[ { "title": "기술블로그 두번째 이전 소식", "url": "/posts/move-tech-blog/", "categories": "Life, Talk", "tags": "", "date": "2025-02-05 00:37:00 +0800", "snippet": "오랫만에 인사드립니다.다름이 아니라, 기술블로그를 이전하게 되었습니다.매번 쓰고싶은 글은 많은데 VSCode를 켜고, Markdown 문서를 만들고, 이미지를 적용해야 하면 이미지를 따로 갖고 오는 등의 절차를 거쳐서 게시하는게 여간 귀찮은게 아니더라구요.높아진 페이지 랭크가 아쉽지 않은 것은 아닙니다만, 페이지 랭크를 걱정하면서 블로그 글을 쓸 때마다 고통을 느끼느니 블로그 플랫폼을 옮기는게 더 생산적인 것 같아 velog로 이전하게 되었어요.새롭게 운영하는 블로그 주소는 아래와 같아요.https://velog.io/@univdev이제 조금 더 잦은 글 리젠과 함께 소통도 원활하게 이어나갈 생각이니 궁금하신 사항 있으시면 언제든 새로운 블로그로 방문 부탁드립니다.감사합니다." }, { "title": "서버와 클라이언트의 우아한(?) 대화 방법, Adapter Pattern (Feat. FSD)", "url": "/posts/adapter-pattern/", "categories": "Tech, Talk", "tags": "Adapter Pattern, FSD, Design Pattern, 디자인 패턴", "date": "2024-09-10 20:30:00 +0800", "snippet": "들어가며우리는 프로젝트를 수행하면서 다양한 케이스를 마주합니다.그 중 가장 만나고 싶지 않은 케이스 중 하나는 Server가 제공하는 데이터의 Interface와 Client에서 사용할 수 있는 Interface가 너무나 상이한 경우일 것입니다.프론트엔드 직군만의 문제가 아니라 프로젝트를 진행하다보면 언젠가 반드시 한 번은 마주하는 개발자의 숙명과 같은 것인데 Interface를 수정하거나 BFF와 같은 추가적인 인프라를 구축하지 못하는 상황에서 사용하면 좋은 방법을 문제 사례와 함께 소개 하고자 합니다.문제 발생 경위문제 상황을 설명 드리기 전에 아래 문제를 이해하기 전에 상황 설명을 먼저 진행해야 할 것 같습니다.여러 이해관계가 얽혀있고 비즈니스적인 요소도 섞여있어서 복잡한 관계는 배제하고 문제 상황을 간단하게 요약하자면 iOS App만 존재하는 서비스가 있습니다. 해당 서비스는 서버에 데이터를 업로드 하지않고 기기에 저장하는 방식으로 구현 되어 있었습니다. 해당 서비스의 Web 버전 런칭을 하자는 안건이 나왔습니다. 내부 사정상 Back-End API 개발을 당장 할 수 없으니 Front-End 개발을 선행하고 Back-End를 나중에 개발하는 방향으로 가닥이 잡힙니다. Front-End에서 미래에 개발 될 기능의 Interface를 유추하여 개발을 완료 했습니다. 모바일 대응 목적으로 Back-End가 API 개발을 완료했습니다. Front-End는 이후 Back-End에서 개발한 API를 확인해보니 Front-End에서 즉각적으로 사용하기 어려운 Interface로 작성 되어 있었습니다. (모바일을 기준으로 만들어졌기 때문) Web 버전으로 API를 새로 제작하려면 시간이 걸리기에 일단 모바일에 기준하여 작성 된 API를 우선 연동해야 하는 상황입니다. BFF는 이후 API의 수정이 발생할 경우 관리 비용이 증가할 우려가 있어 구현하지 않기로 결정했습니다. 읽으시면서 “왜 이렇게 개발하지” 싶은 느낌을 받으셨을 텐데, 회사 내부 상황을 기재하지 않는 선에서 설명한 내용이라 어색함을 느끼시더라도 양해 부탁드립니다 😢문제 상황Server에서는 다음과 같은 Interface로 이루어진 데이터를 제공합니다.{ name: string; note: string; habitRepeat: { weeklyRepeatDays: number[] // enum [1, 2, 4, 8, 16, 32, 64] }}사용자의 ‘습관’을 개선하기 위해 Habit을 생성하고 특정 요일마다 이를 반복하는 기능에 필요한 데이터 구조입니다.weeklyRepeatDays 프로퍼티는 해당 Habit을 무슨 요일마다 반복할 것인지에 대한 Spec입니다.웹 개발자의 도메인 지식으로는 0~6 혹은 1~7 사이 숫자를 배열로 포함하여 ‘어떤 요일에만 반복할 것인지’를 결정한다고 이해할 수 있겠습니다만, 문제는 해당 프로퍼티에 삽입되는 숫자의 규칙이 1, 2, 4 … 64로 이루어진 등비 수열이였습니다.도대체 이건 무슨 규칙인가 싶어 개발자에게 문의 해보니 “왜 그런지 아무도 몰라. iOS에서는 저런식으로 요일 Format을 넣더라고. Web API를 만들 때 이것도 고쳐줄까?”라고 답변이 왔습니다 😱솔루션 정의그렇다면 제가 해야 할 일은 명확합니다. Server Interface에서 넘어오는 등비수열이 각각 일 ~ 토 요일과 매칭 된다는 사실은 확실합니다. 웹에서 개발한 컴포넌트에 맞게 이를 0~6 사이 숫자로 매칭하면 됩니다.AdapterAdapter는 우리가 흔히 해외여행 갈 때 사용하는 돼지코를 의미하는 그 어댑터가 맞습니다.데이터의 Format을 환경에 맞게 변환하는 모습이 마치 전압을 바꾸기 위해 어댑터를 사용하는 모습과 비슷하다고 해서 지어진 이름이라 추측 해봅니다 🤔문제 해결하기 (Feat. FSD)현재 개발 하고 있는 프로젝트는 FSD 아키텍처를 사용하고 있습니다.(언젠가 FSD 아키텍처에 대해 문서로 작성하겠습니다. 많은 기대 부탁드려요 😄)src ㄴ features ㄴ Habits ㄴ helpers ㄴ HabitsIOSAdapter.helper.ts ㄴ entities ㄴ Habits ㄴ types ㄴ Habits.types.ts ㄴ shared ㄴ types ㄴ Adapter.types.ts디렉토리 구조는 위와 같습니다.여기서 주목해야 할 파일은 Habits.types.ts HabitsIOSAdapter.helper.ts Adapter.types.ts입니다.우선 Adapter의 구현체를 작성하기 전에 Interface를 먼저 정의하겠습니다.// shared/types/Adapter.types.tsexport interface Adapter&amp;lt;I, O&amp;gt; { adapt(input: I, ...args: any[]): O}Adapter.types.ts 파일에 앞으로 사용할 모든 Adapter의 Interface를 작성합니다....args 는 추후 adapt 함수를 실구현 할 때 ‘Interface 변경에 필요한 추가적인 데이터’를 매개변수로 전달 받아야 하는 상황에서 확장이 가능하도록 넣어둔 매개변수입니다.위 Interface를 토대로 실제 구현체는 아래와 같이 구현할 수 있습니다.// features/Habits/helpers/HabitsIOSAdapter.helper.tsexport class HabitIOSAdapter implements Adapter&amp;lt;IHabitIOS, IHabitWeb&amp;gt; { public adapt(input: IHabitIOS, otherDependencies: string[]) { return { // Interface를 변경하는 로직 }; }}만약 Interface를 변경하는 로직을 구현하는 과정에서 추가적인 함수 구현이 필요한 경우, 일반적인 Method 구현 방식을 사용하시면 됩니다.// features/Habits/helpers/HabitsIOSAdapter.helper.tsexport class HabitIOSAdapter implements Adapter&amp;lt;IHabitIOS, IHabitWeb&amp;gt; { public adapt(input: IHabitIOS, otherDependencies: string[]) { return { // Interface를 변경하는 로직 }; } private convertWeeklyRepeatDays() { return // ... }}추가적으로 IHabitIOS 와 같은 Interface는 entities 레이어에 있는 Habits.types.ts에 작성 해주시면 됩니다.// entities/Habits/types/Habits.types.tsexport type IHabitIOS = { // ...}export type IHabitWeb = { // ...}무슨 이점이 있을까?Adapter Pattern을 FSD Architecture와 함께 사용한 예시를 보여드렸습니다.이렇게 정리하면 크게 두가지 이점이 있습니다. 파일의 흐름이 shared → entities → features 와 같이 단방향으로 흐르기 때문에 파일간 참조 관계가 명확해집니다. Adapter 클래스를 통해 변환 로직을 한 파일에 집중할 수 있으므로 추후 Interface를 수정하는 등의 작업을 할 때 수정해야 하는 파일이 명확하여 작업 비용이 매우 저렴해집니다.마치며어쩌다보니 Adapter Pattern과 함께 FSD까지 같이 설명드리게 되었는데요.‘은총알은 없다’ 라고들 하지만 상당히 많은 프로젝트에 사용할 수 있는 공통적인 패턴은 존재하기에 ‘디자인 패턴’의 존재가 성립할 수 있는거겠죠.FSD는 요즘 제가 실무에서 애용하고 있는 아키텍처입니다.언젠가 기회가 되면 FSD에 대해서도 작성해보도록 하겠습니다.만약 그 때가 되면 이 글 마지막에 링크를 첨부하겠습니다.긴 글 읽어주셔서 감사합니다! 👏" }, { "title": "프로그래밍 교육을 진행해보며 느낀점 (멘토 활동 중간 회고)", "url": "/posts/experience-teacher/", "categories": "Life, Talk", "tags": "교육, Education, 프로그래밍", "date": "2024-09-03 09:31:00 +0800", "snippet": "들어가며저는 웹 개발 관련 교육 활동을 진행하고 있습니다.물론 본업은 따로 있는지라 온전히 교육 활동에만 힘을 쓰고 있는 것은 아니기에 전업 강사분들과 비할 바는 못되지만 나름대로 교육 활동을 누적 2년 정도 진행하고 있는 주니어 강사라고 생각해주시면 감사할 것 같습니다.제 교육 커리어의 시작은 제가 졸업한 모교에서 시작 되었습니다.어쩌다보니 기회가 닿게 되어 기능반(프로그래밍 대회 준비반) 강사를 했던 경험을 시작으로 교육에 흥미가 있다는 것을 알게 되었고 그게 연이 되어 총 3개의 고등학교를 전전하며 짧게 강의를 진행했었어요.대학교를 휴학하고 본업을 갖게 된 이후로 현실이 바빠 오프라인 강의는 진행하고 있지 못하지만(기회가 된다면 언제든지 할 의향이 있습니다.) 현재는 원격 환경에서 1:1 멘토링을 부업 느낌으로 진행하고 있습니다.여담이지만 현재 진행하고 있는 멘토링과 고등학교 오프라인 강의를 놓고 비교해보자면 확실히 멘토링쪽이 학생분들의 열의가 더 대단하다고 느꼈던 것 같습니다.아무래도 자발적으로 니즈를 느끼고 참여하신 분들이라 그런 것 같다고 생각이 되네요.현재 진행하는 멘토링은 OT를 먼저 1:1로 진행하고 진행 여부를 결정하시는데도 불구하고 벌써 10명 이상의 수강생 분들이 저와 함께 해주시기를 희망하셨다는게 언제나 감사할 따름입니다.아무튼 오늘은 이러한 활동을 n개월 째 지속하면서 느낀 점들을 공유하고 실수를 반성하면서 앞으로 진행할 멘토링을 개선할 수 있는 회고록을 작성해보고자 합니다.멘토링을 시작하게 된 계기위에서도 말씀 드렸듯이 모교 강사 활동을 시작으로 교육에 흥미를 갖기 시작했습니다.본업 문제로 인해 잠시 접어두었지만 언제나 열의만큼은 있었기 때문에 기회를 찾고 있었던 참에 Okky 커뮤니티에서 멘토링 강사 모집 공고를 보고 지원하게 되어 지금 소속 된 멘토 플랫폼과 연이 닿았습니다.운이 좋았던거죠.어느정도 가볍게 접근한 느낌도 없지 않아 있습니다만 멘토링 활동은 약간 제 한(?)이 서려있는 활동이기도 합니다.저는 커리어의 시작을 6인 규모의 스타트업에서 시작했습니다.제가 해당 회사에서 오프보드를 밟을 시점에는 20명 이상의 규모로 성장 하기는 했었지만 아무래도 작은 기업에서 사용할 수 있는 리소스에는 한계가 있었고 그렇다보니 저에게 기술적으로 뭔가를 코칭해 줄 분이 없었습니다.결국 혼자 맨땅에서 삽질하듯 배워나가 남들은 2년, 3년 안에 배웠을 지식을 5년차 때 알게 되는 경우도 많았었어요.멘토링을 시작한 이유는 ‘내가 다른 분들의 사수가 되었으면 좋겠다’ 하는 마음이 작용 했다고 생각합니다.흑역사인생 썰좀 그만 풀어라‘누군가를 가르치는 경험’ 자체가 없었던 커리어 초반에는 뭔가 여러가지를 시도해보고 싶어서 대회를 준비 하는 학생들에게 제가 대회를 나갔었던 시절 겪었던 일화들을 설명하면서 시간을 보냈었어요.그런데 썰을 풀다보니 재밌어져서 계속 그런 썰만 풀다가 시간을 보내게 되었고 ‘인생 얘기만 하다가 시간 태우는 강사’가 되어버렸던 적도 있었습니다. (지금은 반성 많이 하고 있어요)커리큘럼은 가져와야지웹 개발에 대해서 가르치고자 할 때 ‘내가 어지간한건 웹으로 다 만들어 봤으니까 주제 하나 던져주고 모르면 알려줘야지’ 라는 막연한 생각으로 강의를 시작했다가 호되게 혼났던 경험도 있었습니다.학생분들은 ‘이 분야 자체를 모르고 도전’하는 경우가 많았는데 그런 분들은 본인이 어떤걸 해야하고 어떤걸 모르는지 모르는 상태라는걸 몰랐던거죠.그래서 멘토링을 진행하다가 학생분은 질문 자체를 할 수가 없었고 저는 질문을 받지 못하니 어떤 피드백도 할 수 없었던 경험도 있었습니다.요즘은 어떤데요즘은 위와 같은 경험을 토대로 커리큘럼도 만들어서 개발자를 희망하시는 분들께 나름의 만족감을 드리며 멘토링을 진행하고 있다고 생각합니다.실제로 전체 학생의 80%가 멘토링 기간 연장을 신청 해주시거든요. (정말 감사합니다)그리고 제가 소속 된 멘토링 플랫폼은 강의 진행 결정 이전에 OT를 1회 진행하는데 제가 진행하는 OT를 보고 좋은 리뷰를 남겨주시기도 하셔서 이 부분에서 힘을 받고 있습니다.마치며언젠가는 직접 책도 써보고 강연도 진행해보고 싶습니다.그렇기엔 아직 갈 길이 멀다고 생각하지만 그만큼 노력한다면 그렇게 먼 미래의 일도 아닐 것 같다는 근거 없는 자신감도 생깁니다.이 생각이 먼 미래에도 변함 없다면 좋겠다 생각하며 긴 글 마칩니다.감사합니다." }, { "title": "사용자 경험 증대를 위한 낙관적 업데이트 (feat. React Query)", "url": "/posts/optimistic-update/", "categories": "Tech, Talk", "tags": "React Query, Optimistic Update, 낙관적 업데이트, UX", "date": "2024-08-29 13:57:00 +0800", "snippet": "낙관적 업데이트 (Optimistic Update)낙관적 업데이트는 서버 혹은 외부 디펜던시에 의존하는 업데이트 요청이 ‘반드시 성공할 것’ 이라는 믿음 하에 구현하는 업데이트 방식입니다.비동기 요청의 문제점주로 외부 디펜던시에 의존하는 업데이트 방식 (게시글의 작성 혹은 수정)은 비동기 요청으로 진행합니다.이렇게 처리하는 요청의 경우 응답이 돌아올 때 까지 짧게는 수 ms에서 부터 길게는 10s가 넘는 시간이 소요 될 수 있습니다.이런 경우 대부분의 프론트엔드 개발자는 이러한 비동기 요청이 수행되는 과정에서 사용자가 불편함을 느끼지 않도록 Loading Indicator 혹은 Skeleton UI 등의 요소로 “저 지금 열심히 당신의 요청을 처리하고 있어요” 라고 어필을 해야 합니다.하지만 이러한 로딩 방식은 뭔가 조금 아쉽습니다.Skeleton UI나 Loading Indicator 방식은 작업 상황이 업데이트 중임을 알려줄 수는 있어도 결국 작업 상황이 완료되지 못한 상태이기 때문에 유의미한 결과를 반영하진 않기 때문입니다.낙관적 업데이트의 Principle낙관적 업데이트를 구현하기 위한 원칙(Principle)은 ‘사용자가 낙관적 업데이트를 수행할 수 있는 정보를 제공하느냐’가 관건입니다.예를 들자면 사용자가 게시글을 작성하는 경우 아래와 같은 Payload를 제공할 것입니다.{ title: string; content: string; files: (File | string)[];}위와 같이 사용자가 제공한 정보는 게시글 상세 페이지와 목록 페이지를 구현하는데 있어 가장 핵심적인 데이터를 제공하고 있습니다.낙관적 업데이트는 사용자가 요청을 보낼 때 제공한 데이터를 기반으로 ‘서버에 반영되지 않은 가짜 데이터’를 UI에 선반영 하는 방식으로 구현하기에, 사용자가 보낸 데이터가 UI를 구성하는데 부족함이 없는지 우선적으로 판단해야 합니다.React Query를 이용하여 간단하게 적용해보자useQuery의 동작 원리우리는 React에서 서버 및 외부 디펜던시와 요청을 주고 받을 때 React Query를 주로 사용합니다.React Query는 이러한 쓰임에 맞게 낙관적 업데이트를 쉽게 구현할 수 있는 여러 툴킷을 제공하기에 직접 해당 기능을 구현하는 것 보다 매우 쉽게 낙관적 업데이트를 구현할 수 있습니다.일반적으로 어떤 데이터를 Fetching 할 때 다음과 같은 코드를 작성할 것입니다.const usePostListQuery = () =&amp;gt; { const query = useQuery({ queryKey: [&#39;post&#39;, &#39;all&#39;], queryFn: () =&amp;gt; ..., staleTime: 1000 * 60 * 5, // 5분 간격으로 데이터를 Refetch });}React Query는 In-memory Cache를 구현하기 위해 Query Client라는 객체를 앱 전역적으로 공유하여 사용합니다.다시 말해, useQuery 훅을 이용하여 캐싱한 데이터는 Query Client 내부에 저장되어 앱 전역적으로 공유되고 있다는 뜻입니다.useQuery를 사용할 때 필수적으로 제공하는 프로퍼티인 queryKey는 이러한 캐싱 메커니즘에서 데이터를 저장하는 위치를 지칭할 때 사용하기 때문에 이를 이용하여 데이터 업데이트 요청 시 인위적으로 Query Client에 적용 된 데이터를 수정하는 것이 가능합니다.낙관적 업데이트는 위에서 설명한 기능을 토대로 캐싱 된 데이터를 인위적으로 수정하여 UI에 반영하는 방식입니다.useMutation에서 인위적으로 데이터 수정하기React Query를 사용하여 서버 데이터를 업데이트 할 때 useMutation 훅을 사용합니다.const useCreatePostMutation = () =&amp;gt; { const mutation = useMutation({ mutationFn: (payload) =&amp;gt; ..., });}useMutation 훅에는 onMutate onSettled onSuccess onError와 같이 다양한 이벤트를 핸들링할 수 있도록 Callback을 전달할 수 있는 프로퍼티를 지원합니다. onMutate - 요청 시작 onSettled - 응답 결과에 상관 없이 요청이 종료되면 발생 onSuccess - mutationFn에 전달한 함수의 결과가 resolve일 경우 onError - mutationFn에 전달한 함수의 결과가 reject일 경우낙관적 업데이트의 경우 ‘UI의 선반영’ 을 목적으로 하기 때문에 onMutate 를 이용합니다.코드로 작성하면 아래와 같습니다.const useCreatePostMutation = () =&amp;gt; { const queryClient = useQueryClient(); const mutation = useMutation({ mutationFn: (payload) =&amp;gt; ..., onMutate: (_, payload) =&amp;gt; { queryClient.getQueryCache().findAll({ queryKey: [&#39;post&#39;, &#39;all&#39;] }) .map((cache) =&amp;gt; { const data = queryClient.getQueryData(cache.queryKey); queryClient.setQueryData(cache.queryKey, { data: [...data, { ...payload }] }); }); }, });}useQueryClient 훅을 사용하면 Query Client 바운더리 내부에서 Query Client에 대한 정보를 호출할 수 있습니다.Query Client 인스턴스에는 getQueryCache getQueryData setQueryData 등 현재 캐싱 데이터 맵을 제어할 수 있는 여러 메소드가 존재합니다.getQueryData와 setQueryData는 queryKey 프로퍼티를 통해 저장 된 데이터의 읽기 및 쓰기가 가능하지만 queryKey가 정확히 기입 된 데이터에 대해서만 대응이 가능하기 때문에 getQueryCache 메소드를 통해 queryKey에 대한 검색을 선행하고, 검색 된 Cache에서 Query Key를 직접 호출하여 제어하는 방식으로 사용합니다.낙관적 업데이트 구현 방법 정리 [&#39;post&#39;, &#39;all&#39;, { perPage: 100, page: 1 }] 과 같은 형태로 기입 된 캐시 데이터의 경우 Query Key를 온전히 동일하게 삽입하여 수정하는게 사실상 불가능함 그렇기에 getQueryCache 메소드를 사용하여 [&#39;post&#39;, &#39;all&#39;] 로 시작하는 Query Key를 검색하여 매칭 된 전체 캐시를 불러옴 .forEach로 반복하여 해당 캐시의 Query Key를 정확히 불러온 뒤 getQueryData 및 setQueryData로 캐싱 된 데이터를 수정함네트워크 요청이 실패한다면?낙관적 업데이트의 가정 자체가 ‘반드시 성공할 것’ 이기 때문에 디펜던시의 안정성을 신용하여 업데이트를 선행합니다.하지만 디펜던시를 절대적으로 신용하는 것은 매우 위험한 행동이기에, 요청이 실패할 경우에 대한 예외 처리를 반드시 구현해야 합니다.해결책이야 다양하겠지만 가장 많이 쓰는 방식은 ‘선반영한 데이터를 원래 데이터로 돌려놓는 방식’ 이기에 저 역시 이 방법을 사용하겠습니다.저는 해당 작업을 ‘롤백(Rollback)’이라고 표현 하겠습니다.롤백 기능 구현 방법useMutation 훅의 onMutate와 onSuccess onSettled onError 이벤트는 데이터를 단방향으로 전송할 수 있습니다.onMutate에서 어떤 데이터를 Return 하면 onSettled onSuccess onError의 세번째 매개변수에서 해당 Return 값을 받아오는 것이 가능합니다. const useCreatePostMutation = () =&amp;gt; { const queryClient = useQueryClient(); const mutation = useMutation({ mutationFn: (payload) =&amp;gt; ..., onMutate: (_, payload) =&amp;gt; { const previousPostListData = new Map&amp;lt;QueryKey, Data&amp;gt;(); queryClient.getQueryCache().findAll({ queryKey: [&#39;post&#39;, &#39;all&#39;] }) .map((cache) =&amp;gt; { const data = queryClient.getQueryData(cache.queryKey); queryClient.setQueryData(cache.queryKey, { data: [...data, { ...payload }] }); previousPostListData.set(cache.queryKey, data); }); return { previousPostListData, }; }, });}위 로직은 previousPostListData 라는 Map 변수를 onMutate에서 Return 하는 로직이 추가 되었습니다.낙관적 업데이트를 수행하는 도중 .forEach 내부에서 기존 데이터를 Map에 삽입하고 onMutate 의 반환 값으로 사용합니다.최종적으로는 onSettle onError onSuccess 에서 다음과 같이 받아올 수 있습니다. const useCreatePostMutation = () =&amp;gt; { const queryClient = useQueryClient(); const mutation = useMutation({ mutationFn: (payload) =&amp;gt; ..., onMutate: (_, payload) =&amp;gt; { const previousPostListData = new Map&amp;lt;QueryKey, Data&amp;gt;(); queryClient.getQueryCache().findAll({ queryKey: [&#39;post&#39;, &#39;all&#39;] }) .map((cache) =&amp;gt; { const data = queryClient.getQueryData(cache.queryKey); queryClient.setQueryData(cache.queryKey, { data: [...data, { ...payload }] }); previousPostListData.set(cache.queryKey, data); }); return { previousPostListData, }; }, onError: (_, __, ctx) =&amp;gt; { if (ctx?.previousPostListData) { // ... } } });}onError Callback의 세번째 매개변수로 previousPostListData 를 받아올 수 있습니다.언제나 유효하게 존재하는 값이 아닐 수 있기 때문에 if문 등을 사용하여 유효한 값인지 검사를 진행한 후 롤백 로직을 구현하면 됩니다.{ // ... useMutation 로직들 onError: (_, __, ctx) =&amp;gt; { if (ctx?.previousPostListData) { ctx.previousPostListData.forEach((value, queryKey) =&amp;gt; { queryClient.setQueryData(queryKey, value); }); } }} 롤백 로직은 위와 같이 구현 하실 수 있습니다.queryKey 와 이전 데이터를 Key-Value 쌍으로 가진 Map을 반복하여 queryClient의 데이터를 Set 하는 방식으로 아주 간단히 롤백 로직을 구현 하실 수 있습니다.데이터 최신화아마 눈치가 빠르신 분이라면 사용자가 기입한 데이터를 선반영 하는 작업만 수행해서는 부족하다는 것을 눈치 채셨을 겁니다.그 이유는 사용자가 데이터를 기입할 때 데이터의 PK를 같이 전달하지는 않기 때문입니다.대부분의 경우 서버에 저장 된 데이터를 읽거나 새로 쓰기 위해서 PK를 사용합니다.그렇기 때문에 프론트엔드에서 게시물 상세 조회 페이지의 라우트를 구현할 때 /pages/a40efAC32 와 같이 ‘조회하고 있는 데이터의 PK’ 를 path 혹은 SearchParams로 전달하여 데이터를 호출합니다.위에서 작성한 선반영 로직만을 기입하면 해당 데이터가 서버에 어떤 PK로 등록 되었는지 알 수 있는 방법이 없기 때문에 선반영 이후 네트워크에서 응답이 돌아오면 최신 데이터로 갱신하는 작업이 수반 되어야 합니다.React Query는 이런 케이스도 아주 간단히 처리할 수 있도록 도와줍니다.{ // ...useMutate 로직 onSuccess: () =&amp;gt; { queryClient.invalidateQueries({ queryKey: [&#39;post&#39;, &#39;all&#39;] }); }}위 코드처럼 단 한줄만 추가하면 기존 캐싱 된 데이터를 모두 Stale 상태로 변경하여 해당 데이터를 사용하는 페이지에 방문할 때 Fetch를 진행합니다.위에서 사용한 setQueryData 혹은 getQueryData와 다른점은 Query Key가 부분 매칭 되어도 모두 만료 처리 하기 때문에 getQueryCache 메소드로 모든 캐시 데이터를 검색할 필요가 없다는 점입니다.마치며이번 문서에서는 Loading Indicator나 Skeleton UI보다 훨씬 진보 된 로딩 화면을 구현하는 방법에 대해서 알아 봤습니다.저도 비교적 최근에 낙관적 업데이트를 도입해 봤는데 프론트엔드에서 UX를 개선하는 방법은 공부 하면 할수록 다양하다는 것을 느낍니다.이 문서를 통해 여러분도 저와 같은 감상을 느끼고, 낙관적 업데이트를 도입 해보시면서 보다 나은 사용성의 앱을 세상에 많이 공개 해주시면 더할 나위 없이 기쁠 것 같습니다.감사합니다." }, { "title": "2024 서울 코믹월드 부스 참여한 썰 풉니다", "url": "/posts/2024-seoul-comicworld-ssul/", "categories": "Life, Talk", "tags": "서울 코믹월드, 게임, 부스, Unity, Seoul Comicworld, Comic World", "date": "2024-07-23 13:18:00 +0800", "snippet": "이 글은 프론트엔드에 관한 글이 아닐 수 있으며 다소의 오타쿠 문화가 첨가 되어 있습니다.만약 이러한 글이 취향이 맞지 않으시다면 제 블로그에 다른 좋은 글들도 많으니 한번 쯤 읽고 가주시면 감사하겠습니다.요즘 프론트엔드가 재밌지가 않아요최근에 굉장히 새롭고 재밌는 경험을 하게 되어 이 경험을 공유하고자 합니다.대충 요약하면 요즘 동기부여 안된다는 글제 링크드인 에서도 한 번 언급했던 내용이긴 합니다만, 저는 요즘 프론트엔드 개발이 재미가 없습니다.막 하기 싫고 그런건 아닌데, 그냥 예전처럼 재밌다는 기분이 별로 들지가 않습니다.이 상태가 계속 이어지게 되면 결국에는 번아웃으로 이어지게 될 것이고 최악의 상황에는 제 개발자 커리어에도 지장이 갈 수 있기 때문에 이 분위기를 환기 해 줄 필요가 있다 생각 되었습니다.시선을 돌려보자근데 솔직히 프론트엔드 개발에 대한 흥미가 떨어진 이 상황이 따지고 보면 그리 이상한 일은 아닐 겁니다.아무리 재미있는 게임이여도 10년 넘게 그것만 하고 있다보면 질릴 텐데 개발이라고 다르진 않을 것 같거든요.게임이 재미가 없을 때는 다른 게임을 찾아서 나서 듯이, 프론트엔드 개발 말고 평소에 배워보고 싶었던 것을 배우면 어떨까 싶었습니다.그러던 도중 눈에 들어오던게 ‘게임’이었습니다.원래 제가 개발자를 희망하게 되었던 계기도 다름 아닌 게임이라 다시 초심으로 돌아가 보는 것이 어떨까 생각하게 되었습니다.초등학생 때 한참 활동 했었던 플래시 게임 커뮤니티. 지금은 접속할 수 없다.뭘 만들면 좋을까언제나 고민 되는 주제입니다.새로운 프로그래밍 언어와 제작 프로세스를 배우기 위해서는 실제로 만들어 보는게 최고라는게 제 생각인데, 항상 뭔가를 만들려고 보면 뭘 만들지 생각이 안난다는게 가장 큰 문제거든요.그래서 게임을 만들고 싶다는 생각만 가득 품은 채 실제 행동으로 옮기는 데는 조금 시간이 걸렸습니다.계기는 예상치 못한 곳에서 찾아온다게임을 만들어 보자는 원대한 계획은 제 마음 속에서만 머무른 채 시간만 계속 지날 무렵, 저는 훈련소 시절 친구를 만나기 위해 ‘서울 코믹월드’ 에 방문하게 되었습니다.이 친구는 서브컬처 업계에서 일을 하고 있기 때문에 본인이 제작한 굿즈 판매 등을 하기 위해 주기적으로 이런 행사에 나온다고 합니다.이 친구도 볼 겸, 운영하는 부스도 구경할 겸 일산 킨텍스로 향하게 되었습니다.계획대로 친구도 만나고 부스 구경도 끝난 무렵에 다른 부스들은 어떤 것을 팔고 있나 구경을 하기 시작했습니다.여러 부스가 있었지만 제 눈길을 사로 잡았던 부스는 따로 있었는데, 그 부스는 굿즈를 파는 일반적인 부스였으나 다른 부스와 차별 점을 두기 위해 자체 제작한 게임을 홍보 수단으로 사용하고 있던 것입니다.물론 게임 아이디어는 어딘가에서 봤던 게임을 그대로 제작한 듯 했지만 부스 홍보 수단의 게임 이라는 참신한 아이디어는 제 창작욕에 불을 지피기 충분했습니다.“고작 그게 뭐라고 그렇게 까지?” 싶으실 수 있는데 제 생각이 행동으로 쉽사리 나오지 못하는 이유는 크게 두 가지입니다. 이걸 어디부터 시작해야 하지? 이걸 해서 얻는게 뭐지?위와 같은 고민들이 해결되지 못하기 때문에 쉽사리 행동으로 옮겨지질 못하고 있었습니다.그런데 명확한 목적이 생긴다면 이야기는 달라집니다.명확한 목적은 작업의 범위와 동기를 부여해주고 제가 다른 짓을 못하게 붙잡아 두는 좋은 수단이기 때문입니다.분명 가볍게 시작하려 했는데하지만 첫 작품부터 성대할 수는 없는 법이기에 가볍게 마음을 먹고 작업에 착수하고자 친구에게 문자를 날렸습니다.저는 그저 일러스트레이터인 친구한테 부탁하면 여태까지 그린 그림이 많을테니 그 중에서 몇 개 정도 따줄 수 있지 않을까 하는 마음에 가볍게 물어봤습니다.그러자 이 친구는 아예 처음부터 다시 그려줌과 동시에 게임에 등장하는 굿즈를 실물로 제작해서 판매 하자는 원대한 계획까지 제안 하게 되고 제 초기 생각과는 다르게 굉장한 스케일로 커지고 있었습니다.까짓거 함 해보죠 뭐게임 주제 정하기여차저차 해서 초기 계획과는 다르게 너무나 원대해진 계획을 통해 만들고자 정해진 게임은 위 채팅에서도 보실 수 있듯이 ‘수박 게임’의 레플리카 였습니다.유튜브 알고리즘을 지배했었던 수박 게임이 게임을 지정한 데에는 나름의 이유가 있습니다. 퍼즐 게임의 특성 상 App-Like 게임으로 제작하기 쉽고 게임 규칙이 단순해서 추가적인 이해나 설명이 필요하지 않으며 게임 제작에 익숙치 않은 제가 제작할 수 있을법한 제작 난이도가 그리 높지 않은 게임이기 때문입니다.플랫폼 정하기행사를 둘러보는 사람들이 타겟이므로 부스 앞에서 QR코드로 인식하여 플레이 할 수 있도록 모바일 대상 플레이어로 한정하여 제작했습니다.배포 인프라 정하기이 부분에서 고민을 조금 많이 했습니다.서울 코믹월드 특성 상 2차 창작 굿즈가 대세이기 때문에 저희가 제작할 게임도 2차 창작물이기 때문입니다.구글 플레이스토어는 2차 창작 앱도 여러번 보았기 때문에 이 부분에서 문제가 그다지 되지 않으리라 예상 되었지만 문제는 아이폰 사용자들을 위한 앱을 어떻게 배포하느냐 였습니다.App Store는 구글 플레이스토어와 다르게 2차 창작물이 배포 되기 어려운 환경일 뿐더러 일정 수준 이상의 퀄리티가 보장 되지 않으면 배포 단계에서부터 문제가 생깁니다.그렇다고 행사장에서 플레이 하고자 마음 먹은 아이폰 유저를 내칠 수도 없는 노릇 이기에 최종적으로 결정한 플랫폼은 웹이 되었습니다.Unity 기반으로 제작 된 게임은 WebGL 기반의 빌드를 매우 간단하게 할 수 있기도 하구요.또한 웹 플랫폼 특성상 Provider의 심사와 같은 제약이 없기 때문에 지금 같은 상황에 최적의 플랫폼이라 판단했습니다.레벨 디자인레벨 디자인은 초기 12레벨까지 구현하려고 했습니다.워낙 하고 싶은 것도 많았고 난이도가 제법 있어야 클리어 했을 때의 성취감이 있을 것이라는 판단이었어요.하지만 다시 우리의 유저를 생각했을 때 12레벨은 현실적으로 무리가 있다고 판단 되었습니다.보상을 얻기 위한 허들이 너무 높으면 안됐고, 이전에도 말씀 드렸듯이 부스를 탐방해야 하는 행사 특성 상 한 곳에서 시간을 오래 투자하기란 힘들기 때문이었어요.최종적으로는 9레벨로 축약하여 게임에 반영하였고 이 판단은 행사장에서 빛을 발하게 되었습니다.Scene 설계Scene은 Unity에서 게임을 구성하는 여러 페이지를 나타냅니다.게임을 계획했던 초기에는 홈 화면, 게임 화면, 결과 화면 총 3가지로 구성을 하고자 했으나 주어진 시간이 그렇게 많지 않았기에 홈 화면과 게임 화면 두가지로 구성하고 나머지는 Dialog로 풀어내게 되었습니다.그렇게 제작 된 홈 스크린과 게임 스크린화면 비율 설정과 반응형 UI 구성게임을 플레이 할 유저층이 모바일 유저이기에 화면 비율은 9:16 으로 구성하였습니다.세로 화면으로 플레이 하는 모바일 게임은 일반 데스크탑 모니터 비율의 반대를 갖기에 실제 게임 개발 당시에도 게임 스크린 기준점을 1080 x 1920으로 설정하고 작업했습니다.반응형 UI는 웹과 다르게 게임에서는 신경 써야 할 부분이 매우 많다고 느꼈습니다.Button UI를 코드로 구성하여 런타임에 계산하는 웹과는 다르게 이미지를 활용하여 구성해야 했기 때문에 비율을 신경써야 해서 크기와 레이아웃 배치에 보다 공을 많이 들였습니다.그리고 각각의 요소들이 배치 되는 기준점 (Anchor)을 직접 조정하여 캔버스에 배치해야 여러 사이즈에서 각각의 요소들이 제 위치에 배치 되기 때문에 이 개념을 이해하느라 시간을 다소 할애했습니다.이제 와서 생각해보니까 CSS의 Left, Top으로 배치하는 Absolute 요소의 개념과 크게 차이가 없었던 부분이네요.그 외에도 수많은 배경지식을 학습하고 이해 하느라 삽질을 좀 많이 했습니다. width: 100%과 비슷한 포지션을 갖는 Stretch Canvas를 렌더링 하는 기준을 설정하는 Render Mode 설정 방법 게임 영역 바깥에 오브젝트가 탈출하게 되면 잔상이 남는 이슈위와 같은 이슈들을 해결 하다보니 확실히 새로운 영역으로의 도전은 쉽지가 않다는 생각이 들었습니다.행사 당일행사장 도착 후 준비부스 참가자 입구로 들어가는 날이 다 오네자차로 50분을 내달려 일산 킨텍스에 도착했습니다.비가 내린 날인데도 불구하고 입구부터 다양한(?) 목적으로 방문하신 분들이 행사장 입구에서부터 모여계셨는데 이 분들이 서계신 줄이 아니라 부스 참가자 입구로 들어서면서 영문 모를 승리감이 느껴졌습니다.테마파크에서 패스트 패스 구입하신 분들이 이런 기분이셨을까요제 친구는 저보다 한 시간 일찍 행사장으로 출발하여 부스 설치를 마무리한 시점이었습니다.물론 제 친구에게 얹혀서 참가하는 입장이긴 하지만 나름 공동 참가자인데 부스 설치를 같이 진행하지 못한 부분에서 조금 미안하다는 생각이 들었습니다.먼저 와서 자리 깔고있는 내 친구E열에 배치 된 부스에 도착하고나니 친구가 오밤중에 프린트한 게임 웹사이트 접속용 QR코드 종이가 눈에 띄었습니다.이번 부스를 오픈하는데 도움을 준 다른 분들과도 인사를 나누고 났는데도 손님들이 오시려면 아직 시간이 남았기에 다른 부스의 오픈 과정을 구경했습니다.행사 시작실제로 행사가 시작되고 나니 수많은 사람들이 부스 앞을 지나다니는 모습을 보게 되었습니다.인기 작가의 부스에는 줄을 관리 해주는 인원이 따로 챙겨야 할 정도로 줄이 길게 서기도 하고, 어떤 작가 분은 팬이 직접 방문하여 인사를 나누고 악수도 하는 모습을 보고 있으니 제가 몰랐던 업계의 일면을 보는 것 같아 굉장히 신기했습니다.제 친구도 나름 이런 부분에서 팬층이 꽤 있는지 ‘커뮤니티 보고 왔어요’ 라는 인삿말과 함께 음료와 빵을 건네주는 분들이 꽤나 많이 방문하더라구요.실제 유저를 만나다부스에 방문하는 방문객 분들 중 예상보다 많은 분들께서 게임 플레이에 참여해주셨습니다.그 중에서 가장 기억에 남으시는 분은 휴가를 받고 행사장에 오신 현역 군인 분이셨는데요.게임에 나름 열심히 도전 해주셨지만 생각보다 긴 플레이타임에 결국 최종 퍼즐까지 완성하시진 못하시고 돌아가시는 모습을 보았습니다.최대한 플레이타임을 짧게 가져간다고 노력했는데 현장은 그보다 더욱 촉박했다는 것을 간과했습니다.그럼에도 불구하고 끝까지 현장에서 플레이 해주신 분들이 인증을 해주셔서 더욱 감사함을 느끼게 된 하루였습니다.클리어 인증을 해주신 분들이 굉장히 많았다눈 앞에서 받은 이슈 리포팅현업에서 나름 오래 있으면서 마이너한 이슈에 대한 리포팅은 VOC를 통해 많이 받아봤고 이에 대해 익숙해졌다고 생각했는데 실제 유저가 눈 앞에서 이슈 리포팅을 하는건 완전 색다른 경험이었습니다.특정 기종에서 접속하면 시작 버튼이 가로로 쭉 늘어져 보인다던가, 오브젝트가 화면 바깥으로 나가는 등의 이슈가 제보 되었을 때에는 진심으로 어딘가에 숨고 싶다는 생각이 들 정도로 부끄러웠거든요.현장에서 이슈 핫픽스 하고있는 개발자현장에서 버그가 발생하면 바로 대응하기 위해 현장에 직접 노트북을 들고 간 보람이 있는 하루였습니다 😢후기여러모로 부끄러운 상황도 많이 있었지만 진심으로 색다르고 재미있는 경험이였다고 생각하고 다음번에도 참가하고 싶다는 생각이 들정도로 뜻 깊었습니다.새로운 기술을 배우는건 익숙한 기술을 사용하는 것 보다 많이 더디고 힘든 과정이라고 생각합니다.그런 과정을 딛고 게임을 만들고 사람들이 눈 앞에서 즐겨주시는 모습을 보니까 이런게 바로 창작자의 동력이 아닌가 다시금 느끼게 된 순간이였습니다.위에서 만든 게임은 비록 저의 수 십 시간이 들어간 수익 0원의 게임이지만 이 날의 경험을 토대로 언젠가는 저만의 게임을 만들어서 수익도 내보고 싶습니다." }, { "title": "Mac OS Unity에서 VSCode를 사용하기 위한 설정 방법", "url": "/posts/unity-vscode-setting-for-mac/", "categories": "Tech, Unity", "tags": "Unity, VSCode", "date": "2024-05-29 10:18:00 +0800", "snippet": "들어가며Unity를 처음 설치하고나면 ‘Visual Studio for Mac’이라는 IDE가 함께 설치되어 기본 에디터로 사용됩니다.해당 IDE는 Unity Script를 작성할 때 사용되는데, 상당히 많은 개발자들이 기본 IDE인 Visual Studio를 그대로 사용하기보다 상대적으로 친숙한 Visual Studio Code를 사용하는 편입니다.이 문서에서는 Mac OS + Unity 환경에서 Visual Studio Code를 사용하기 위해 필요한 초기 설정 방법을 기술합니다.생각보다 간단함에도 불구하고 다른 블로그에서 나와있는 방법이 저에게 효과가 없었어서 기존 다른 블로그에 기술 되어있는 내용에 더해 제가 추가적으로 시행한 방법을 추가적으로 기술하였습니다.Unity 설치하기Unity를 설치하기 위해 Unity Hub를 먼저 설치 해주셔야 합니다.Unity Hub는 에디터를 비롯한 게임 개발에 필요한 교육자료 및 패키지를 통합적으로 관리하기 위한 소프트웨어입니다.Mac OS는 여기에서 Hub를 다운로드 해야 합니다.Unity Hub를 설치 후 실행하면 다음과 같은 화면이 표시 됩니다.아마 Unity가 설치 되어 있지 않으실테니 [Install Editor] 버튼을 눌러 원하시는 버전의 Unity 설치를 진행해주세요.Unity 실행하기설치 된 Unity를 실행하기 위해서는 프로젝트를 생성하셔야 합니다.Unity Hub 좌측 네비게이션을 보시면 [Projects] 버튼이 있는데 해당 버튼을 클릭하면 아래 사진과 같은 화면이 표시 됩니다.우측 상단에 있는 [New Project] 버튼을 클릭하셔서 프로젝트를 생성해주세요.원래라면 해당 화면에서 개발하실 게임의 성격에 맞는 템플릿을 고르셔야 하겠지만 지금은 Unity 에디터를 켜는게 중요하기 때문에 아무거나 생성하시면 됩니다.프로젝트 생성을 무사히 마치셨다면 프로젝트를 선택하여 Unity 에디터를 여실 수 있습니다.Unity IDE 변경하기[Unity] -&amp;gt; [Settings] 메뉴를 순서대로 누르면 아래 사진과 같이 ‘Preference’ 탭이 열리게 됩니다.[External Tools] 메뉴를 선택하시면 ‘External Script Editor’ 라는 항목이 보이게 되는데, 기본 설정은 ‘Visual Studio for Mac’ 으로 되어 있을 것입니다.해당 항목을 ‘Visual Studio Code’로 변경해주시면 됩니다.(만약 해당 항목이 존재하지 않는다면 ‘Browse…’ 를 눌러 컴퓨터에 설치 된 VSCode 프로그램을 직접 찾아 선택하는 방식으로도 해결하실 수 있습니다.)Visual Studio Code Intellisense 문제 해결하기Unity에서 VSCode를 연결하는 과정은 문제 없이 수행했으나, 이후 스크립트를 작성하려고 하면 자동완성이 되지 않는 문제로 인해 당황하게 됩니다.여기부터가 본 문서를 작성하게 된 이유이자 핵심이니 잘 따라해주시기 바랍니다.VSCode Extensions 설치하기우선 아래 Extension을 모두 설치해주시기 바랍니다. C# C# Dev Kit Unity.NET 관련 소프트웨어 설치하기VSCode Extension을 모두 설치하셨다면 컴퓨터에 설치해주셔야 하는 소프트웨어가 두 개 있습니다. Mono .NET Framework (‘최신’이라는 표시가 붙은 버전으로 설치하시길 권장합니다.)위 소프트웨어를 모두 설치하시고 VSCode를 실행하시면 성공적으로 동작하는 경우가 있고, 저처럼 자동완성이 여전히 동작하지 않는 경우가 있습니다.만약 자동완성이 제대로 동작하지 않으신다면 VSCode를 켰을 때 높은 확률로 다음과 같은 오류를 보셨을 것입니다.컴퓨터에 .NET이 성공적으로 설치가 되었으나 Visual Studio Code가 해당 프레임워크를 실행하려면 컴퓨터가 해당 프로그램이 설치 된 경로를 명시적으로 알고 있어야 하는데 그렇지 않아 발생하는 이슈입니다.이런 경우 .NET이 설치 된 경로를 path에 등록하시면 해결하실 수 있습니다.path 설정하기 (위 과정을 모두 마쳐도 자동완성이 안 될 경우)제 경우, /usr/local/share/dotnet/dotnet 경로에 .NET이 설치가 되었습니다.혹시 확인해보고 싶으시다면 터미널을 여신 뒤 cd /usr/local/share/dotnet 명령어를 입력하였을 때 dotnet 폴더에 정상적으로 접근이 되는지 확인하시면 됩니다.Mac에서 Zsh를 사용하시고 계신다면 ~/.zshrc에, Bash를 사용하고 계신다면 ~/.bash_profile에 환경 변수를 등록하실 수 있습니다.저는 Zsh를 사용하고 있기에 Zsh 기준으로 설명 드리겠습니다. 터미널에서 vi ~/.zshrc 를 입력합니다. ~/.zshrc 문서가 열리면 방향키를 이용하여 문서의 최하단으로 이동합니다. i 키를 눌러 Insert 모드를 활성화 합니다. export PATH=&quot;$PATH:/usr/local/share/dotnet/dotnet&quot; 구문을 추가합니다. esc 키를 눌러 Insert 모드를 종료합니다. :wq 를 입력하여 변경사항을 저장 후 터미널로 돌아옵니다. source ~/.zshrc 를 입력하여 변경 된 path를 적용합니다. VSCode를 재실행합니다.위 과정을 모두 마치시면 VSCode에서 자동완성 기능이 정상 동작 하는 것을 확인하실 수 있습니다.자동 완성을 비롯한 Auto Import 기능도 정상적으로 동작 하는 것을 보실 수 있습니다.마치며제가 Unity에서 VSCode를 쓰고 싶어서 여러 블로그의 설치 가이드를 따라해보다가 실패하길 반복하면서 알게 된 사실을 문서화 하였습니다.이 기록이 여러분들의 시간을 조금이나마 아낄 수 있다면 기쁠 것 같습니다." }, { "title": "HOC와 UI 컴포넌트를 결합한 선언적인 비즈니스 컴포넌트", "url": "/posts/declarative-programming-with-hoc/", "categories": "Tech, React", "tags": "React, HOC, Business Component, Component, UI Component, UI, Refactoring", "date": "2024-05-08 09:44:00 +0800", "snippet": "UI 컴포넌트와 비즈니스 컴포넌트를 서로 적절한 수준에서 분리하여 작업하는 것은 저에게 있어 가장 큰 숙제이자 난관이었습니다.비교적 최근까지도 저는 여러가지 고민과 시도를 반복하며 보다 나은 코드와 파일 구조를 작성하는데 하루의 대부분의 시간을 보냈습니다. 동일한 UI 컴포넌트를 바라보는 수많은 Container 컴포넌트를 어떻게 관리해야 할까? UI 컴포넌트가 꼭 필요할까? (재사용성 안높아보이는건 일단 Container로 만들고 나중에 분리할까?)이와 같은 고민들을 수차례 반복하며 점점 더 복잡해져만 가는 파일 구조, 코드 복잡도와 전쟁을 벌이고 있었습니다.이 부분을 HOC를 통해 해결하여 나름 쾌적한 코드 스멜을 맡으며 작업하고 있기에 이 경험을 공유하고자 이 문서를 작성하였습니다.일단 본론으로 들어가기 전에 UI 컴포넌트와 Container 컴포넌트가 무엇인지 설명하겠습니다.UI 컴포넌트UI 컴포넌트는 순수하게 props를 전달하면 UI에 반영 되어 보여지는 컴포넌트입니다.그 어떤 비즈니스 로직과도 연결 되어 있지 않아, 페이지 여러 곳에서 사용할 수 있는 컴포넌트의 기본 목적에 가장 충실한 컴포넌트라고 볼 수 있습니다.가장 간단한 예를 들자면 위 사진과 같은 버튼을 예시로 들 수 있습니다.하지만 실제 프로젝트를 수행하면서 컴포넌트로 관리하고자 하는 UI는 위 버튼처럼 Atomic한 컴포넌트만 존재하지 않습니다.위 날짜 입력 Form처럼 굉장히 복잡한 수준의 컴포넌트도 충분히 UI 컴포넌트로 관리하고 싶을 수 있습니다.왜 복잡한 컴포넌트도 순수하게 관리해야 하나요?우리가 게시판을 만들어 본 적이 한 번이라도 있다면 충분히 경험했을 상황을 예로 들겠습니다.위 사진과 같은 게시글 작성 Form이 존재한다고 가정해봅시다.위 게시판에서 ‘글을 작성한다’는 시나리오를 수행한다고 생각해보면 프로세스는 다음과 같을 것입니다. 사용자는 게시글 작성 버튼을 눌러서 게시글 작성 페이지에 접속한다. 에디터에 게시글을 입력한다. 작성 버튼을 누른다.매우 간단한 프로세스입니다.하지만 ‘글을 수정한다.’는 시나리오를 생각해보면 어떨까요? 사용자는 게시글을 수정 버튼을 누른다. 게시글 작성 당시와 동일한 기능을 지원하는 게시글 작성 Form에서 수정을 진행한다. 수정 버튼을 눌러 수정을 완료한다.게시글 수정의 경우 기존에 사용자가 입력했던 게시글의 제목과 내용 등을 모두 불러와 Form에 초기부터 입력이 되도록 구현해야 합니다.이럴 때 작성 Form과 수정 Form이 동일한 기능을 지원하게 하면서, 상황에 따라 일부 기능의 수정이 가능하도록 구현할 필요가 있습니다.그렇기 때문에 Form과 같은 유기체 성격의 컴포넌트도 UI 컴포넌트로 분리할 필요가 있는 것입니다.Container 컴포넌트Container 컴포넌트는 다른 말로 Business 컴포넌트라고도 불립니다.말 그대로 특정 도메인 안에서만 쓰이는 로직이 포함 된 컴포넌트입니다.방금 전에 언급 했던 게시글 작성과 수정으로 예시를 들겠습니다.우리는 게시판의 유연한 사용을 위해 PostForm.tsx 라는 UI 컴포넌트를 만들었다고 생각해봅시다.PostForm.tsx 을 사용하여 게시글 수정 기능을 구현하고자 한다면 다음과 같이 구현할 수 있습니다./* * PostForm.tsx를 사용하여 게시글 수정을 진행하기 위한 Container 컴포넌트입니다. */const UpdatePostFormContainer = () =&amp;gt; { const [post, setPost] = useState&amp;lt;Post&amp;gt;(); useEffect(() =&amp;gt; { fetch(POST_SERVER_DOMAIN) .then((response) =&amp;gt; response.json()) .then((post) =&amp;gt; setPost(post)); }, []); return ( &amp;lt;PostForm { ...post } /&amp;gt; );} fetch API를 사용하여 게시글을 불러옵니다. PostForm 컴포넌트에 불러온 데이터를 Bind합니다.이처럼 ‘특정 API 서버’와 같은 다른 프로젝트에서 재사용하기 매우 어려운, 비즈니스 로직에 깊게 연관 된 로직이 포함 된 컴포넌트를 Container 컴포넌트라고 부릅니다.왜 Props를 사용하지 않고 Container 컴포넌트로 분리 하나요?결론부터 말씀 드리자면 관심사를 분리하기 위해 사용합니다.props를 사용한다는 것은 다른 말로 하자면 컴포넌트를 사용하는 레이어에서 props로 전달할 데이터를 Fetching 하는 작업이 수반 되어야 한다는 얘기입니다.대부분의 경우 컴포넌트에 넘겨줄 데이터를 Fetching 하는 주체는 페이지가 될 것입니다.UI 요소를 배치하고자 하는 경우 페이지에 배치해야 하기 때문입니다.하지만 Page의 경우 대부분 수행하고자 하는 코드의 무게가 무겁습니다.페이지에는 보통 UI를 배치하는 코드만으로도 부담이 상당히 가해집니다.여기에 데이터를 Fetching하는 코드에 대한 책임마저 페이지에게 일임한다면 페이지의 복잡도는 기하급수적으로 증가하게 될 것입니다.import React, { useState, useEffect } from &#39;react&#39;;const ComplexPage = () =&amp;gt; { const [data, setData] = useState([]); const [loading, setLoading] = useState(false); const [error, setError] = useState(null); const [query, setQuery] = useState(&#39;default&#39;); useEffect(() =&amp;gt; { setLoading(true); fetch(`https://api.example.com/data?query=${query}`) .then(response =&amp;gt; response.json()) .then(setData) .catch(setError) .finally(() =&amp;gt; setLoading(false)); }, [query]); const handleChange = event =&amp;gt; { setQuery(event.target.value); }; const handleRefresh = () =&amp;gt; { setLoading(true); fetch(`https://api.example.com/data?query=${query}`) .then(response =&amp;gt; response.json()) .then(setData) .catch(setError) .finally(() =&amp;gt; setLoading(false)); }; return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Complex Page Example&amp;lt;/h1&amp;gt; {error &amp;amp;&amp;amp; &amp;lt;p&amp;gt;Error loading data!&amp;lt;/p&amp;gt;} &amp;lt;input type=&quot;text&quot; value={query} onChange={handleChange} /&amp;gt; &amp;lt;button onClick={handleRefresh}&amp;gt;Refresh&amp;lt;/button&amp;gt; {loading ? ( &amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt; ) : ( &amp;lt;ul&amp;gt; {data.map((item, index) =&amp;gt; ( &amp;lt;li key={index}&amp;gt;{item.name}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; )} &amp;lt;/div&amp;gt; );};export default ComplexPage;// 😱😱😱😱😱그렇기에 이미 관심사가 잘 분리 되어 있는 UI 컴포넌트를 기준으로 비즈니스 로직을 추가한 Container 컴포넌트를 제작하여 관리하는 것입니다.Container 컴포넌트는 문제가 없나요?비즈니스 코드가 수정 되어야 하는 일부 상황에서 동일한 UI 컴포넌트를 참조하는 Container 컴포넌트가 많아질 수 있다는 단점이 존재합니다. 게시물을 불러오는 API 서버가 서로 다른 Endpoint를 가지는 경우 각각의 상황에서 Fetching하는 게시물의 interface가 서로 상이하여 이를 규격화 할 필요가 있는 경우위 예시처럼 비즈니스 로직이 조금씩 상이하여 재사용이 어려운 경우 새로운 컴포넌트를 다시 만들어서 비즈니스 로직을 연결해야 하는데, 이렇게 구현할 경우 아래와 같이 불필요하게 복잡하고 많은 Container 컴포넌트가 생겨날 수 있습니다.- EditPostFormContainer.tsx- FreeBoardPostFormContainer.tsx- HumorBoardPostFormContainer.tsx- AwesomePostFormContainer.tsx...비즈니스 로직을 HOC에게 위임해보자HOC는 특정 함수를 통해 새로운 컴포넌트를 반환하는 구현 방법입니다.HOC의 구현 및 사용 방법은 다음과 같습니다.// PostForm.tsxexport const PostForm = ({ title, content }: PostFormProps) =&amp;gt; { return ( &amp;lt;form&amp;gt; &amp;lt;input value={title} name=&quot;title&quot; /&amp;gt; &amp;lt;textarea name=&quot;content&quot;&amp;gt;{ content }&amp;lt;/textarea&amp;gt; &amp;lt;/form&amp;gt; );}이처럼 title과 content를 전달 받아 Form을 구현하는 UI 컴포넌트가 있습니다.이 컴포넌트에 데이터를 자동으로 할당해주는 HOC를 구현해봅시다.// withPostData.tsconst withPostData = (Component: ComponentType&amp;lt;typeof PostForm&amp;gt;) =&amp;gt; { return () =&amp;gt; { const [post, setPost] = useState(); useEffect(() =&amp;gt; { fetch(POST_SERVER_DOMAIN) .then((response) =&amp;gt; response.json()) .then((post) =&amp;gt; setPost(post)); }, []); return ( &amp;lt;Component title={post.title} content={post.content} /&amp;gt; ); };}withPostData 라는 함수는 JSX Element를 반환하는 함수를 반환하도록 구현되어 있습니다.다시 말해, React Component를 함수 내에서 자체적으로 제작하여 반환한다는 뜻입니다.그러므로 페이지에서 다음과 같이 사용할 수 있습니다.// page.tsxexport const Page = () =&amp;gt; { return ( &amp;lt;PostFormWithData /&amp;gt; );}const PostFormWithData = withPostData(PostForm);이처럼 매우 선언적인 코드로 Data Fetching, Data Bind, UI 배치와 같은 작업을 모두 수행할 수 있게 되었습니다. 🎉HOC를 활용한 데이터 바인딩의 또다른 장점만약 당신이 게시판의 형태가 매우 다양한 웹사이트를 운영하고 있다고 가정해봅시다. 자유게시판 유머게시판 QnA 게시판 등등…Container 컴포넌트를 활용하였다면 UI 컴포넌트에 대응 되는 Container 컴포넌트를 동일한 갯수 (혹은 그 이상)만큼 생성해야 합니다.- FreeBoardPostForm.tsx- HumorBoardPostForm.tsx- QnABoardPostForm.tsx- FreeBoardEditPostFormContainer.tsx- HumorBoardEditPostFormContainer.tsx- QnABoardEditPostFormContainer.tsx- ...😱😱😱하지만 당신이 HOC를 이용한 데이터 바인딩을 사용했다면 다음과 같이 간단하게 제작할 수 있습니다.// HumorBoardPostForm.tsxconst FreeboardEditPage = () =&amp;gt; { return ( &amp;lt;PostFormWithData /&amp;gt; );}const PostFormWithData = withPostData(FreeBoardPostForm);// HumorBoardPostPage.tsxconst HumorBoardEditPage = () =&amp;gt; { return ( &amp;lt;PostFormWithData /&amp;gt; );}const PostFormWithData = withPostData(HumorBoardPostForm);// QnABoardPostForm.tsxconst QnABoardEditPage = () =&amp;gt; { return ( &amp;lt;PostFormWithData /&amp;gt; );}const PostFormWithData = withPostData(QnABoardPostForm);Container 컴포넌트의 구현 없이 매우 선언적으로 페이지 내에서 바로 게시물 수정 기능을 구현하는데 성공하였습니다. 🎉물론 이런 이점을 누리려면 각각의 게시판이 동일한 로직을 거쳐서 게시물 데이터를 할당 받을 수 있도록 interface를 잘 구성해야 하겠습니다.번외) Suspense와 HOC를 활용한 선언적인 스켈레톤 코드React 18에서 추가 된 Suspense 컴포넌트는 하위에 사용 된 컴포넌트에서 Promise가 throw 되면 fallback Prop으로 전달한 UI를 노출시킵니다.const PromiseExample = () =&amp;gt; { return ( &amp;lt;Suspense fallback={&amp;lt;LoadingIndicator /&amp;gt;}&amp;gt; &amp;lt;VerySlowComponent /&amp;gt; // 여기서 Promise를 throw하고 있다면 LoadingIndicator 노출 &amp;lt;/Suspense&amp;gt; );}HOC Data Fetching 부분을 간단하게 수정하는 것만으로도 Suspense와 결합하여 스켈레톤 UI를 보여주는 선언적인 코드를 작성할 수 있습니다.// withData.tsexport const withData = () =&amp;gt; { return () =&amp;gt; { const [data, setData] = useState(null); useEffect(() =&amp;gt; { fakeFetch().then(response =&amp;gt; { setData(response.data); }); }, []); if (!data) { // 데이터가 아직 로드되지 않았을 때는 Suspense가 처리할 수 있도록 Promise를 throw합니다. throw fakeFetch(); } return &amp;lt;div&amp;gt;{data}&amp;lt;/div&amp;gt;; };}HOC를 위와 같이 작성하면 이를 사용하여 아래와 같이 구현이 가능합니다.const PromiseExample = () =&amp;gt; { return ( &amp;lt;Suspense fallback={&amp;lt;LoadingIndicator /&amp;gt;}&amp;gt; &amp;lt;VerySlowComponent /&amp;gt; &amp;lt;/Suspense&amp;gt; );}const VerySlowComponent = withData(UIComponent);후기이처럼 HOC를 사용하여 데이터를 쉽게 불러오고 할당하고 사용하는 방법에 대해 알아보았습니다.문서 초입에 말씀 드렸던 것 처럼 부끄럽게도 저는 얼마 전 까지 UI 컴포넌트, Container 컴포넌트에 대한 폴더 구조와 중복 코드 관리 방법에 대해 정말 오랜 기간 고민하였습니다.이 과정에서 정말 여러가지를 시도 해보았습니다. UI 컴포넌트를 만들지 말고 모든 컴포넌트를 Container 컴포넌트로 만들어본다던가 Data Fetching을 위한 Hook을 세밀하게 분리하여 페이지에서 최대한 코드 정의 없이 Hook만으로 Fetching 해본다던가하지만 어떤 방법을 써도 프로젝트 규모가 커지면 결국에는 스파게티가 되어버렸고, 그 스파게티를 해결하기 위해 고생만 하기도 했던 경험이 많았는데 HOC를 사용한 방법은 아직 아무런 문제 없이 쾌적한 코드 환경을 조성해주고 있습니다.‘은총알은 없다’는 말이 있듯이, 결국에는 이 역시도 사용범위가 거대해지면 분명 어떠한 문제점이 나타날 것이라 생각합니다만 그 때는 그 상황에 맞는 해결 방법이 있으리라 믿으며 글을 마칩니다." }, { "title": "우아한 나의 패키지, ww-timer 회고", "url": "/posts/my-first-npm-library/", "categories": "Tech, Talk", "tags": "npm, package, ww-timer", "date": "2024-04-28 23:03:00 +0800", "snippet": "npm에 ww-timer를 배포하다저는 한 달 쯤 전에 npm에 ww-timer라는 라이브러리를 배포했습니다.현재 개발하고 있는 서비스는 글로벌 시장을 목표로 하고 있는 생산성 앱인데, 이 앱의 기능 중 하나로 타이머가 들어갈 예정입니다.웹에서 Timer를 개발하려면 필히 setTimeout이나 setInterval을 사용해야 하는데 이러한 비동기 함수는 브라우저의 작업량에 따라 실행 순위가 후순위로 밀리고 밀려 결국에는 실제 시간과 엄청난 차이가 벌어지게 되는 문제가 발생했습니다.이러한 문제는 결국 Web Worker를 사용하여 해결하였으나 Web Worker를 사용하는 방법 자체가 파일의 파편화와 선언적이지 못한 코드를 만들었기 때문에 이 문제를 해결하고자 별도의 패키지로 제작하게 되었습니다.문제점기본적으로 브라우저는 매우 바쁩니다. 특히나 오늘날의 웹페이지는 Javascript로 작성되고 동작하는 경우가 매우 많아 브라우저는 Javascript를 처리하기 위해 앞단에서 매우 바쁜 일을 처리합니다.Javascript는 단일 스레드이기에 한번에 하나의 업무만을 처리할 수 있는데 심지어 그 업무 처리 방식도 ‘동기적으로 처리 될 수 있는 업무’를 우선하여 처리하고, 손이 남으면 비동기 업무를 수행합니다.그렇기에 setTimeout이나 setInterval과 같은 비동기 함수는 브라우저가 얼마나 바쁘냐에 따라 실행 시간의 정확도가 매우 떨어지는 결과를 야기할 수 있습니다.이는 일반적인 경우에는 별 문제가 없으나 타이머와 같이 매우 정밀한 시간 제어가 필요한 어플리케이션의 경우 치명적인 결과를 발생 시킬 수 있습니다.Web Worker를 이용한 해결 방법현실 세계에서 일이 바쁘다면 직원을 더 채용합니다.자바스크립트의 세계에서는 매우 바쁜 기본 스레드의 업무를 덜어주기 위해 Web Worker라는 것을 사용합니다.간단하게 설명하자면 DOM 처리와 같은 브라우저의 화면 처리 업무를 제외한 대부분의 업무를 수행할 수 있는 노동자를 고용한다고 볼 수 있어요.Web Worker 코드 살펴보기ww-timer는 지정한 시간마다 기본 스레드에게 메시지를 보내는 아주 단순한 코드로 구성 되어 있습니다.(() =&amp;gt; { self.addEventListener(&#39;message&#39;, (event) =&amp;gt; { if (typeof event.data !== &#39;object&#39;) { throw new Error(&#39;Invalid data&#39;); } if (typeof event.data.interval !== &#39;number&#39;) { throw new Error(&#39;Invalid interval&#39;); } self.setInterval(() =&amp;gt; { self.postMessage(&#39;called&#39;); }, event.data.interval); });})();Web Worker에서의 self는 Web Worker가 동작하고 있는 Background Thread를 의미합니다.이 곳에서는 window객체를 참조해야 사용할 수 있는 API를 제외한 대부분의 API를 사용할 수 있습니다.Web Worker는 postMessage 함수를 이용하여 Web Worker가 동작하는 기본 스레드에게 메시지를 전송할 수 있습니다.또한 onMessage 이벤트를 사용하여 기본 스레드가 Web Worker에게 보내오는 메시지 역시 수신이 가능합니다.이를 바탕으로 위 코드의 동작 원리를 해석하자면 다음과 같습니다. 기본 스레드에서 Web Worker를 생성한다. Web Worker에게 { interval: 1000 }이라는 메시지를 보낸다고 가정한다. Web Worker는 해당 메시지를 토대로 interval을 생성한다. 기본 스레드에서 보내온 interval만큼의 시간이 지날 때 마다 기본 스레드에게 called 라는 메시지를 전송한다.클라이언트 코드 살펴보기Web Worker의 실행을 돕는 코드는 다음과 같이 작성되어 있습니다.class WWTimer { lastTime = Date.now(); isActive = false; wwInstance = null; constructor(callback, interval = 1000) { if (typeof callback !== &#39;function&#39;) { throw new Error(&#39;Callback function is required.&#39;); } if (interval &amp;lt;= 1) { throw new Error(&#39;Interval must be greater than 1.&#39;); } this.lastTime = Date.now(); this.isActive = false; this.workerURI = getWorkerURI(worker); this.wwInstance = new Worker(this.workerURI); this.wwInstance.postMessage({ interval }); this.wwInstance.addEventListener(&#39;message&#39;, (event) =&amp;gt; { if (event.data === &#39;called&#39; &amp;amp;&amp;amp; this.isActive) { const elapsedTime = Date.now() - this.lastTime; this.lastTime = Date.now(); callback({ currentTime: new Date(), timeElapsed: elapsedTime }); } }); } start() { this.isActive = true; } pause() { this.isActive = false; } destroy() { this.wwInstance.terminate(); }}export default WWTimer;조금 코드가 길어지긴 했는데 원리 자체는 매우 단순합니다. new WWTimer(callback, interval)를 사용하여 인스턴스를 생성합니다. 생성자에 의해 Web Worker 인스턴스가 생성 됩니다. 사용자가 두번째 매개변수로 전달한 interval을 Web Worker가 이해할 수 있도록 객체로 만들어 전송합니다. Web Worker가 메시지를 전송할 때마다 현재 시간을 기록합니다. 첫번째 실행 이후에는 이전 호출 시간과 비교하여 정확히 얼마의 시간이 지난 다음에 interval이 실행 되었는지를 저장하는 timeElapsed 프로퍼티와 현재 시간을 담은 currentTime 프로퍼티를 생성합니다. 이 데이터를 callback의 매개변수로 전달하여 보다 유연한 처리를 가능하게 합니다.트러블 슈팅번들링 이후 Web Worker의 URL을 못찾는 이슈Web Worker를 브라우저에서 생성할 때는 다음의 API를 사용합니다.const worker = new Worker(&#39;worker 파일의 경로&#39;);매개변수로 포함 되어야 하는 Worker 파일의 경로는 반드시 브라우저가 접근할 수 있는 경로여야 합니다.하지만 npm 패키지는 번들러에 의해 번들링 되고 사용자의 컴퓨터에 다운받게 되는 순간 node_modules라는 폴더에 포함 되는 코드 조각이 되기 때문에 브라우저가 접근할 수 있는 경로 자체가 존재하지 않습니다.이 이슈는 Web Worker에서 동작할 소스코드를 Javascript 소스코드가 아닌 일반 평문으로 취급하면서 해결할 수 있었습니다.Javascript에는 자체적으로 파일을 생성하고 이 파일에 대한 경로를 생성할 수 있는 강력한 API가 존재합니다.바로 Blob이라는 API입니다.Blob API는 자바스크립트로 바이너리 파일을 생성할 수 있는 API입니다. (심지어 브라우저에서도 사용 가능한!)const blob = new Blob([&#39;File Content&#39;], { type: &#39;file mimetype&#39; });이런 식으로 사용할 수 있는데, 첫번째 매개변수에는 파일을 구성할 데이터를 문자열 형태로 기입합니다.두번째 매개변수에는 해당 파일을 취급하는 방식(?) 에 대해 기입합니다.대표적으로는 text/plain 혹은 아래 예시에 등장하는 text/javascript가 있겠네요.Web Worker 파일을 메모리에 저장하고, 메모리에 저장 된 Web Worker 파일에 접근할 수 있도록 URL을 생성해주는 함수를 아래와 같이 만들었습니다.export const getWorkerURI = (workerScript) =&amp;gt; { if (typeof workerScript !== &#39;string&#39;) { throw new Error(&#39;Worker script must be a string&#39;); } const blob = new Blob([workerScript], { type: &#39;text/javascript&#39; }); const url = URL.createObjectURL(blob); window.setTimeout(() =&amp;gt; URL.revokeObjectURL(url)); return url;}; 매개변수로 Web Worker에서 동작할 소스코드를 매개변수로 전달한다. 이를 Blob API를 이용하여 Javascript File로 만들고 메모리에 저장한다. 메모리에 저장 된 파일을 URL API를 이용하여 실제 접근 가능한 URL로 만든다. URL을 생성했으니 더이상 필요 없어진 URL 객체를 메모리에서 제거한다. (Worker API에 전달 될 시간은 필요하니까 비동기로 처리) URL을 반환한다.이로써 node_modules에 포함 되는 패키지에서도 Web Worker를 사용할 수 있게 되었습니다.배포파일 최적화 이슈생각보다 별거 없는 코드와 기능인데도 불구하고 용량이 매우 큽니다.결론부터 말씀드리자면 이는 제 어처구니 없는 실수에 인한 것으로 불필요한 파일이 같이 업로드 되었기 때문입니다.ww-timer 패키지 레포지토리에는 examples라는 폴더가 있습니다.다른 오픈소스들과 마찬가지로 이를 실제 프로젝트에서 어떻게 사용할 수 있는지를 나타낸 사용 예시 폴더입니다.이 예시 파일에는 React를 사용한 프로젝트에서 어떻게 사용할 수 있는지에 대한 예시가 존재했는데, 이 파일이 npm 패키지에 그대로 올라가버린 것입니다.존재감이 독보적인 examples 폴더이 이슈는 .npmignore 파일을 수정하면서 해결하였습니다..npmignore는 npm 저장소에 업로드 할 파일과 안 할 파일을 구분하기 위한 용도로 사용 됩니다.여담이지만 만약 레포지토리에 .npmignore가 없다면 .gitignore로 대체한다고 합니다.이 파일에examples/위와 같이 추가함으로써 용량 문제를 해결하였습니다.examples 폴더가 빠진 파일 목록 (그 외에도 몇 개 더 빠진건 비밀)회고주간 다운로드 237회!돌이켜 생각해보면 정말 보잘 것 없는 기능이고 API도 부족한 바가 많다고 생각하는 라이브러리이지만 여태까지 npm 라이브러리를 써보기만 하다가 직접 만들어보니 많은 것을 배울 수 있었다고 생각합니다.특히나 패키지를 배포한 1주일 간 제가 만든 패키지의 다운로드 건 수가 200건 이상이 찍힌 것을 목격했을 때는 기분이 정말 좋았습니다.마치 어렸을 때 플래시 게임 커뮤니티에 투고했었던 게임이 월간 베스트에 올라갔었던 기분과 비슷했달까요.비록 지금은 주간 다운로드 횟수가 10회도 못넘기고 있지만 그대로 매우 뜻깊은 경험이었다고 생각합니다." }, { "title": "Swagger를 이용한 세상 간단한 API Mocking", "url": "/posts/automatic-api/", "categories": "Tech, Talk", "tags": "Swagger, API, Mocking", "date": "2024-04-28 21:56:00 +0800", "snippet": "API Mocking프론트엔드와 백엔드의 관계에서 대부분의 경우 프론트엔드가 백엔드에 의존성을 띄고 있습니다.프로젝트를 수행함에 있어서 프론트엔드가 API를 연동하려면 백엔드의 개발이 모두 끝나야 진행할 수 있게 되기 때문입니다.API의 개발이 모두 완료 되기 전 까지 대기할 필요가 없어지도록 가짜 API 서버를 개발하여 사용하는 방식이 만들어졌는데, 이를 API Mocking이라고 합니다.기존 작업 순서백엔드에 대한 프론트엔드의 의존성을 줄이기 위한 방법은 대부분 다음과 같습니다. 백엔드는 프로젝트 투입 당시 예상 되는 API의 스펙을 결정합니다. 이 과정에서 Payload, Response Interface를 확정합니다. 이 사실을 프론트엔드에게 알립니다. 프론트엔드는 임시 API 서버를 구축하여 백엔드가 결정한 Request, Response 스펙으로 가짜 데이터가 전달 되도록 간단하게 API를 구현합니다. 프론트엔드는 가짜 API 서버에서 응답값을 받도록 화면을 구현합니다. 백엔드의 API 개발이 끝났다면 프론트엔드는 가짜 API 서버 경로를 진짜 API 서버로 치환합니다. Interface를 사전에 조율 하였으니 응답 데이터에 대한 문제가 발생하지 않고 자연스럽게 연결이 됩니다.위 방법에 대한 문제점이 과정에서의 문제는 다음과 같습니다. 백엔드의 Interface를 코드로 옮겨야 하는 불편함 임시 API라고는 하지만 API 서버를 프론트도 개발해야 한다는 비효율심지어 계획 단계에서 모든 것을 예상할 수가 없기 때문에 백엔드의 API Interface는 주기적으로 변경 될 수 있으며, 계획이 수정 되면 백엔드는 프론트엔드에게 통보해야 하고 프론트엔드는 수정 된 내용으로 초기 작성했던 Interface와 서버 코드를 수정해야 하는 번거로움이 동반됩니다.해결 방법⚠️ Swagger 문서를 작성하는 방법에 대해서는 기술하지 않습니다.Swagger를 통한 자동화API를 개발하는 과정에서 프론트엔드가 언제든지 API의 인터페이스를 이해하고 실행 해볼 수 있도록 하기 위해 Swagger 문서를 작성하게 됩니다.Swagger 문서는 json 파일로 추출할 수 있는데, 이 json 파일을 이용하여 프론트엔드에서 API를 실행해볼 수 있는 클라이언트, 가짜 응답값을 전달할 수 있는 가짜 API 서버를 만들 수 있습니다.Swagger UI에서 json 추출하기만약 Swagger UI 문서가 구축 되었고, 내부 interface가 작성 된 상태라면 UI 페이지에 접근했을 때 위 사진과 같은 json 파일에 대한 링크가 표시 됩니다.해당 링크에 접근하면 Swagger UI 문서를 이루고 있는 모든 데이터를 json 파일로 내려 받을 수 있습니다.JSON 파일로 HTTP Client 만들기HTTP Client여기서 말하는 HTTP Client는 프론트엔드에서 백엔드에 요청을 보낼 때 사용하는 fetch API를 커스터마이징한 코드를 얘기합니다.일반적인 경우 단순히 백엔드에 요청을 보내는 경우라면 fetch(&#39;api_path&#39;, { params: ... }) 와 같은 방식으로 요청을 보내게 됩니다.HTTP Client의 장점타입 추론위와 같은 방법을 사용한다면 API 서버의 Path나 Payload, Response 데이터의 구조를 IDE 내에서 직관적으로 파악하기 어렵기 때문에 typescript를 사용하고 있다면 다소 아쉬운 부분이 있습니다.하지만 Swagger를 이용하여 HTTP Client를 구축한다면 다음과 같이 사용할 수 있습니다.api.auth.authControllerLogin({ email: &#39;chanyoung@example.com&#39;, password: &#39;12345678&#39;,});만약 API 서버 내부에 /auth/login 경로의 API가 존재하고 있다면 HTTP Client는 Path의 Segment를 기준으로 Depth가 있는 객체를 생성하게 됩니다.그리고 그 객체 하위에는 실제 API를 요청할 수 있는 함수가 존재합니다.해당 함수에는 Swagger에서 명시해 둔 요청, 응답 값에 대한 interface가 정의 되어 있기 때문에 typescript를 사용하고 있다면 요청, 응답 값에 대한 타입 추론이 가능합니다.fetch API에 대한 자동 확장Swagger로 인해 생성 된 HTTP Client는 사용자가 서비스에 녹여내기에 부족함이 없는 기능을 제공합니다.생성 된 HTTPClient 구조의 일부를 보면 아래와 같습니다.export class HttpClient&amp;lt;SecurityDataType = unknown&amp;gt; { public baseUrl: string = &quot;http://localhost:3000/&quot;; private securityData: SecurityDataType | null = null; private securityWorker?: ApiConfig&amp;lt;SecurityDataType&amp;gt;[&quot;securityWorker&quot;]; private abortControllers = new Map&amp;lt;CancelToken, AbortController&amp;gt;(); private customFetch = (...fetchParams: Parameters&amp;lt;typeof fetch&amp;gt;) =&amp;gt; fetch(...fetchParams);Javascript에서 사용하는 fetch API를 사용하는데, fetch 는 사용하다보면 부족한 기능이 있습니다. BaseURL 설정 기능 제공 안함 200 ~ 299 외 응답에 대해 Exception 처리가 되지 않음이러한 기능을 구현하려면 개발자의 작업이 추가적으로 필요한데, HTTP Client는 이러한 기능에 대한 처리가 이미 되어 있어서 Mocking 뿐 아니라 실제 서버와 연동할 때 사용함에도 부족함이 없습니다.생성 방법⚠️ swagger.json 파일이 이미 있다고 간주합니다.생성 방법은 매우 간단합니다.npx swagger-typescript-api -p path/to/your/swagger.json -o path/to/output/dir --name index.ts path/to/your/swagger.json 은 swagger.json 파일이 저장 된 경로로 수정해야 합니다. path/to/output/dir은 index.ts 파일이 생성 될 디렉토리 경로 입니다. index.ts는 HTTP Client 파일입니다. 파일명을 수정하고 싶으시면 해당 옵션을 수정해야 합니다.위 코드를 실행하면 swagger-typescript-api 패키지가 swagger.json 을 읽고 지정해 둔 경로에 index.ts 파일을 생성하게 됩니다.Mock API 서버 구축 방법⚠️ swagger.json 파일이 이미 있다고 간주합니다. API 서버를 구축하기 위해 필요한 의존성 패키지를 다운 받아야 합니다. yarn add @stoplight/prism-cli package.json에 script를 추가합니다. &quot;scripts&quot;: { &quot;run:server&quot;: &quot;prism mock --host 0.0.0.0 -p 15002 -d swagger.json&quot; } host는 서버의 IP입니다. 0.0.0.0을 기입하면 일반적인 루프백 아이피와 동일하게 작동합니다. -p 15002는 포트 번호입니다. -d swagger.json은 swagger.json의 위치입니다. 만약 다른 폴더에 존재한다면 swagger.json값만 수정하여 swagger.json 파일의 경로를 정확히 지정해야 합니다. http://localhost:15002 주소로 API 서버에 대한 구축이 완료 됩니다. Mock 서버와 HTTP Client 연동하기이 방법 또한 매우 간단합니다.HTTP Client 파일 내부의 baseUrl 프로퍼티의 경로를 http://localhost:15002로 수정하시면 별도의 추가적인 설정 없이 즉각적으로 요청을 보낼 수 있습니다." }, { "title": "Focus Keeper 랜딩 페이지 런칭 후기 (부제: UX가 프로덕트 성공에 미치는 영향)", "url": "/posts/focuskeeper-renewal/", "categories": "Tech, Talk", "tags": "UX, Focus Keeper", "date": "2024-04-15 12:18:00 +0800", "snippet": "저는 얼마 전에 회사에서 운영하고 있던 Focus Keeper의 랜딩 페이지를 리뉴얼하는 작업을 진행했습니다.단순 페이지 리뉴얼이라서 별 기대를 하지 않았었는데 단순 사용성만 수정했음에도 불구하고 놀라울 정도의 지표가 측정되어 공유드리고자 이 글을 작성했습니다.Focus Keeper는 뽀모도로 기법을 차용하여 성인 ADHD 환자나 집중력이 낮은 사람들이 보다 높은 집중력을 오래 유지할 수 있도록 도와주는 서비스입니다.이 서비스는 약 2년 전 부터 웹 서비스가 개발되어 한창 운영 중에 있었습니다.그러나 이 때 당시에는 iOS에서 운영 되고 있는 앱으로 접속을 유도하는 형태의 단순한 랜딩만을 목적으로 두었기에 서비스의 여러 부분들이 다소 미흡하였고,경쟁 프로덕트 대비 복잡한 UI로 인해 사용자가 집중해야 할 영역이 다소 모호했던 부분이 있었습니다.그렇게 적당한 수준의 신규 유입과 리텐션만을 유지한 상태로 2년 정도 방치 되어왔던 프로덕트였는데, Focus Keeper 2.0 런칭을 예정하고 있어서 기존 랜딩 페이지도 전체적으로 손보게 되었습니다.달라진 점타이머위: 예전 Focus Keeper, 아래: 현재 Focus Keeper이번 랜딩 페이지 영역에서 가장 크게 달라진 부분이자, 시간이 흘러가는 시각적 효과가 재밌어서 개발하면서도 엄청 만족스럽게 작업했던 부분입니다.기존에는 원형의 타이머가 시간이 흘러감에 따라 테두리의 색상이 줄어드는 단순한 효과였는데, 물결이 차오르고 줄어드는 애니메이션으로 변경되어 멍하니 보고 있어도 재밌는 타이머가 완성되지 않았나 싶습니다. 파도 애니메이션을 구현하기 위해 사용한 라이브러리는 React Wavify입니다.파도의 파고, 진폭 등을 손쉽게 제어할 수 있어서 사용하긴 했는데 requestAnimateFrame API를 기반으로 SVG의 path를 설정하기 때문에 성능이 좋지 못하다는 점이 단점입니다.한정 된 시간 안에 랜딩 페이지의 제작을 마무리 해야 해서 최적화를 하지 못한게 다소 아쉬움이 남습니다.시간 제어뽀모도로 타이머는 기본적으로 25 / 5 / 30 분의 시간이 기본 값이지만 사용자의 습관이나 취향에 따라 시간 조절을 할 필요도 분명히 존재합니다.기존에는 시간을 조정하는 기능이 ‘Timer Option’ 내부에 배치되어 있어서 시간 조작이 다소 불편함이 있었는데, 타이머의 바로 아래에 배치함으로써 보다 직관적으로 시간 조정을 할 수 있게 되었습니다.랜딩 애니메이션 개발한 Focus Keeper 페이지는 곧 런칭할 2.0 버전을 위해 신규 유저의 유입 및 리텐션을 증진 시키기 위함에 목적을 두고 있습니다.이로 인해 리뉴얼 이전 화면보다는 더욱 시인성 있고 재미 있는 랜딩 페이지를 만들어 사용자로 하여금 이목을 집중 시켜야 합니다.디자이너분과 긴밀한 협의 끝에, 스크롤 애니메이션을 통해 페이지를 보다 동적으로 제작하여 Focus Keeper를 사용하는 유저들에게 Benefits을 효과적으로 전달하고자 했습니다.해당 애니메이션을 구현하기 위해 Framer Motion 이라는 라이브러리를 사용했습니다.Framer Motion에는 애니메이션의 구현을 도와줄 컴포넌트와 유틸함수가 존재하는데, 스크롤 애니메이션을 구현하기 위해 useInView 라는 React Hook을 사용하였습니다.Motion Framer를 사용한 이유Motion Framer를 사용한 이유는 크게 세가지입니다.첫번째로는 시간이 너무 부족해서 디자이너와 프론트엔드가 동시에 작업을 시작했어야 했고, 그렇다보니 애니메이션을 어떻게 구현할지 정확하게 정해지지 않아 애니메이션 효과를 직접 제작해보면서 적절한 작업 효율과 임팩트를 협의할 필요가 있었습니다.이 과정에서 Framer Motion은 복잡한 수준의 애니메이션을 직접 제작할 수 있는 여러 편의기능을 지원하기 때문에 매우 용이하게 작업할 수 있었습니다.두번째로는 웹 접근성입니다.우리는 대부분의 경우 웹사이트에서 발생하는 역동적인 애니메이션 효과를 봤을 때 별다른 불편함을 느끼지 않습니다.하지만 일부 유저의 경우 아주 자그마한 애니메이션에도 멀미를 심하게 느끼기도 합니다.이런 유저들은 대부분 브라우저나 모바일 기기 설정에서 애니메이션 여부를 비활성화 하고 서비스를 이용하는데, 애니메이션을 자체적으로 제작한다면 이러한 기기 설정에 대한 예외 처리도 직접 해야합니다.하지만 Framer Motion은 Accessibility 에 대한 설정값을 쉽게 제어할 수 있는 유틸함수를 제공합니다.마지막으로는 선언적인 코드를 작성하기 위함입니다.keyframes를 활용하여 CSS Animation 코드를 직접 작성하고 실행한다면 애니메이션의 구현부, 실행부가 서로 따로 놀게되어 추후 유지보수 작업을 진행할 때 코드를 읽기 매우 힘들어질 우려가 있습니다.Framer Motion 라이브러리는 motion.div와 같은 애니메이션 컴포넌트를 지원하고, Variants를 통해 해당 Element에 적용 되는 애니메이션을 직접 제어할 수 있어서 선언적인 코드를 작성할 수 있습니다.모바일 최적화모바일 최적화모바일 최적화는 원래 매우 촉박했던 개발 기간으로 인해 대응하지 않으려고 했으나, 기존 Focus Keeper를 모바일에서 사용하시던 유저분들의 비중이 약 40% 정도였기에 그 수치가 적지 않아 추가적인 작업을 진행하게 되었습니다.기존 랜딩 페이지는 거대한 타이머를 Viewport 크기에 맞추어 적절한 크기로 변경한 수준이라 모바일에서 사용하면 버튼 터치나 시간 제어 측면에서 사용성이 그다지 좋지 못했습니다.이러한 문제점을 모바일에 적합한 레이아웃을 새로 디자인하여 Device의 크기에 맞게 반응형으로 제작하였습니다.반응형은 총 4Steps의 Break Points를 지정하고 개발하였습니다. 데스크탑: ~ 1366px 랩탑: 1365px ~ 960px 타블렛: 959px ~ 600px 모바일: 599px ~ 0px이렇게 반응형의 규격을 명확하게 작성하게 되면 매우 어중간한 해상도의 경우에도 렌더링 결과를 예측할 수 있게 되고, Grid 레이아웃과 결합되면 별다른 추가 작업 없이도 반응형을 구현할 수가 있기 때문입니다.회고프로젝트를 진행하며 느낀 점처음에는 많이 부족하지 않나 싶은 제작 기간이었으나 여러 타협과 고민을 통해 기간 내 제작이 이루어질 수 있었습니다.특히 이전 까지는 ‘언제까지 무엇을 개발해라.’ 라는 과제가 주어지면 이를 있는 그대로 개발 하였기 때문에 만드는 과정도 힘들고 결과물도 좋게 나오지 않아 만족감이 덜한 경우가 종종 있었습니다.하지만 이번 스프린트를 통해 이러한 기획이 탄생하게 된 배경을 근본적으로 이해하고, 기한 내에 할 수 있는 다른 옵션을 역제안 하는 방법을 터득하여 모두가 납득할 수 있는 결과물이 나오지 않았나 싶습니다.매우 성공적인 성과랜딩 페이지를 런칭하고 정확히 4일 뒤에 측정 된 성과 지표는 매우 성공적이었습니다. 신규회원 가입율: 6.5% -&amp;gt; 12% (85% 상승) 신규유저의 ‘포커스 시작’ 비율 지난 1년 기준 최고치 달성: 54% ‘포커스 시작’ 이후 ‘포커스 완료’ 비율: 28% -&amp;gt; 63% (125% 상승)이 지표를 거머쥐었을 때 기쁨도 기쁨이지만 그것보다 더욱 크게 다가온 것은 놀라움이었습니다.사실 이번 랜딩 페이지 리뉴얼 작업은 UI/UX를 중심으로 변경이 되었을 뿐이지 별도의 마케팅이나 검색 엔진 최적화를 진행한 것은 아니기 때문에 유저들의 유입 경로는 평소와 동일했을 것입니다.그러나 신규 가입율, 사용율, 첫번째 업적 달성율이 모두 증가했다는 것은 단순히 UX 변경에 유저들이 호응하고 프로덕트를 이용할 동기를 얻었다는 뜻이 됩니다.이러한 성과 지표를 보면서 재밌고 직관적인 UX는 사용자로 하여금 매우 빠른 반응을 얻어낼 수도 있다는 것을 깨닫게 되었습니다." }, { "title": "가장 아름다운 배포 자동화, 근데 이제 Slack을 곁들인", "url": "/posts/workflow-slack-notification/", "categories": "Tech, Talk", "tags": "Github", "date": "2023-10-23 00:50:00 +0800", "snippet": " 만약 배포 자동화 방법에 대해서 알고 싶으시다면 제가 이전에 작성한 글을 먼저 읽고 오시는 것을 추천 드립니다.들어가며안녕하세요 😁 박찬영입니다.지난 글에서는 Vercel을 활용한 자동 배포 환경을 만드는 방법에 대해서 말씀 드렸던 바 있어요.이번 문서에서는 지난 번에 분량 조절 문제로 인해 담지 못했던 자동 알림 기능을 추가하는 방법에 대해서 말씀 드리고자 해요.자동 알림은 왜 필요할까요?프로젝트의 배포는 대부분 다음과 같은 요청에 의해 이루어져요. 이번 버전에 추가 된 내용을 최종 사용자에게 릴리즈 해주세요~ 이번 QA에서 발견 된 이슈 수정 하셨으면 배포 해주세요~ 이번 버전 개발 다 되셨으면 QA 해야 하는데 배포 부탁드립니다.그렇다면 개발자는 배포를 진행하고나서 유관자에게 다음과 같은 내용을 포함하여 보고 해야 합니다. 이전 버전과의 차이점 배포를 진행한 버전매우 귀찮은 배포 보고보통 이렇게 수동으로 작성한 보고는 보고를 올릴 때의 기분에 따라 텍스트가 달라지기에 검색도 용이하지 않고 배포가 정상적으로 수행 되었는지 매번 확인 하고 전파해야 하기 때문에 수고로움이 매우 큰 작업입니다.(도대체 ‘3분 뒤’라는 시간은 어떻게 산정한 거야…? 😧)이 끔찍한 상황에서 Slack API를 활용하면 다음과 같은 예쁜 메시지를 자동으로 유관자에게 전파 할 수 있습니다.자동화에 성공한 Slack NotificationSlack Notification 만들어보기Slack 봇 만들기어떠한 상황에 특정 채널에 메시지를 보내기 위해서는 메시지를 보낼 수 있는 주체가 필요합니다.Slack에서는 이 역할을 Bot이라는 존재가 수행합니다.Bot 생성은 무료이며 이 Bot으로 다양한 Task를 수행할 수 있습니다. https://api.slack.com/apps 페이지로 접속합니다. 로그인 합니다. (메시지를 보내고 싶은 채널에 메시지를 보낼 수 있는 권한이 있는 계정으로 로그인 하셔야 합니다.) 로그인을 했다면 보유한 Bot의 목록이 표시 됩니다. [Create New App]을 누릅니다. [App Name] 필드에는 Bot의 이름을 작성합니다. 메시지를 보낼 때 일반 채팅처럼 Speaker의 이름이 보이게 되는데 App Name이 그 역할을 수행합니다. [Pick a workspace to develop your app in] 필드는 Bot이 소속 될 Organization을 선택하여 입력합니다. [Create App] 버튼을 누르면 App이 생성 되고 상세한 설정을 진행할 수 있는 페이지로 이동합니다. 스크롤을 조금만 더 내리면 Bot의 프로필을 설정할 수 있습니다. Bot의 이름 Bot의 프로필 사진 Bot의 소개말 등 다양한 내용들을 기입할 수 있습니다. Slack 메시지 템플릿 제작하기Slack은 일반적인 텍스트부터 버튼과 같은 액션이 포함 된 특수한 대화까지 모두 입력할 수 있습니다.이러한 기능은 당연히 Bot도 이용할 수 있습니다.다만 Slack이 자체적으로 개발한 Format을 사용하기 때문에 Documentation을 읽어보면서 하나 하나 제작하기에는 다소 시간이 많이 소모 됩니다.그래서 Slack은 자신들의 Format을 보다 쉽게 작성할 수 있도록 Slack Block Kit을 지원합니다.Slack Block Kit좌측 메뉴에서 내가 추가하고 싶은 양식을 클릭하면 Slack JSON Format을 자동으로 완성 시켜주기에 내가 원하는 Format을 쉽게 제작할 수 있습니다.일반적인 배포 Notification에 사용되는 위와 같은 형태는 다음과 같이 표현합니다.{ &quot;blocks&quot;: [ { &quot;type&quot;: &quot;header&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;text&quot;: &quot;배포를 진행합니다.&quot;, &quot;emoji&quot;: true } }, { &quot;type&quot;: &quot;divider&quot; }, { &quot;type&quot;: &quot;section&quot;, &quot;fields&quot;: [ { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*버전*\\n`0.0.1`&quot; }, { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*배포 담당자*\\nMe&quot; } ] } ]}Incoming Webhook 발급하기Slack은 각각의 채널마다 메시지를 송신할 수 있는 Incoming Webhook을 지원합니다. 좌측 메뉴에서 [Incoming Webhooks] 메뉴를 선택합니다. Incoming Webhooks 메뉴를 활성화 합니다. [Add New Webhook to Workspace] 버튼을 클릭해서 특정 채널의 Webhook을 발급 받습니다. 터미널을 열어서 [Sample curl request to post to a channel] 에 적힌 curl을 입력하면 해당 채널에 “Hello, World!” 라는 메시지가 입력 됩니다. 생성 된 Webhook URL을 CI/CD Slack Notification 연동에 활용할 수 있습니다.Webhook URL을 Repository에 등록하기Webhook URL은 별다른 인증 과정 없이 특정 채널에 메시지를 보낼 수 있는 중요한 URL입니다.이는 다시 말해 유출 될 경우 Bot을 이용해 허가 되지 않은 사용자가 특정 채널에 메시지를 무단으로 보낼 수 있다는 뜻입니다.Github CI/CD 스크립트에 평문으로 Webhook URL을 입력한다면 심각한 보안상 이슈를 낳을 수 있기 때문에 반드시 Github에서 지원하는 Secret Variables를 사용해야 합니다. CI/CD 스크립트를 적용할 Repository에 접속합니다. 상단 [Settings] 탭을 클릭합니다. 좌측 메뉴에서 [Secret and Variables] 탭을 클릭하면 나오는 [Actions] 메뉴를 클릭합니다. [New repository secret] 버튼을 클릭합니다. [Name]은 SLACK_WEBHOOK_URL로 설정합니다. [Add Secret] 버튼을 눌러서 Secret Variable을 등록합니다.Github Action을 이용하여 Slack Notification 만들기 프로젝트 폴더에 진입합니다. 최상단 경로에 .github/workflows 폴더를 생성합니다. send-slack-notification.yaml 파일을 생성합니다. 해당 파일명은 편의상 지정한 이름이며, 상황마다 다르게 지정할 수 있습니다. 아래와 같은 스크립트를 입력합니다. name: Send slack message on: push: branches: - &quot;develop&quot; env: GITHUB_REPOSITORY: ${{ github.server_url }}/${{ github.repository }} ACTION_URI: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }} jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 # 배포를 시작 하기 전에 Slack에 메시지를 보냅니다. - name: Send ready deploy message uses: slackapi/slack-github-action@v1.24.0 if: always() env: SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK with: payload: | { &quot;text&quot;: &quot;배포가 시작 됩니다!&quot;, &quot;blocks&quot;: [ { &quot;type&quot;: &quot;header&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;text&quot;: &quot;서버에 배포를 진행하고 있습니다! :runner:&quot;, &quot;emoji&quot;: true } }, { &quot;type&quot;: &quot;section&quot;, &quot;fields&quot;: [ { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*작업자*\\n${{ github.actor }}&quot; }, { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*현재 버전*\\n`${{ github.ref_type }}/${{ github.ref_name }}`&quot; } ] }, { &quot;type&quot;: &quot;divider&quot; }, { &quot;type&quot;: &quot;actions&quot;, &quot;elements&quot;: [ { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;Github 바로 가기&quot; }, &quot;url&quot;: &quot;${{ env.GITHUB_REPOSITORY }}&quot; }, { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;패치노트 바로 가기&quot; }, &quot;url&quot;: &quot;${{ env.GITHUB_REPOSITORY }}/releases/tag/${{ github.ref_name }}&quot; }, { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;웹사이트 이동하기&quot; }, &quot;style&quot;: &quot;primary&quot;, &quot;url&quot;: &quot;${{ inputs.WEBSITE_URI }}&quot; } ] } ] } # Build 스크립트를 이 곳에 작성해주세요. # 배포 완료에 대한 Slack 메시지를 전송합니다. - name: Send complete deploy message uses: slackapi/slack-github-action@v1.24.0 if: success() env: SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK with: payload: | { &quot;text&quot;: &quot;배포가 완료 되었습니다!&quot;, &quot;blocks&quot;: [ { &quot;type&quot;: &quot;header&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;text&quot;: &quot;서버에 배포가 완료 되었습니다! :party_congrats:&quot;, &quot;emoji&quot;: true } }, { &quot;type&quot;: &quot;section&quot;, &quot;fields&quot;: [ { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*작업자*\\n${{ github.actor }}&quot; }, { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*현재 버전*\\n`${{ github.ref_type }}/${{ github.ref_name }}`&quot; } ] }, { &quot;type&quot;: &quot;divider&quot; }, { &quot;type&quot;: &quot;actions&quot;, &quot;elements&quot;: [ { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;Github 바로 가기&quot; }, &quot;url&quot;: &quot;${{ env.GITHUB_REPOSITORY }}&quot; }, { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;패치노트 바로 가기&quot; }, &quot;url&quot;: &quot;${{ env.GITHUB_REPOSITORY }}/releases/tag/${{ github.ref_name }}&quot; }, { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;웹사이트 이동하기&quot; }, &quot;style&quot;: &quot;primary&quot;, &quot;url&quot;: &quot;${{ inputs.WEBSITE_URI }}&quot; } ] } ] } # 배포 실패시 메시지를 전송합니다. - name: Failed deploy uses: slackapi/slack-github-action@v1.24.0 if: failure() with: payload: | { &quot;blocks&quot;: [ { &quot;type&quot;: &quot;header&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;text&quot;: &quot;배포가 실패했어요 :scream:&quot;, &quot;emoji&quot;: true } }, { &quot;type&quot;: &quot;section&quot;, &quot;fields&quot;: [ { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*작업자*\\n${{ github.actor }}&quot; }, { &quot;type&quot;: &quot;mrkdwn&quot;, &quot;text&quot;: &quot;*현재 버전*\\n`${{ github.ref_type }}/${{ github.ref_name }}`&quot; } ] }, { &quot;type&quot;: &quot;divider&quot; }, { &quot;type&quot;: &quot;actions&quot;, &quot;elements&quot;: [ { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;Github 바로 가기&quot; }, &quot;url&quot;: &quot;${{ env.GITHUB_REPOSITORY }}&quot; }, { &quot;type&quot;: &quot;button&quot;, &quot;text&quot;: { &quot;type&quot;: &quot;plain_text&quot;, &quot;emoji&quot;: true, &quot;text&quot;: &quot;Log 확인하기&quot; }, &quot;style&quot;: &quot;danger&quot;, &quot;url&quot;: &quot;${{ env.ACTION_URI }}&quot; } ] } ] } 위 스크립트대로 작성하면 다음과 같은 레이아웃의 메시지가 작성 됩니다 🎉 자동화 된 Slack Notification 스크립트 분석해보기Action CheckoutSlack Notification을 Github Workflow에서 사용할 수 있도록 해주는 Checkout Action에는 여러가지가 있지만 그 중에서 Slack API 팀이 만든 slackapi/slack-github-action@v1.24.0 를 사용하였습니다.slack-github-action Github 바로 가기 🔗if문Github Action에서 지원하는 if문은 해당 Step의 진행 여부를 결정합니다.조건문이 false를 반환한다면 해당 Step이 Skip됩니다.if: success()if: failure()if: always()if: ${{ env.EXAMPLE == &#39;This is false&#39; }} # falseGithub에서는 success failure always와 같은 함수를 제공하는데, 이는 이전 step의 결과에 따라 각기 다른 결과값을 반환하여 특정 step의 에러 여부를 통해 다음 step의 진행 여부를 결정할 수 있습니다. success : 이전 Step의 결과가 성공했을 때 failure : 이전 Step의 결과가 실패했을 때 always : 이전 Step의 결과에 상관 없이 항상env 정의env: SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOKslackapi/slack-github-action@v.1.24.0 패키지에서 사용할 env 데이터를 정의합니다.Contextgithub.actor github.ref_type 과 같은 Context를 통해 보다 다양한 형태의 메시지를 전송할 수 있습니다.자세한 내용은 여기를 참조 해주세요 🙌마치며문서로 뽑으니 두 편밖에 나오지 않았지만 분량 자체로 보자면 매우 긴 여정을 드디어 끝내게 되었군요 😅배포 자동화 업무를 진행하면서 느낀 점이 있다면 여태까지의 저는 프론트엔드 개발에만 집중했지 내가 개발한 서비스가 사용자에게 어떻게 Delivery 되는 지, 전체적인 과정에 대해서는 무심했었던 것 아닌가 라는 생각이 들었어요.여러 사람과 기술적인 얘기를 나누다보면 여러 솔루션을 사용해보고 무엇이 좋네 저게 좋네 하는 식으로 티키타카가 이루어지는데 저는 그런 대화에 끼기에는 소양이 부족했거든요.이번 배포 자동화 문제를 제가 해결하겠다고 자발적으로 나선 것도 직접적인 서비스 개발에서 잠시 벗어나 서비스의 배포 프로세스를 배우고 익히고 싶다는 목적이 있었거든요.실제로 같이 개발하는 팀원 모두가 유용하게 사용하는 모습을 보니 좋은 서비스를 개발 했을 때와는 다른 즐거움도 있더라구요. 🙂이런 즐거움을 조금만 더 일찍 알았었다면 좋았을텐데 하는 아쉬움도 있습니다만 이제야 제가 무엇을 모르는지 감을 잡은 것 같아서 매우 즐겁게 진행했던 Task였습니다." }, { "title": "Next.js + Vercel + Github Workflow를 결합한 가장 아름다운 배포 자동화", "url": "/posts/vercel-cicd/", "categories": "Tech, Talk", "tags": "Vercel, Next.js, CICD", "date": "2023-09-29 22:21:00 +0800", "snippet": "안녕하세요 😁 박찬영입니다.오늘은 Next.js와 Vercel을 활용한 배포 자동화 방법에 대해서 얘기 하고자 해요.이번에 제가 회사에서 진행하고 있었던 프로젝트가 AWS에서 Vercel로 인프라를 이전하게 되었어요.그러한 이유로 AWS의 CI/CD를 사용할 수가 없기 때문에 Vercel에 맞는 자동 배포를 구성할 할 필요가 있어 이번 Task를 진행하게 되었습니다.CI/CD란?현업에서 활약하고 계신 분들은 당연하고 개발자를 지망하시는 분들도 CI/CD에 대해서는 한번 쯤 들어보신 적이 있으실거예요.CI/CD는 Continuous Integration와 Continuous Delivery의 약자를 결합한 단어입니다.간단하게 말해서 “지속적으로 통합하고 지속적으로 배포해라”입니다.CICI는 이처럼 개발자가 개발한 프로젝트를 빌드하고 테스트를 진행하는 일련의 프로세스를 말해요.여러 개발자들이 하나의 프로젝트에서 동시적인 개발을 진행하게 되면 분명히 높은 확률로 충돌 등이 일어나게 되는데 잘 짜여진 CI는 이러한 상황을 미연에 방지해줘요.CDCD는 지속적으로 고객에게 프로젝트를 전달하기 위한 프로세스를 말해요.여기서 말하는 고객은 최종 사용자가 될 수도 있고, 조직 내부의 QA팀이 될 수도 있어요.배포는 하루에도 수 없이 발생할 수 있는 중요한 과정이며, 또한 매우 귀찮고 시간을 많이 잡아먹는 작업이에요.이 작업을 자동화 하는 것이 CD의 핵심이라고 할 수 있어요.왜 배포를 자동화 해야 할까요?개발자가 Staging 혹은 Production 서버에 결과물을 배포하는 과정에는 다음과 같아요. Local Server에서 개발을 열심히 진행합니다. Build 커맨드를 입력하여 실제로 오류 없이 Build가 동작 하는지 시험 해봅니다. Test 커맨드를 입력하여 테스트를 진행합니다. 위 과정에서 문제가 없었다면 웹(혹은 서버) 호스팅 서비스에 Terminal을 사용하여 접속합니다. git pull 명령어를 이용하여 원격 서버의 프로젝트 파일을 최신화 합니다. Build 커맨드를 입력하여 실제로 사용할 파일을 만듭니다. Build 된 파일을 실행합니다. 유관자에게 새로운 버전이 배포 되었다는 사실을 알립니다. 만약 배포 이후에 버그가 발견 되었다면 1번으로 돌아가서 이 과정을 다시 수행해야 합니다.이 과정은 글로 나열만 해도 벌써부터 피곤함이 느껴집니다 🤮 실제로는 이보다 더 악랄하겠죠.규모가 큰 프로젝트에서의 Build 시간만 따져봐도 10분이 넘는 경우도 있거든요.이 과정을 자동화 한다면 개발자는 Git에 새로운 커밋 하나를 올리거나, 배포 버튼을 누르는 간단한 작업 하나만으로 이 모든 작업에서 자유로워질 수 있어요.배포 자동화의 중요성을 이제 잘 아시겠죠?Vercel우선 배포 자동화를 진행하기 전에 이번에 사용한 Vercel에 대해서 짧게 핥아보고 갈 필요가 있어요.Vercel은 Next.js 혹은 React를 이용하여 만들어진 프로젝트를 배포하는데 최적화 된 솔루션입니다.Vercel의 특징이자 가장 큰 장점은 다음과 같습니다. Zero Config을 지향하기 때문에 AWS같은 솔루션과는 비교가 안될 정도로 초기 설정이 단순합니다. Next.js의 개발사이다 보니 React와 Next.js에 관한 배포와 최적화는 타 플랫폼과 비교가 불가능합니다. 폰트 최적화 이미지 최적화 및 캐싱 Edge Function 등 Vercel의 운영 환경 이해하기Vercel은 세 가지의 배포 환경이 존재합니다.Developmentvercel dev를 로컬 환경에서 실행했을 때 Development 환경으로 구동 됩니다. Vercel이 지원하는 dev 명령어는 Vercel의 환경을 다운로드 받아 개발모드로 실행하도록 해주는 명령어입니다. Vercel에 등록 된 모든 설정값과 개발 모드에서 불러올 수 있는 환경 변수를 적용한 상태로 로컬 환경에서 체험할 수 있습니다.Preview 일반적인 staging의 역할을 하는 환경입니다. master 혹은 main 이라는 이름을 가진 브랜치 외 나머지 브랜치에 히스토리가 추가 되면 자동으로 배포 됩니다. vercel deploy --prebuilt 명령어로 직접 배포할 수도 있습니다. Preview는 배포가 이루어질 때마다 새로운 형태의 도메인이 새로 발급 됩니다. 이전 버전의 Preview 도메인이 스냅샷처럼 남아있기에 과거 버전과 현재 버전을 따로 접속해서 열람하는 것도 가능합니다.Production 실제 사용자에게 전달 될 서비스입니다. master 혹은 main 이라는 이름을 가진 브랜치에 새로운 히스토리가 추가 되면 배포 됩니다. vercel deploy 명령어로 직접 배포할 수도 있습니다.프로젝트 추가Vercel CLI를 이용한 프로젝트 추가 npm을 이용하여 Vercel CLI를 설치합니다. npm i -g vercel Vercel 로그인을 진행합니다. vercel login Vercel로 호스팅 하고자 하는 프로젝트의 Root에서 아래의 명령어를 입력합니다. ⚠️ 현재 프로젝트의 구조가 Monorepo라도 package 폴더 내부가 아닌 Monorepo 레포지토리 최상위 폴더에서 사용해야 합니다. vercel link 위 명령어를 사용하면 Vercel 프로젝트와 Git Repository를 연결하는 작업을 시작합니다. 현재 디렉토리에 Vercel 설정을 진행하는지 묻습니다. Y를 입력해주세요. # 현재 디렉토리에 Vercel 설정을 진행합니까? ? Set up “~/repository-path”? [Y/n]: Y 해당 프로젝트의 scope를 설정 해주세요. # 해당 프로젝트의 scope를 설정 해주세요. ? Which scope should contain your project? [ ] organization1 [ ] organization2 [ ] organization3 Vercel과 연결 된 계정에 포함 된 모든 조직이 나옵니다. 이 프로젝트를 소유할 조직을 선택하시면 됩니다. Vercel 프로젝트의 생성 혹은 연결 여부를 결정합니다. # Vercel에 이미 프로젝트가 생성 되어 있고, 해당 프로젝트의 설정값을 그대로 # 연결하길 원하면 Y를 입력합니다. ? Link to existing project? [y/N]: 만약 Vercel에 이미 존재하는 프로젝트와 연결하는 경우 Y를 입력해주세요. 프로젝트 설정을 마저 진행하시려면 N을 입력해주세요. Vercel 프로젝트의 이름을 입력해주세요. # 이 프로젝트와 연결 될 Vercel 프로젝트의 이름을 입력합니다. (입력한 이름대로 생성 됩니다.) ? What&#39;s your project&#39;s name? 배포가 이루어질 프로젝트의 경로를 입력합니다. # Vercel을 통해 배포를 진행할 패키지의 Root 디렉토리를 입력합니다. # 모놀리식 프로젝트라면 기본값인 ./를 사용하면 됩니다. # 모노레포 프로젝트라면 packages/web과 같은 배포할 패키지의 상대 경로를 입력해야 합니다. ? In which directory is your code located? ./ 일반적인 단일레포(모놀리식)의 경우 기본값인 ./대로 설정하셔도 무방합니다. 만약 모노레포라면 실제 Vercel을 이용하여 배포를 진행할 프로젝트가 저장된 곳의 상대 경로를 입력합니다. 만약 packages/web에 있는 패키지만 Vercel을 이용하여 호스팅 하려면 packages/web을 입력합니다. f. 배포 명령어를 설정합니다. # 위에서 입력한 여러 설정값을 바탕으로 Vercel의 배포 프로세스에서 사용할 명령어를 설정합니다. # Build Command는 일반적으로 사용하고 있는 프로젝트 빌드를 위한 커맨드 입니다. # Development Command는 개발모드 설정을 위한 커맨드 입니다. # Output Directory는 빌드 이후에 배포 될 파일들이 추가 되는 폴더입니다. No framework detected. Default Project Settings: - Build Command: `npm run vercel-build` or `npm run build` - Development Command: None - Install Command: `yarn install`, `pnpm install`, `npm install`, or `bun install` - Output Directory: `public` if it exists, or `.` ? Want to modify these settings? [y/N] Build Command는 프로젝트를 빌드할 때 사용하는 명령어입니다. Development Command는 개발모드 실행을 위해 사용하는 명령어입니다. Install Command는 패키지를 설치할 때 사용하는 명령어입니다. Output Directory는 빌드 이후 번들링 된 파일들이 저장 될 경로입니다. Next.js 환경을 위한 배포 명령어 설정개발 된 프로젝트가 Next.js로 만들어져 있다면 위 설정 과정 중 ‘배포 명령어 설정 과정’에서 일부 값을 변경해야 합니다.Build Command특별한 일이 없다면 Next.js의 기본 빌드 명령어와 동일하므로 변경하지 않습니다.Development Command사용할 일이 없다면 변경하지 않습니다.Install Command패키지를 설치하기 위한 명령어로서 특별한 일이 없다면 변경하지 않습니다.Output Directory기본값은 public이며 만약 public 폴더가 없다면 현재 프로젝트를 가리킵니다. 만약 배포하고자 하는 프로젝트가 정적 빌드를 이용한 정적 페이지 호스팅이라면 기본값으로 둬도 괜찮습니다. 서버사이드 렌더링 프로젝트라면 이 경로를 .next로 변경해야 합니다.Vercel 프로젝트 설정CI/CD 설정을 위해 Vercel 관리 도구에서 설정해야 하는 몇가지 옵션이 존재합니다.개설한 프로젝트 진입하기Vercel 프로젝트 목록 화면Vercel에 접속 후 로그인을 진행하면 위와 같이 새로 추가한 프로젝트가 존재합니다.해당 프로젝트를 눌러 상세 페이지에 진입하면 다음과 같은 화면이 보여집니다.Vercel 프로젝트 상세 화면자동배포 차단하기자동 배포를 차단해야 하는 이유Vercel은 Git Repository와 연결 된 순간부터 Git의 커밋 내역을 바탕으로 자동 배포를 진행합니다.자동 배포는 정말 간편하지만 일부 상황에서는 방해 요소로 작용합니다. 빌드 완료 후 Slack 혹은 Discord Notification 전송 원하는 시점에 배포하도록 설정하고자 하는 경우 그 외 디테일한 추가 설정이 필요한 경우방법 프로젝트 상단 [Settings] 탭을 클릭합니다. Settings 페이지 좌측 네비게이션에서 [Git] 메뉴를 클릭합니다. 제일 아래로 내려보면 등장하는 [Ignored Build Step]을 확인합니다. 기본값이 [Automatic]으로 되어 있는데 이를 [Don’t build anything]으로 변경합니다. [Save] 버튼을 누릅니다. 이제 어떤 브랜치에 새로운 히스토리가 푸쉬 되어도 배포가 진행 되지 않습니다. 🎉Staging 도메인 개설하기 프로젝트 상단 [Project] 탭을 클릭합니다. 프로젝트 제목 옆에 보이는 [Domains] 버튼을 클릭합니다. Staging 서버로 연결 될 도메인을 입력하고 [Add] 버튼을 클릭합니다. ⚠️ 단, 여기서 사용할 수 있는 도메인은 Vercel 프로젝트와 연결 된 도메인이어야 합니다. 만약 내 소유의 도메인을 등록하고자 한다면 [도메인 인증과정](https://vercel.com/guides/why-is-my-vercel-domain-unverified)을 따르셔야 합니다. 그게 아니라면 기본 도메인의 원형을 따르는 도메인만 설정이 가능합니다. 원형: example.vercel.app 가능한 도메인: staging-example.vercel.app 개설한 도메인의 상세 설정에서 Git Branch를 master나 main이 아닌 아무 브랜치로 설정합니다. ✅ Vercel의 기본 설정은 Git Repository의 히스토리와 브랜치 이름을 가지고 Production 여부를 판단하기 때문입니다. 환경변수 설정하기프로젝트 내부에서 여러가지 이유로 .env 파일 안에 어떠한 값을 정의하여 사용하는 경우가 있습니다.번들러가 번들링을 할 때 해당 env 변수를 읽어야 하므로 Vercel 프로젝트에 환경 변수를 정의하는 작업이 필요합니다. 상단 [Settings] 탭을 클릭합니다. 좌측 [Environment Variables] 메뉴를 클릭합니다. 아래 사진의 영역에서 환경 변수를 설정하실 수 있습니다. 환경 변수마다 어떤 빌드 상태일 때 불러올지 설정할 수 있습니다. production preview development 환경 변수를 필드에 일일이 입력해도 되지만 기존에 작성 되어 있던 .env 파일을 해당 영역에 드래그 드롭하면 자동으로 입력 됩니다. Github Workflow를 이용한 CI/CDVercel은 Git Repository 연결만으로 간편한 자동 배포를 지원하지만 Github Action을 이용하여 CI/CD를 작성하면 다음과 같은 이점이 있습니다. Slack, Discord와 같은 메신저에 Notification을 연결할 수 있습니다. 특정 버전을 선택하여 배포를 진행하는 등 커밋 히스토리에 기반한 배포 이외의 방법을 사용할 수 있습니다. 그 외 복잡한 사전/사후 프로세스를 진행할 수 있습니다. (유닛 테스트, e2e 테스트 등)Vercel 환경 변수 알아내기아래 배포 프로세스를 진행하기 위해서는 Vercel에서 얻을 수 있는 네 가지의 환경 변수가 필요합니다.Organization ID 개발 프로젝트와 Vercel 프로젝트를 서로 연결하는 과정을 진행했다면 해당 프로젝트 폴더의 root에 .vercel 폴더가 생깁니다. .vercel/project.json 파일을 열어보면 orgId 프로퍼티가 존재하는데, 이 값이 Organization ID입니다.Project ID 개발 프로젝트와 Vercel 프로젝트를 서로 연결하는 과정을 진행했다면 해당 프로젝트 폴더의 root에 .vercel 폴더가 생깁니다. .vercel/project.json 파일을 열어보면 projectId 프로퍼티가 존재하는데, 이 값이 Project ID입니다.Token Vercel 페이지로 접속합니다. 로그인 합니다. 우측 상단 프로필 이미지를 클릭합니다. [Settings]를 클릭합니다. 좌측 메뉴에서 [Tokens]를 클릭합니다. [Token Name] [Scope] [Expiration]을 입력하고 [Create] 버튼을 누릅니다. Scope는 반드시 배포를 진행할 프로젝트가 소속 된 조직으로 설정합니다. 발급 된 Token을 사용합니다. 한번 발급 된 Token은 어떠한 방법으로도 재열람이 불가능하니 반드시 다른 곳에 안전하게 보관해야 합니다. Team ID Vercel 페이지로 접속합니다. 로그인 합니다. 좌측 상단 조직명을 클릭합니다. 상단 [Settings]를 클릭합니다. [General] 탭의 중간 쯤에 있는 Team ID를 복사합니다.Github Secret Key 등록하기CI/CD를 진행하기 위해서는 위에서 얻은 여러 Key 값을 활용해야 합니다.하지만 Key 값은 보안상 매우 엄중히 관리 되어야 하기 때문에 Repository에 그대로 노출 되는 Github Action에 평문으로 작성하면 보안상 심각한 이슈를 낳을 수 있습니다.그렇기에 Github는 보안상 민감한 Key를 별도의 저장소에 보관하고 관리할 수 있도록 Secret Variables 저장소를 지원합니다. Vercel에 배포할 프로젝트의 Github Repository에 진입합니다. 상단 [Settings] 탭을 클릭합니다. 좌측 메뉴 [Security] 항목의 [Secrets and variables] 탭을 클릭합니다. 하위의 [Actions] 탭을 클릭합니다. [New repository secret] 버튼을 클릭합니다. 위에서 얻은 네 가지 Key를 다음의 이름으로 저장합니다. Organization ID → VERCEL_ORG_ID Project ID → VERCEL_PROJECT_ID Team ID → VERCEL_TEAM_ID Token → VERCEL_TOKEN 저장 했다면 다음과 같은 Secret Variables 목록을 보실 수 있습니다. .github 디렉토리 만들기 프로젝트 Root 폴더에 .github 폴더를 만듭니다. .github 폴더 안에 workflows 폴더를 만듭니다.Preview 배포 자동화 스크립트 작성하기 위에서 생성한 .github/workflows 폴더 안에 vercel-preview-deploy.yaml 파일을 생성합니다. 아래와 같이 스크립트를 작성합니다. name: Vercel Preview Deployment env: VERCEL_ORG_ID: $ VERCEL_PROJECT_ID: $ on: push: branches: - &quot;develop&quot; jobs: Deploy-Preview: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Install Vercel CLI run: npm install --global vercel@latest - name: Pull Vercel Environment Information run: vercel pull --yes --environment=preview --token=$ - name: Build Project Artifacts run: vercel build --token=$ - name: Assign beta domain run: | vercel deploy --prebuilt --token=$ &amp;gt; domain.txt vercel alias set `cat domain.txt` staging-logomakershop-biz.vercel.app --scope $ --token $ 원격 Repository에 푸쉬합니다.Preview 배포 스크립트 이해하기 VERCEL 배포에 필요한 조직 ID와 PROJECT_ID를 설정합니다. name: Vercel Preview Deployment env: VERCEL_ORG_ID: $ VERCEL_PROJECT_ID: $ develop 브랜치에 새로운 히스토리가 추가 되면 해당 Workflow가 작동합니다. on: push: branches: - &quot;develop&quot; Ubuntu 가상머신을 통해 아래 프로세스를 수행합니다. jobs: Deploy-Preview: runs-on: ubuntu-latest 해당 프로세스의 이름을 Deploy-Preview라고 명명합니다. 배포를 위한 Vercel 패키지를 설치합니다. - name: Install Vercel CLI run: npm install --global vercel@latest Vercel 설정값을 다운로드 합니다. - name: Pull Vercel Environment Information run: vercel pull --yes --environment=preview --token=$ 배포를 위한 인스턴스는 .vercel 파일이 없으므로 Vercel 설정값을 다운 받아야 합니다. --yes 플래그는 해당 명령어에 대한 Confirm 여부를 모두 Yes로 설정합니다. 프로젝트를 빌드합니다. - name: Build Project Artifacts run: vercel build --token=$ 새로운 Preview 버전을 생성하고 미리 생성해둔 staging 도메인을 별명으로 정합니다. - name: Assign beta domain run: | vercel deploy --prebuilt --token=$ &amp;gt; domain.txt vercel alias set `cat domain.txt` staging-logomakershop-biz.vercel.app --scope $ --token $ vercel deploy --prebuilt 명령어를 이용하여 Preview 배포를 실행합니다. vercel deploy --prebuilt 명령어는 새롭게 발급 된 도메인을 Output으로 반환합니다. 새로 발급 된 도메인을 domain.txt 파일에 저장합니다. vercel alias set 명령어로 domain.txt 파일에 저장 된 도메인을 Staging 도메인에도 연결합니다. ❓ 왜 alias가 필요한가요?위에서 언급 했듯이 Preview는 매번 새로운 도메인을 생성하여 배포합니다.매번 새로운 도메인을 생성하게 되면 고정 된 URL이 필요한 여러 상황에서 방해가 됩니다. Preview 확인이 필요한 내부 관계자에게 최신 Preview 주소를 매번 고지 해줘야 합니다. Cognito와 같이 Redirect URI를 입력 해야 이용할 수 있는 서드파티 솔루션을 사용할 수 없습니다.위와 같은 이유로 언제나 최신 Preview를 유지하는 고정 된 도메인이 필요합니다.Production 배포 자동화 스크립트 작성하기 .github/workflows 폴더에 vercel-product-deploy.yaml 파일을 생성합니다. 해당 파일에 다음과 같이 스크립트를 작성합니다. name: Vercel Production Deployment env: VERCEL_ORG_ID: $ VERCEL_PROJECT_ID: $ on: push: branches: - &quot;master&quot; # or main jobs: Deploy-Production: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Install Vercel CLI run: npm install --global vercel@latest - name: Pull Vercel Environment Information run: vercel pull --yes --environment=production --token=$ - name: Build Project Artifacts run: vercel build --prod --token=$ - name: Deploy Project Artifacts to Vercel run: vercel deploy --prebuilt --prod --token=$ Production 배포 스크립트 이해하기 Vercel 프로젝트에 대한 설정을 진행합니다. name: Vercel Production Deployment env: VERCEL_ORG_ID: $ VERCEL_PROJECT_ID: $ master 브랜치에 새로운 히스토리가 푸쉬 되면 해당 Workflow가 동작합니다. on: push: branches: - &quot;master&quot; # or main Ubuntu 가상머신을 통해 아래 프로세스를 실행합니다. jobs: Deploy-Production: runs-on: ubuntu-latest Vercel 배포를 위한 CLI 패키지를 npm에서 설치합니다. - name: Install Vercel CLI run: npm install --global vercel@latest Vercel 설정을 다운로드 합니다. - name: Pull Vercel Environment Information run: vercel pull --yes --environment=preview --token=$ 빌드 합니다. ```yaml name: Build Project Artifacts run: vercel build –prod –token=$ ``` --prod 플래그를 활용하면 Production 모드로 빌드합니다. 배포를 진행합니다.마치며이번 문서에서는 이렇게 Next.js와 Vercel 그리고 Github Workflow를 활용한 배포 자동화를 진행해봤습니다 🎉제가 처음 연동을 진행했을 때 겪었던 모든 트러블을 상세히 작성하느라 다소 분량 조절에 실패한 듯한 느낌이 들지만 이 문서 하나로 다른 많은 개발자분들이 시간을 아낄 수 있다고 생각하면 이보다 보람찬 일도 또 없을 것 같습니다.다음번에는 Slack Bot을 이용하여 유관자들에게 배포 상태에 대한 알림을 자동으로 보내주는 방법도 기재할 예정이오니 많은 관심 부탁드립니다 🙇" }, { "title": "Taxonomy 대응을 위한 좋은 아키텍처", "url": "/posts/good-taxonomy-architecture/", "categories": "Tech, Architecture", "tags": "React, Architecture, Taxonomy", "date": "2023-08-23 18:47:00 +0800", "snippet": "안녕하세요 박찬영입니다 🙂이번 포스트에서는 Taxonomy를 연동하면서 겪었던 어려운 문제와 Challenge 경험을 공유하기 위해 작성합니다.동일한 문제를 앓았거나 앓을 예정이신 분들께서 보시고 좋은 영감을 얻어가셨으면 좋겠습니다.Taxonomy란?본 문서의 이해를 위해 간단하게 설명하자면 ‘유저의 행동 패턴을 분석하기 위한 방법’ 입니다.사용자는 대부분의 경우 개발자의 의도대로 움직여주지 않습니다.누르라고 만든 버튼을 사용자가 못찾는다거나 사용 빈도가 적을 것으로 예상 되었던 기능이 가장 호응을 많이 받게 되는 경우가 있는데 이런 상황은 기획과 개발 단계에서 예측할 수 없죠.심지어 사용자는 본인이 무엇을 원하는지 서비스 제공자에게 알려주지 않습니다.서비스 제공자는 사용자가 원하는 니즈를 알아 맞추는 퀴즈를 풀어야만 하는데 Taxonomy는 이를 풀어내는데 결정적인 도움을 제공합니다.‘사용자가 버튼을 눌렀다’ 는 간단한 이벤트를 알려주는 것 뿐 아니라 해당 사용자가 어떤 사용자인지, 어떤 타이밍에 눌렀는지, 어떤 작업을 하다 눌렀는지 등을 유추할 수 있도록 각종 프로퍼티를 함께 전송할 수 있습니다.좋은 아키텍처가 필요한 이유제가 이번에 진행했던 Taxonomy 연동 작업에서 실제로 있었던 일을 예시로 설명 드리겠습니다.위 사진은 제가 개발한 서비스의 와이어프레임입니다.좌측에 보여지는 템플릿 목록에서 템플릿을 하나 선택하면 사용자가 편집하고 있는 에디터에 해당 템플릿이 반영 되는 기능이 있어요.해당 기능을 위한 Flow는 아래와 같습니다. 좌측 템플릿 패널에서 카테고리를 선택하여 카테고리에 맞는 템플릿을 조회할 수 있습니다. 템플릿을 선택하면 현재 편집하고 있는 디자인에 덮어쓰기 됩니다.이런 식으로 디자인의 교체가 이루어지는 것이죠.예시 이벤트지금부터 Taxonomy 연동 작업 중 어려웠던 여러 사례를 설명 드리기 위해 제가 실제로 작업 했던 이벤트를 가지고 설명하겠습니다.제가 PO분께 전달 받은 Taxonomy Event Spec에는 다음과 같은 Event가 있었습니다. 사용자가 [편집 된 디자인을 저장] 할 경우 이벤트 전송 [이벤트 프로퍼티] 템플릿의 id (만약 템플릿이 교체 되었다면) 해당 템플릿을 선택할 당시에 선택했던 카테고리의 id (만약 템플릿이 교체 되었다면) #1. 데이터 Scope에 대한 변경이 자주 발생한다.위에서 설명한 이벤트를 올바르게 전송하기 위해서는 [내가 템플릿 교체 당시 선택했던 카테고리]와 [교체한 템플릿의 정보]를 알아야 합니다.하지만 이는 현재 구조에서는 불가능한 작업이었습니다.위 이미지는 에디터 화면의 컴포넌트 구조를 나타낸 그래프입니다.보시면 [템플릿 패널] 컴포넌트 내부에서 카테고리와 템플릿 리스트에 대한 정보를 모두 가지고 있는데, 정작 저장이 이루어지는 곳은 [헤더] 컴포넌트 하위에 존재하는 [저장 버튼] 컴포넌트입니다.처음 설계 당시에는 Taxonomy Spec이 정해지지 않았기 때문에 템플릿 탐색에 필요한 데이터를 굳이 전역으로 올려서 다루지 않았기에 생긴 일이죠.이 문제를 해결하려면 [템플릿 패널] 컴포넌트에서 다루고 있는 데이터를 [편집 페이지]와 동일하거나 더욱 상위의 개념으로 끌어올려야 합니다.다른 Scope에서 사용하고 있는 데이터를 요구하는 택소노미의 경우 데이터 자체의 Scope를 변경하지 않으면 사용할 수가 없습니다.하지만 단순히 값을 전역 레벨로 올려 사용하게 되면 관심사 분리가 모호해지고 이는 추후 기술적인 빚을 야기할 수 있습니다.#2. 불필요한 데이터의 개입Taxonomy 연동 과정이 어려운 두 번째 이유는 사용자의 경험을 위해 설계한 Flow에 불필요한 데이터가 개입하게 된다는 점입니다.예시를 하나 들어볼게요.단순하게 생각했을 때 [저장]이라는 행위를 처리하기 위해 필요한 데이터는 현재 작업물에 필요한 데이터 뿐입니다.하지만 저장 로직에 Taxonomy Event에 대한 전송 로직을 추가 하기 위해서는 저장과는 관련이 없을 수도 있는 데이터가 저장 Flow에 개입하게 됩니다.이 과정에서 택소노미 코드와 저장 코드를 명확하게 분류하지 못한다면 이해하기 모호하고 유지보수하기 굉장히 힘든 Flow로 변질 될 가능성이 있습니다.#3. 오염되는 소스코드[저장] 기능은 단순히 사용자가 저장 버튼을 눌렀을 때만 실행 되는 것이 아닙니다.예기치 못한 상황에서 작업물을 보호하기 위해 작업물을 저장하는 등 여러 부분에서 저장이 이루어지기 때문에 Taxonomy에 대한 로직도 시나리오마다 대응을 해줘야 합니다.이러한 Task는 자연스럽게 Taxonomy 관련 코드를 파편화 되게 만들며, 더 나아가 Taxonomy Event Property에 대한 관리도 어렵게 만들기 때문에 유지보수를 위해서 Taxonomy의 처리와 관련한 모든 함수를 한 곳에 모아 둘 필요가 있습니다.Context를 이용한 Taxonomy 로직 분리페이지 구조 분석Context는 Nested Component 구조에서 데이터를 여러 컴포넌트에 효율적으로 전파하기 위한 가장 간단한 솔루션입니다.Taxonomy 로직 분리를 위해 우선 현재 프로젝트의 컴포넌트 구조를 다시 살펴봅시다.위 사진은 편집 페이지의 컴포넌트 구조입니다.사용자는 Root에 해당하는 [페이지] 레벨로 진입하여 서비스를 이용하게 됩니다.Taxonomy가 수집하고자 하는 정보들은 유저의 행동 패턴이기에 이를 토대로‘사용자의 모든 행위는 페이지에서 이루어지니까 Taxonomy 분리도 페이지 단위로 할 수 있다.’는 결론을 세울 수 있게 됩니다.Taxonomy 수집을 위한 Values Context 생성저는 이러한 결론을 토대로 페이지 레벨을 아우르는 Context를 만들었습니다.이 Context는 해당 페이지에서 전송 되어야만 하는 Taxonomy 이벤트와 관련한 Value들을 저장하는 Context입니다. 템플릿 패널에서 사용자가 조회하는 카테고리 리스트의 id 템플릿 패널에서 사용자가 선택한 템플릿의 id이로 인해 비즈니스 로직을 자체적으로 수행하는 컴포넌트 내부에서만 갖고 있는 여러 데이터들을 상위 레벨로 끌어올려 적절하게 사용할 수 있게 되었습니다.또한 React의 Context는 Provider를 생성할 때마다 Value를 초기화 해야합니다.Value를 초기화 하는 코드가 페이지 컴포넌트에서 너무 많은 비중을 차지하게 되면 코드 가독성을 해칠 수 있으니컴포넌트 생성부에서 공용으로 사용할 Provider도 같이 정의합니다.// 택소노미 데이터를 핸들링 하기 위한 Context입니다.export const TaxonomyValuesContext = createContext&amp;lt;TaxonomyValuesContextArguments&amp;gt;({});export const TaxonomyValuesContextProvider = ({ children }: { children: ReactNode }) =&amp;gt; { const [selectedTemplateCategory, setSelectedTemplateCategory] = useState&amp;lt;TaxonomyTemplateCategory&amp;gt;(); const [selectedTemplateId, setSelectedTemplateId] = useState&amp;lt;string&amp;gt;(); return ( &amp;lt;TaxonomyValuesContext.Provider value={{ selectedTemplateCategory, setSelectedTemplateCategory, selectedTemplateId, setSelectedTemplateId, }} &amp;gt; { children } &amp;lt;/TaxonomyValuesContext.Provider&amp;gt; );};⚠️ 이렇게 생성한 Context는 순수하게 Taxonomy 수집 용도로만 사용 되어야 합니다. 비즈니스 로직에 사용 될 경우 목적이 불분명해지고 추적할 수 없는 리렌더링이 이루어질 수 있습니다.Taxonomy 수집을 위한 Event Context 생성Taxonomy에서 수집하고자 하는 이벤트는 비즈니스 로직에 포함 되어야만 하는 경우가 있을 수 있습니다. 파일의 전송이 완료 된 경우 사용자가 게시물을 업로드 했으나 네트워크 요청에 실패한 경우 사용자가 결제를 완료 했을 때 지불 된 금액과 상품명을 수집하는 경우위와 같은 여러 상황에서 이벤트를 수집하려고 하면 Taxonomy 코드가 여러 컴포넌트 내부에 놓이게 됩니다.위 그래프와 같은 상황에서는 다음과 같은 문제점을 발생시킬 수 있어요. 특정 이벤트를 삭제 해야하는데 도대체 어디에 작성 된 건지 모르겠어요. 동일한 이벤트의 프로퍼티를 수정해야 하는데 너무 여러곳에서 사용 되어서 수정하기가 힘들어요. 도대체 갑자기 왜 이벤트 전송이 발생하는지 추적할 수가 없어요.이러한 문제를 해결하기 위해 이벤트 전송 관련 함수만을 포함하는 Event Context를 따로 생성하였습니다.Event Context를 그래프와 같이 생성함으로써 다음과 같은 이점을 얻을 수 있습니다. Taxonomy Event 전송을 위한 함수의 구현부를 한 곳에 집약할 수 있어요. 파편화 현상이 없어지므로 추후 이벤트의 추적과 수정이 용이해요.또한 Value Context와 마찬가지로 Provider 초기화 코드를 페이지에 작성하지 않기 위해 Provider를 따로 정의하면 페이지 컴포넌트의 코드를 깔끔하게 유지할 수 있습니다.export const TaxonomyEventsContext = createContext&amp;lt;TaxonomyEventsContextArguments&amp;gt;({});export const TaxonomyEventsContextProvider = ({ children }: { children: ReactNode }) =&amp;gt; { const { selectedTemplateCategory, selectedTemplateId, } = useContext(TaxonomyValuesContext); const setTaxonomyCreateSave = () =&amp;gt; { // 저장 시 Taxonomy 이벤트 전송 track({ event_type: &#39;create_save&#39;, event_properties: { selectedTemplateCategory, selectedTemplateId, }, }); } return ( &amp;lt;TaxonomyEventsContext.Provider value={{ setTaxonomyCreateSave, }} &amp;gt; { children } &amp;lt;/TaxonomyEventsContext.Provider&amp;gt; );};복잡한 Context 정리페이지 컴포넌트는 개발 도중 발생하는 여러 이슈로 인해 이미 Context Provider가 매우 복잡하게 선언 된 상황일 수 있습니다.&amp;lt;TaxonomyValueContextProvider&amp;gt; &amp;lt;TaxonomyEventContextProvider&amp;gt; &amp;lt;FirstProvider&amp;gt; &amp;lt;SecondProvider&amp;gt; &amp;lt;ThirdProvider&amp;gt; { children } &amp;lt;/ThirdProvider&amp;gt; &amp;lt;/SecondProvider&amp;gt; &amp;lt;/FirstProvider&amp;gt; &amp;lt;/TaxonomyEventContextProvider&amp;gt;&amp;lt;/TaxonomyValueContextProvider&amp;gt;// Terrible Context Hell위에서 설명한 아키텍처를 채용했다면 페이지 컴포넌트에는 두 개의 Provider가 추가로 존재하게 됩니다.Context Hell 현상은 그 자체만으로 코드의 가독성을 해치며 코드를 읽기 싫게 만듭니다.Taxonomy Value와 Taxonomy Event Context는 ‘이벤트 전송’이라는 하나의 역할에 충실한 Context이기 때문에 이 둘을 하나로 묶으면 Provider를 한 개로 줄일 수 있습니다.// Taxonomy.tsximport { ReactNode } from &#39;react&#39;;import { TaxonomyEventsContextProvider } from &#39;./TaxonomyEvents/context&#39;;import { TaxonomyValuesContextProvider } from &#39;./TaxonomyValues/context&#39;;export const TaxonomyContextProvider = ({ children }: { children: ReactNode }) =&amp;gt; { return ( &amp;lt;TaxonomyValuesContextProvider&amp;gt; &amp;lt;TaxonomyEventsContextProvider&amp;gt; { children } &amp;lt;/TaxonomyEventsContextProvider&amp;gt; &amp;lt;/TaxonomyValuesContextProvider&amp;gt; );};// page.tsx&amp;lt;TaxonomyContextProvider&amp;gt; &amp;lt;FirstProvider&amp;gt; &amp;lt;SecondProvider&amp;gt; &amp;lt;ThirdProvider&amp;gt; { children } &amp;lt;/ThirdProvider&amp;gt; &amp;lt;/SecondProvider&amp;gt; &amp;lt;/FirstProvider&amp;gt;&amp;lt;/TaxonomyContextProvider&amp;gt;// A little terrible Context Hell마치며Taxonomy를 연동하면서 가장 어려웠던 점은 기존 로직과의 의존성을 최대한 배제하는 작업이었습니다.이로 인해 기존 Flow를 전면적으로 수정 하느라 힘든 부분들이 다소 있었지만 의존성을 덜어내기 위한 아키텍처를 진지하게 고민해볼 수 있었고, 프로젝트의 구조를 다시 살펴볼 수 있는 시간이 되어서 나름 유의미한 시간이었다 생각합니다.저의 삽질이 다른 많은 사람들의 시간을 절약해 줄 수 있길 바라며 긴 글 마치겠습니다.읽어주셔서 감사합니다 🙌" }, { "title": "사용자 경험을 위한 의도적인 비효율", "url": "/posts/dummy-delay-for-more-ux/", "categories": "", "tags": "Tech, Talk", "date": "2023-08-21 19:23:00 +0800", "snippet": "안녕하세요 👋 박찬영입니다.오늘은 사용자의 경험을 증가 시키기 위해 의도적으로 소프트웨어의 응답을 늦추는 사례에 대해서 소개하고자 해요.과거의 최적화개발 업계에 몸 담고 있는 사람이 아니어도 한 번 쯤 들어본 적이 있는 에피소드를 소개 하고자 합니다.바로 현대 플랫폼 게임의 선구자, 슈퍼마리오인데요.슈퍼마리오 초기버전이 등장한 시기는 1985년입니다.이 때의 하드웨어 사양은 현재에 비할 바가 못될 정도로 엄청난 저사양이었어요.닌텐도가 그 때 당시 개발한 ‘패미컴’은 하드웨어의 가용 용량이 50kb 정도로, 현재로 따지자면 저화질 사진 하나도 제대로 담지 못할 용량이었다고 해요.그래서 당시 닌텐도에서 근무하던 슈퍼마리오 개발자는 게임에 들어가는 리소스 용량을 극한으로 절약하고자 여러가지 시도를 하게 돼요.만약 당신이 슈퍼마리오 아트팀의 담당자라고 가정했을 때 ‘까만색 손목 보호대를 착용한 보스를 그려주세요’ 라는 오더가 접수된다면 여러분은 어떻게 하실 건가요?아마 오더대로 까만색 손목 보호대를 그대로 그리는 경우가 대부분일 겁니다.하지만 극도로 한정 된 리소스를 절약해야 하는 슈퍼마리오의 아트팀은 한가지 묘수를 생각했는데요, 슈퍼마리오 게임의 보스 스테이지 뒷 배경이 까만색이라는 점에서 착안하여 손목 보호대를 아예 그리지 않은 겁니다.픽셀 데이터가 없는 손목 보호대 영역은 투명하게 렌더링 될 것이고, 보스 스테이지의 배경이 투과되어 까만색으로 보여질 것이기 때문이죠.이처럼 과거에는 하드웨어의 제약 사항 때문에 사용자 경험을 위한 여러 장치들을 연구 해야만 했고, 그 연구의 산물이 오늘날 까지도 이어져 온 경우가 많아요.그 예시로는 ‘로딩 팁’이 있어요.캐릭터가 사망하거나 다른 지역으로의 이동이 발생하면 해당 스테이지의 정보를 초기화 하는 등의 작업이 수반 됩니다.이 과정에서는 게임의 진행을 잠시 멈추고 대기해야 하는데 하드웨어 사양이 안좋았던 옛날에는 로딩 시간이 매우 길고 지루했을거예요.플레이어가 이 지루한 시간을 그나마 재미있게 보내라는 의미에서 개발자들은 로딩 화면을 재미있게 보낼 수 있도록 여러 시도를 했고, 그 산물 중 하나가 위 사진에 나오는 ‘로딩 팁’입니다.‘내가 이 게임을 진행하는데 필요한 정보를 줄테니까 무의미하게 시간 버리지 말고 이거라도 봐라’ 라는 의미인거죠.오늘날의 최적화오늘날에는 위 사례처럼 광적(?)으로 최적화에 집착하는 사례는 찾아보기 힘들어요.오히려 최적화를 너무 안해서 욕을 먹는 경우가 많죠.그렇게 만들어도 게임을 출시하는데 문제가 없을 정도로 가정용 하드웨어가 많이 발전했기 때문이예요.그런데 무엇이든 너무 과하면 안좋은걸까요? 이번에는 너무 빨라서 생긴 사례에 대해 소개 할게요.‘고스트 오브 쓰시마’(이하 고오쓰)라는 2020년도에 발매한 게임이 있습니다.이 게임도 마찬가지로 ‘로딩 팁’ 시스템을 추가했어요.캐릭터가 사망하면 게임을 진행하는 팁을 알려주는 화면이 표시가 되는거죠.하지만 개발자들은 이 시스템을 도입하고 한가지 문제를 겪게 돼요.하드웨어의 사양이 너무 빨라서 로딩 창에 표시 되는 팁을 읽을 시간조차 주어지지 않았던거죠.이러한 문제점을 인지한 고오쓰 개발진은 ‘로딩 시간을 의도적으로 늘려봐’ 라는 오더를 개발팀에게 주문하였고 지금의 로딩 팁은 ‘로딩은 진작에 끝난 팁 화면’이 되어 버린 것이죠.이처럼 사용자들이 익숙한 ‘로딩 팁’이라는 UX를 경험시켜 주기 위해 의도적으로 비효율을 발생 시키는 사례도 존재합니다.직접 겪은 사례위 화면은 사용자가 저장 버튼을 누를 때 보여지는 Toast 메시지입니다.혹시 눈치 채셨나요? 순간적으로 ‘Doodling with Data.’ 라는 메시지가 로딩 중에 표시되고 있어요.우리 팀의 백엔드 개발자분들이 열일을 해주신 덕분에 API 응답 속도가 정말 너무 빠르더라구요.[로딩 중 메시지] → [성공 / 실패 메시지]와 같이 로딩 메시지가 보여지도록 구현 하였는데, 로딩 중이라는 것을 알리는 메시지가 너무 순식간에 지나가버려서 제 역할을 하지 못한 것이죠.더미 딜레이 적용저는 사용자 경험을 위해 ‘사용자가 인지할 수 있는’ 로딩 메시지를 보여주길 원했고, 고의적인 딜레이를 추가하여서 이 문제를 해결 했습니다.고의적인 딜레이를 만드는데 있어서 제가 생각한 조건은 다음과 같습니다. 개발자가 직접 딜레이 시간을 기입하여 재사용이 가능해야 할 것 실제 로딩 속도가 고의적인 딜레이를 상회한다면 딜레이를 주지 말고 완료 할 것 실제 로딩 속도도 긴데 딜레이까지 추가 되면 사용자 경험을 심각하게 저해할 수 있기 때문 위와 같은 고민을 녹여 DummyDelay Class를 작성했습니다./** * API와 같은 다양한 비동기 호출에서 고의적으로 딜레이를 시켜서 로딩 화면을 보여주기 위한 클래스입니다. */export class DummyDelay { /** * promise api를 전달받으면 promise api가 완료 되기 까지의 실제 시간과 최소 시간을 비교하여 * 설정한 최소 시간보다 api의 응답 시간이 길면 가짜 딜레이를 사용하지 않고 * 만약 그보다 짧으면 남은 시간만큼 가짜 딜레이를 진행합니다. * @params promise * @params delay * @params promise */ public static start&amp;lt;T&amp;gt;(promise: Promise&amp;lt;T&amp;gt;, delay: number) { return new Promise&amp;lt;T&amp;gt;((resolve, reject) =&amp;gt; { const startTime = (new Date()).getTime(); promise .then((response) =&amp;gt; { const endTime = (new Date()).getTime(); const takenTime = endTime - startTime; if (takenTime &amp;gt; delay) { resolve(response); } else { window.setTimeout(() =&amp;gt; resolve(response), delay - takenTime); } }) .catch((error) =&amp;gt; { const endTime = (new Date()).getTime(); const takenTime = endTime - startTime; if (takenTime &amp;gt;= delay) { reject(error); } else { window.setTimeout(() =&amp;gt; reject(error), delay - takenTime); } }); }); }};DummyDelay.start 메소드는 다음과 같은 절차에 의해 실행 됩니다. 첫 번째 매개변수로 promise callback을 받습니다. (API 호출 등) promise callback을 실행하기 전에 DummyDelay.start 함수의 실행 시간을 저장합니다. 완료 혹은 실패 시 시점을 저장하여 함수의 시작 시간과 비교합니다. 종료까지 걸린 시간이 딜레이보다 길 경우 resolve를 실행하여 값을 반환합니다. 그렇지 않다면 남은 시간만큼 딜레이를 주어 사용자가 설정한 딜레이 시간을 채워서 값을 반환합니다.DummyClass를 적용한 예시입니다.마치며하드웨어의 사양 부족으로 인해 생겨난 여러가지 해결책들이 오늘날에 와서는 ‘없으면 허전한’ 요소로서 취급 되는 상황도 있다는 것을 새삼스럽게 알게 되었습니다.단순히 속도적인 측면으로서 생각해보면 위 케이스들에서 제가 만들어낸 DummyDelay Class, 고오쓰의 로딩 팁 등은 필요하지 않은 것이 사실입니다.그러나 이미 이러한 요소들에 익숙해진 사용자들의 시선을 맞추기 위해 속도를 희생 하면서 까지 보여줘야 하는 하나의 컨텐츠가 되어버린 것이죠.미래에는 속도를 희생 하지도 않고, 사용자들의 경험도 충족 시켜줄 새로운 UX가 나오게 되지 않을까 싶습니다." }, { "title": "사용자의 액션을 분석해보자! Amplitude의 Taxonomy 연동 방법", "url": "/posts/amplitude-taxonomy-for-fe/", "categories": "Tech, Talk", "tags": "Taxonomy, Amplitude, React", "date": "2023-08-06 22:25:00 +0800", "snippet": "들어가며안녕하세요 😀 박찬영입니다.저는 회사에서 신규 서비스 런칭을 앞두고 있기 때문에 정말 많은 Task가 몰아치는 하루를 보내고 있어요 😭그렇게 해결했던 수많은 Task 중 문서로 남겨두면 유용할 법한 내용을 가져왔어요!Amplitude란?Amplitude는 서비스의 사용성을 증대시키는데 도움을 줄 수 있는 다양한 정보를 수집하고 응용하기 위한 서비스입니다.TaxonomyTaxonomy란 유저들이 어떠한 ‘행위’를 했을 때 해당 행위에 대한 데이터들을 수집하여 유저가 ‘어떤 버튼을 많이 눌렀는가’, ‘이 행동을 한 유저는 어떠한 공통점을 보이는가’ 등유저들의 상황을 이해하고 이를 기반으로 서비스의 사용성을 증대시키기 위한 행동 수집 방식입니다.본 문서에서는 많은 서비스들이 사용하는 서비스인 Amplitude를 사용하여 Taxonomy Event를 수집하는 방법에 대해 알아보도록 하겠습니다.Amplitude Browser SDK 설치Amplitude에 이벤트를 전송하거나 유저 정보에 대한 설정을 하기 위해서는 Browser SDK가 필요합니다.Amplitude는 다양한 플랫폼과 패키지매니저를 지원하므로 가급적 npm을 이용하여 설치 하는 것을 권장합니다.npmnpm i -S @amplitude/analytics-browseryarnyarn add @amplitude/analytics-browserSDK 설정위에서 설치한 SDK를 프로젝트에 사용하기 위해서는 Amplitude 서비스와 내 프로젝트를 연결하는 과정이 필요합니다.Amplitude API Key 발급Find your Amplitude Project API Credentials - Amplitude Developer Center 설정 페이지에 접근합니다. Projects 페이지에서 API Key를 발급 받을 프로젝트를 선택합니다. 이 곳에서 API Key를 발급 받을 수 있습니다. 프로젝트 적용 일반적인 라이브러리의 초기화 방법과 동일하다고 보시면 됩니다. 어느 곳에 접속하더라도 프로젝트에 대한 초기화가 이루어질 수 있도록 프로젝트 진입부에 아래와 같은 코드를 추가 해야 합니다. import * as amplitude from &#39;@amplitude/analytics-browser&#39;; amplitude.init(&#39;&amp;lt;YOUR_API_KEY&amp;gt;&#39;); Next.js의 경우 _app.tsx 페이지에 코드를 적용하면 됩니다. 다만 저의 경우는 _app.tsx 파일이 각종 라이브러리의 초기화 로직으로 지저분해지는 것을 방지하기 위해 AmplitudeSDK.tsx 컴포넌트를 생성하여 코드를 작성하였습니다. // AmplitudeSDK.tsx import * as amplitude from &#39;@amplitude/analytics-browser&#39;; import { HTMLAttributes, useEffect } from &#39;react&#39;;; export interface AmplitudeSDKProps extends HTMLAttributes&amp;lt;HTMLDivElement&amp;gt; { } export const AmplitudeSDK = ({ ...others }: AmplitudeSDKProps) =&amp;gt; { useEffect(() =&amp;gt; { amplitude.init(process.env.AMPLITUDE_TAXONOMY_API_KEY as string); }, []); return ( &amp;lt;&amp;gt;&amp;lt;/&amp;gt; ); }; 이렇게 만들어진 AmplitudeSDK.tsx 파일은 _app.tsx에 적용하면 됩니다. &amp;lt;QueryClientProvider&amp;gt; &amp;lt;Provider store={store}&amp;gt; &amp;lt;AppHead /&amp;gt; &amp;lt;AmplitudeSDK /&amp;gt; // 이렇게 추가해 주세요 { Layout(&amp;lt;Component { ...props.pageProps } {...props} /&amp;gt;) } &amp;lt;/Provider&amp;gt; &amp;lt;/QueryClientProvider&amp;gt; 계획 된 이벤트 설정 방법 본격적으로 Taxonomy를 활용한 이벤트 수집을 시작하기 전에 이벤트를 설정하는 방법에 대해 알아보겠습니다. 이벤트 목록 확인하기 Amplitude Dashboard 페이지에서 [Data] 항목을 선택합니다. 좌측 메뉴의 [Event] 탭을 클릭하면 프로젝트에 설정 된 이벤트를 볼 수 있습니다.Taxonomy StatusAmplitude의 이벤트 Status에는 세 가지 [Status]가 존재합니다. Live: 사전에 수집하기로 했었던 이벤트이며, 서비스에서 수집 된 케이스가 하나 이상 존재하는 이벤트 Planned: 계획은 했지만 서비스에서 수집 된 데이터가 없는 이벤트 Unexpected: 계획하지 않았지만 서비스에서 수신 된 이벤트세 가지 상태에서 실제로 유의미하게 사용할 수 있는 데이터는 [Planned] 데이터이므로 사전에 필요할 것 같은 데이터를 정의하는 과정이 필요합니다.이벤트 수집 계획 작성하기이벤트 페이지 우측 상단에 존재하는 [Create event] 버튼을 누르면 다음 프로세스를 통해 이벤트 계획을 수립할 수 있습니다 이벤트 이름을 작성합니다. 이벤트에 대한 세부 설정을 진행합니다. 세부 설정으로는 이벤트 프로퍼티, 카테고리, 수집 상태 등을 설정할 수 있습니다. 이벤트 프로퍼티 유저의 행동 패턴을 분석할 때 “어떤 유저가 버튼을 눌렀대요” 라는 막연한 사실만을 통보받는다면 해당 유저가 왜 하필 그 시간대에 버튼을 눌렀는지와 같은 세부적인 추론을 할 수 없습니다.그러한 니즈를 해결하기 위해 이벤트를 실행하는 사람의 의도를 추론하기 위한 여러 단서를 붙여서 이벤트와 함께 전송할 수 있는데 이를 이벤트 프로퍼티라고 부릅니다. [Add Property] 버튼을 클릭하면 프로퍼티를 추가할 수 있습니다.추가 된 프로퍼티를 클릭하여 세부 정보를 살펴보면이처럼 해당 프로퍼티에 들어갈 값을 설정할 수 있습니다.이벤트 프로퍼티는 문자열, 숫자, Enum 등 다양한 자료형을 지원합니다.만약 하나의 이벤트에 다수의 프로퍼티를 설정한다면 추후 json 자료형을 이용하여 한번에 다수의 프로퍼티를 설정할 수도 있습니다.Amplitude에 이벤트 전송하기이벤트를 전송하는 방법은 매우 간단합니다.Amplitude SDK에 내장 되어 있는 track 메소드를 사용하면 전송할 수 있습니다.import { track } from &#39;@amplitude/analytics-browser&#39;;track(&#39;event-name&#39;);단순 이벤트의 발생 여부에 대해서만 전송한다면 위와 같이 사용할 수 있습니다.만약 이벤트 프로퍼티와 함께 이벤트를 전송해야 한다면 다음과 같이 작성하면 됩니다.import { track } from &#39;@amplitude/analytics-browser&#39;;track({ &#39;event-name&#39;: &#39;click-button&#39;, &#39;event-property&#39;: { &#39;button-color&#39;: &#39;red&#39;, &#39;button-identity&#39;: &#39;redirect-home&#39;, }});만약 연결하는데 성공했을 경우 해당 이벤트를 발생시키면 브라우저 개발자도구 [Network] 탭에서 다음과 같은 요청을 볼 수 있습니다.짧은 순간에 여러 차례의 이벤트 송신이 발생하면 일정시간 뒤에 발생했던 요청들을 한번에 묶어서 전송하는 모습을 보실 수 있습니다.이 로직은 @amplitude/analytics-browser 라이브러리가 내부적으로 처리하기 때문에 개발자 입장에서는 고려할 필요가 없다는 장점이 있습니다.선 송신 후 계획우리는 [Taxonomy Status] 항목을 통해 ‘예측되지 못한 이벤트도 수신할 수 있구나’ 라는 사실을 알게 되었습니다.Unexpected 상태는 어떻게 사용하면 좋을까요?Amplitude는 Unexpected 상태의 이벤트를 Planned로 바꿀 수 있는 솔루션을 제공하고 있습니다.상단을 보시면 [Review Unexpected] 탭이 존재하는데, 이 탭에서 예측되지 못한 이벤트들을 모아서 볼 수 있습니다.예측되지 못한 이벤트 중 하나를 선택하면 [This event is not in your tracking plan.] 옆에 보이는 Add 버튼이 존재합니다.예측되지 못한 이벤트를 이런식으로 계획의 범주 안에 포함 시킬 수 있습니다.그러면 이걸 어떻게 써먹을 수 있을까요?예상 되는 시나리오는 크게 두 가지 있습니다.#1. 계획은 나중에 등록하고 일단 코딩부터 할 때Amplitude에 수많은 이벤트를 등록하는 것도 하나의 비용입니다.Taxonomy를 개발자에게 연결 해달라고 요청을 할 때 계획 작업이 완료 되어있지 않으면 개발자는 일을 진행할 수가 없는 의존 관계가 형성이 되겠죠.위에서 설명한 방법을 이용한다면 개발자가 먼저 모든 이벤트들을 적재적소에 배치하고 송신하면 예측되지 못한 이벤트로 수집이 될 것이고, 이러한 이벤트들을 추후에 Amplitude에서 계획 이벤트로 변경하여 등록하는 방식으로 업무를 수행할 수 있습니다.#2. 사전에 계획하지 못한 행동을 수집할 때이벤트를 계획하고 수집을 시작했더니 무시할 수 없는 숫자의 사용자가 예상과는 다른 행동을 보일 때 예측되지 못한 이벤트가 수집 될 수 있습니다.이러한 사용자들의 패턴도 분석하고 싶다면 향후 계획 이벤트로 변경하여 정식으로 수집하는 것도 하나의 방법이 될 수 있습니다." }, { "title": "Headless 브라우저를 이용한 스냅샷 촬영 구현", "url": "/posts/headless-browser-snapshot/", "categories": "Tech, Talk", "tags": "", "date": "2023-08-02 00:00:00 +0800", "snippet": "들어가며요즘 업무가 바빠 기술 블로그에 글을 투고 한지 너무 오래 되었다는 것도 잊고 있었습니다.사정 상 주기적인 업데이트가 불가능 했어요 😢그래서 이번 포스트에서는 최근에 있었던 개발 Task 중 가장 인상 깊었던 Task를 갖고 왔습니다!저는 최근에 위 움짤과 같은 에디터를 개발하고 있었습니다.디자인 편집을 가능하게 해주는 이 에디터는 브라우저의 DOM을 이용하는데요, 에디터를 어떻게 만들었는지에 대해서는 할 얘기가 정말 너무 많지만 오늘은 이 얘기에 대해서 조금 접어두고 다른 얘기를 하고자 합니다.DOM 렌더링 엔진의 한계위에서 말씀 드렸다시피 이 에디터는 DOM으로 설계 되어 동작하고 있습니다.그렇다보니 이와 같이 사용자가 작업한 디자인을 미리 보여주는 스냅샷을 촬영하는게 하나의 난제로 다가오게 되었어요.왜냐면 일반적인 방법으로는 DOM에 그려진 요소들을 레스터 이미지로 만드는 방법이 존재하지 않았고, html2canvas와 같은 라이브러리는 렌더링 된 화면을 온전히 그려내지 못했거든요.이런 기능은 비단 Snapshot 뿐 아니라 유저가 제작한 디자인을 다운로드 받게 하는 핵심 기능에도 관여하기 때문에 반드시 해결해야만 하는 문제였어요.그러다가 생각해 낸 하나의 묘수가 바로 Headless 브라우저를 이용한 스냅샷 촬영이었어요.촬영 플로우는 다음과 같아요. Headless 브라우저를 이용하여 렌더링 엔진을 활성화 한다. 렌더링 엔진에서 사용자가 편집한 디자인을 그려낸다. 렌더링 엔진 자체를 Headless 브라우저의 screenshot 메소드를 사용하여 촬영한다. base64로 반환한다.자, 정말 완벽한 계획이죠?다만 이 플랜에는 한가지 단점이 있었어요.렌더링 엔진을 호스팅하는 서비스에 접근하여 그려내야 한다는 점이에요.일단 브라우저를 켜고, 렌더링 엔진 호스팅 서비스에 접근하는 행위 자체가 다소 시간이 걸린다는 점이 문제였어요.이 과정에서 병목을 최대한 줄이기 위해 가장 유명한 브라우저인 Puppeteer 대신 Playwright 브라우저를 채택하자고 아이디어를 낸 백엔드 개발팀 덕분에 브라우저 인스턴스에 대한 로딩 속도는 어느정도 해결 했지만 네트워크 접속 시간에 대해서는 어떻게 하기가 어렵더라구요.그래서 제가 생각해낸 아이디어는 ‘한번 호출한 리소스는 최대한 빼먹어보자‘였어요.기존 스냅샷 촬영 플로우는 다음과 같아요.위 과정을 살펴보면 페이지 접속 혹은 렌더링에 필요한 외부 리소스를 다운로드 받는 과정들이 다수 포함 되어 있는 것을 알 수 있습니다.이로 인해 [작업물 추출] 기능에 가장 큰 성능 저하를 야기하는 부분은 네트워크 관련 부분임을 가늠할 수 있어요.해결 방법원인을 예상했다면 이제 어떤 부분을 바꿔 볼 수 있을까요?자원의 재사용우선 위에 작성한 절차를 밟아보면 페이지를 접속한 이후 렌더링까지 꽤 많은 시간을 소모함을 알 수 있습니다. 페이지 인스턴스의 생성 렌더링 엔진 페이지 열기 렌더링에 필요한 리소스 다운로드 브라우저의 렌더링 완료 대기이렇게 많은 자원을 소모하는 렌더링 프로세스를 각기 다른 해상도의 캡처를 위해 세 번이나 반복합니다.소스코드를 보면서 얘기 해볼까요?const promises = snapshotScales.map(async (scale) =&amp;gt; { const newPage = await browser.newPage(); // 새로운 페이지 인스턴스 생성 await newPage.goto(`${host}/renderer?designId=${designId}&amp;amp;scale=${scale}`, { waitUntil: &#39;domcontentloaded&#39; }); await newPage.waitForSelector(&#39;.RendererScreen__Zoom&#39;); await newPage.waitForSelector(&#39;.TemplateRendererLayer&#39;); await newPage.waitForTimeout(500); // 단순 대기 const jpgScreenshot = await newPage.locator(&#39;.TemplateRendererLayer&#39;).screenshot({ type: &#39;jpeg&#39; }); const pngScreenshot = await newPage.locator(&#39;.TemplateRendererLayer&#39;).screenshot({ type: &#39;png&#39; }); await newPage.close(); // 페이지 인스턴스 닫기 snapshots.jpg.push(jpgScreenshot.toString(&#39;base64&#39;)); snapshots.png.push(pngScreenshot.toString(&#39;base64&#39;));});await Promise.all(promises);위 소스코드는 snapScales라는 배열에 캡처할 배율을 담아두고 렌더링 엔진에 접근하는 로직을 병렬적으로 수행하고 있습니다.이럴 경우 waitForTimeout으로 인해 확정적으로 500ms가 지연이 되고, 각각의 Element가 로드 되는 것을 기다리는 것 까지 합치면 거의 1초에 육박하는 대기시간을 여러번 대기하게 된다는 것을 알 수 있습니다.그래서 아래와 같은 순서대로 수정을 진행했습니다. 한번 렌더링 과정까지 마친 페이지 인스턴스는 모든 이미지를 캡처하기 까지 소멸시키지 않는다. 여러 해상도의 이미지는 DOM Element의 scale을 직접 조정하여 캡처한다.이렇게 수정한 코드는 아래와 같습니다.const newPage = await browser.newPage(); // 새로운 페이지 인스턴스 생성await newPage.goto(`${host}/renderer?designId=${designId}`, { waitUntil: &#39;domcontentloaded&#39; });await newPage.waitForSelector(&#39;.RendererScreen__Zoom&#39;);await newPage.waitForSelector(&#39;.TemplateRendererLayer&#39;);await newPage.waitForTimeout(500); // 단순 대기const promises = snapshotScales.map(async (scale) =&amp;gt; { await newPage.evaluate((scale) =&amp;gt; { const element = document.querySelector(&#39;.TemplateRendererLayer&#39;); element.style.setProperty(&#39;transform&#39; `scale(${scale})`); }, scale); const jpgScreenshot = await newPage.locator(&#39;.TemplateRendererLayer&#39;).screenshot({ type: &#39;jpeg&#39; }); const pngScreenshot = await newPage.locator(&#39;.TemplateRendererLayer&#39;).screenshot({ type: &#39;png&#39; }); await newPage.close(); // 페이지 인스턴스 닫기 snapshots.jpg.push(jpgScreenshot.toString(&#39;base64&#39;)); snapshots.png.push(pngScreenshot.toString(&#39;base64&#39;));});await Promise.all(promises);하지만 이렇게 만들고 나니까 새로운 문제를 마주하게 되었습니다.동일한 인스턴스를 이용한 병렬 처리의 문제점페이지 인스턴스를 초기화 하지 않고 css를 제어하기 때문에 Promise.all을 이용하여 일괄적으로 처리 하고자 하면 연속 된 요청 도중 이전 요청에 대한 css가 남아있기 때문에 최종적인 결과물이 모두 3배율로 뽑히는 문제가 있었습니다.이러한 상황을 해결하려면 순차적으로 이미지 추출을 처리해야 하는데 순차 처리는 일반적인 비동기 처리 상황에서 병렬 처리보다 느립니다.결국 네트워크 요청을 최소화 하느냐 vs 순차적으로 처리하느냐의 Trade-Off가 발생하였고 실제로 얼마나 차이가 나는지를 알아보기 위해 아래와 같이 순차 처리 코드로 변경하고 성능을 측정하였습니다.for await (const scale of snapshotScales) { await page .evaluate((scale) =&amp;gt; { const zoomElement = document.querySelector(&#39;.RendererScreen__Zoom&#39;) as HTMLElement; if (zoomElement) { zoomElement.style.setProperty(&#39;transform&#39;, `scale(${scale})`); } }, scale) .then(() =&amp;gt; page.waitForTimeout(10)) .then(() =&amp;gt; page.locator(&#39;.TemplateRendererLayer&#39;).screenshot({ type: &#39;jpeg&#39; })) .then((screenshot) =&amp;gt; screenshot.toString(&#39;base64&#39;)) .then((base64) =&amp;gt; base64 &amp;amp;&amp;amp; snapshots.jpg.push(base64)) .then(() =&amp;gt; page.locator(&#39;.TemplateRendererLayer&#39;).screenshot({ type: &#39;png&#39; })) .then((screenshot) =&amp;gt; screenshot.toString(&#39;base64&#39;)) .then((base64) =&amp;gt; base64 &amp;amp;&amp;amp; snapshots.png.push(base64));}병렬 처리 vs 순차 처리위에서 작성한 서버 코드를 사용하기 위해 다음과 같은 코드를 작성하고 실행하여 API 실행 전과 실행 완료 후 시간을 측정하여 그 둘을 서로 뺀 값으로 실행 시간을 측정하였습니다.const start = new Date().getTime(); // 코드 실행 시작 시간apiClient .axios .get(&#39;http://localhost:3000/api/snapshot&#39;, { params: { designId } }) .then((r) =&amp;gt; r.data) .then(({ snapshots: { jpg, png } }) =&amp;gt; { const end = new Date().getTime(); // 코드 실행 종료 시간 const gap = end - start; // 종료 시간에서 시작 시간을 뺀 실제 실행 시간 console.log(gap); // &amp;lt;-- 실행 시간 출력 jpg.map((url, key) =&amp;gt; { const anchor = document.createElement(&#39;a&#39;); anchor.href = `data:image/jpg;base64,${url}`; anchor.download = `url${key}.jpg`; anchor.click(); anchor.remove(); }); png.map((url, key) =&amp;gt; { const anchor = document.createElement(&#39;a&#39;); anchor.href = `data:image/png;base64,${url}`; anchor.download = `url${key}.png`; anchor.click(); anchor.remove(); }); });성능은 아래와 같이 나왔습니다.3000ms대의 결과가 병렬 처리를 이용한 방식이고, 2000ms 대의 결과가 순차 처리를 이용한 방식입니다.비동기 로직을 처리하는 대부분의 Case에서는 순차 처리가 병렬 처리보다 느리다는 것이 일반적이지만 페이지 인스턴스를 재사용하여 네트워크 요청을 최소화 하는 편이 이번과 같은 Case에서는 순차 처리 로직이 더욱 긍정적인 퍼포먼스를 발휘할 수도 있다는 것을 알게 되었습니다.마치며다만 이와 같은 Case에서는 무수한 환경적 요인이 작용합니다.스크린샷을 촬영하는 컴퓨터와 네트워크의 환경이 위의 테스트 환경보다 좋다면 Content Delivery 속도 또한 증가하여 본 문서와 다른 결과가 나올 수도 있기에 네트워크 속도가 느린 서비스 환경에서 참고한다면 성능 개선을 기대할 수 있겠지만 그렇지 않다면 오히려 성능 저하를 발생시킬 수도 있음을 유의해야 할 것 같습니다." }, { "title": "VSCode User Snippet 알아보기", "url": "/posts/vscode-snippets-custom/", "categories": "Tech, Talk", "tags": "vscode", "date": "2023-06-21 09:19:00 +0800", "snippet": "User Snippet?개발을 하다보면 비슷한 형식의 코드를 반복적으로 작성해야 할 때가 자주 있습니다.대표적으로 Redux의 Slice나 Hook과 같은 코드를 작성할 때 자주 이러한 상황이 펼쳐집니다.interface UseExampleArguments {}export const useExample = (args: UseExampleArguments) =&amp;gt; { };import { createSlice } from &#39;@reduxjs/toolkit&#39;;const initialState = {};export type AuthSliceState = typeof initialState;export const authSlice = createSlice({ name: &#39;AuthSlice&#39;, initialState, reducers: { }, extraReducers(builder) { },});명령어를 지정하여 자주 사용 되는 코드 형식을 불러오는 도구를 User Snippet이라고 합니다.어떻게 쓸까요?Mac의 경우 Shift + Command + p 를 누르면 VSCode의 다양한 기능들을 설정할 수 있는 메뉴가 표시 됩니다.여기서 User snippet 키워드로 검색하면 하나의 메뉴가 나오게 됩니다.이 메뉴를 클릭합니다.Snippet을 적용할 확장자를 선택해줍니다.확장자를 선택하면 아래와 같이 JSON 파일이 열리게 됩니다.{}우선 아래와 같이 작성 해봅시다.{ &quot;react hook&quot;: { &quot;prefix&quot;: &quot;rhook&quot;, &quot;body&quot;: [] }}우선 JSON의 각 key는 해당 코드 조각이 어떤 이름으로 불릴지 작성합니다.위 예시에서는 react hook이라는 이름의 코드 조각을 생성 한 것입니다.아래는 각 프로퍼티의 역할입니다. prefix: 이 코드 조각을 불러오기 위한 명령어를 설정합니다. 위 예시에서는 rhook이라고 입력하면 실행이 되는 형태입니다. body: 이 코드 조각을 실행 했을 때 파일에 작성 될 코드를 입력합니다. 코드는 배열로 저장하며, 배열의 각 아이템이 코드의 행이 됩니다.위에서 작성했던 useExample을 body에 삽입한다면 아래와 같은 형태가 됩니다.{ &quot;react hook&quot;: { &quot;prefix&quot;: &quot;rhook&quot;, &quot;body&quot;: [ &quot;interface UseExampleArguments {&quot;, &quot;}&quot;, &quot;&quot;, &quot;export const useExample = (args: UseExampleArguments) =&amp;gt; {&quot;, &quot;\\t&quot;, &quot;};&quot; ] }}이 Snippet을 저장하고 .ts 문서에서 rhook을 적고 엔터를 누르면 위에서 봤던 useExample이 빠르게 완성 됩니다.자리 표시자Snippet을 작성하면 기본적으로 마우스 커서가 해당 코드 조각의 가장 아래에 위치합니다.interface UseExampleArguments {}export const useExample = (args: UseExampleArguments) =&amp;gt; { }; // 커서는 여기에하지만 Snippet을 사용하는 대부분의 사람들은 아래와 같은 절차로 코드를 편집하게 됩니다. useExample을 내가 사용할 이름으로 변경하기 useExample 함수 내부에 코드 작성하기이렇게 하기 위해서는 마우스로 직접 해당 위치까지 커서를 이동해야 한다는 단점이 있습니다.Snippet은 코드 조각을 불러오고나면 커서를 어디에 맞춰야 하는지도 설정할 수 있습니다.{ &quot;react hook&quot;: { &quot;prefix&quot;: &quot;rhook&quot;, &quot;body&quot;: [ &quot;interface ${1:useExample}Arguments {&quot;, &quot;}&quot;, &quot;&quot;, &quot;export const ${1:useExample} = (args: ${1:UseExample}Arguments) =&amp;gt; {&quot;, &quot;\\t${2}&quot;, &quot;};&quot; ] }}위의 코드 조각에는 아까 전에는 없었던 ${1}과 ${2}가 추가 되었습니다. 이는 앞으로 ‘자리 표시자’라고 불립니다. ${n}: n번째로 커서를 위치 시킨다는 의미이며, 만약 동일한 번호가 연속해서 등장한다면 다중 선택이 됩니다. Tab을 통해 다음 인덱스에 포커싱을 할 수 있습니다. ${n:defaultValue}::defaultValue 옵션을 추가하여 해당 칸에 기본적으로 삽입 할 데이터를 설정할 수 있습니다.변수자리 표시자 기능을 활용하여 UseExample을 손쉽게 수정할 수 있게 되었습니다만 이름을 수정해야 하는 편집 과정이 여전히 번거롭습니다.Snippet에는 이러한 과정을 더욱 간편하게 바꿀 수 있는 변수들이 존재합니다.여기서는 자주 사용 되는 변수 몇 가지만 짚고 넘어가겠습니다.자세한 내용은 여기를 참고해주세요. TM_FILENAME: 확장자가 포함 된 현재 파일명입니다. TM_FILENAME_BASE 확장자가 제거 된 현재 파일명입니다. TM_SELECTED_TEXT: 현재 선택 된 텍스트입니다.만약 위와 같은 변수를 사용하여 usePost.ts 파일에 usePost라는 hook을 만들고자 한다면 아래와 같이 Snippet을 작성할 수 있습니다.{ &quot;react hook&quot;: { &quot;prefix&quot;: &quot;rhook&quot;, &quot;body&quot;: [ &quot;interface ${TM_FILENAME_BASE}Arguments {&quot;, &quot;}&quot;, &quot;&quot;, &quot;export const ${TM_FILENAME_BASE} = (args: ${TM_FILENAME_BASE}Arguments) =&amp;gt; {&quot;, &quot;\\t${2}&quot;, &quot;};&quot;, &quot;&quot; ] },}변수 변형처음에 비하면 많이 편해졌습니다만 아직 한 가지 불편한 점이 남아 있어요.interface와 args: type을 설정할 때는 UseExample이라는 PascalCase로 나타내고 함수명은 useExample이라는 camelCase로 나타내야 한다는 점인데요.변수 변형 기능을 사용하면 이러한 문제 역시도 해결이 가능합니다.{ &quot;react hook&quot;: { &quot;prefix&quot;: &quot;rhook&quot;, &quot;body&quot;: [ &quot;interface ${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/}Arguments {&quot;, &quot;}&quot;, &quot;&quot;, &quot;export const ${TM_FILENAME_BASE/(.*)/${1:/camelcase}/} = (args: ${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/}Arguments) =&amp;gt; {&quot;, &quot;\\t${2}&quot;, &quot;};&quot;, &quot;&quot; ] }}변수 변형의 규칙은 아래를 따릅니다.${TM_FILENAME/(.*)\\\\..+$/$1/} | | | | | | | |-&amp;gt; no options | | | | | |-&amp;gt; references the contents of the first | | capture group | | | |-&amp;gt; regex to capture everything before | the final `.suffix` | |-&amp;gt; resolves to the filename${text/regex/capture/option} 형태로 기술할 수 있습니다. text: 해당 변수에 삽입 될 데이터입니다. 위의 경우에서는 TM_FILENAME_BASE 변수입니다. regex: 텍스트를 편집하기 위한 규칙을 지정하는 정규표현식이 들어갑니다. (.*)는 모든 형태의 문자를 전부 선택한다는 의미입니다. capture: 위 정규표현식으로 캡처 된 그룹의 인덱스를 작성합니다. option: 지정된 인덱스를 편집하기 위한 규칙을 지정합니다.마치며주로 사용하는 Snippet 편집 규칙에 대해서 설명이 모두 끝났습니다!만약 Extension 개발 계획이 있으신 분들이라면 여기서 설명한 기능 외에도 정말 많은 기능이 있으니 공식 문서를 참조 해주시면 되겠습니다." }, { "title": "기술 블로그 살리기, TF부터 글 작성까지의 일대기", "url": "/posts/new-post-tech-blog-pixo/", "categories": "Life, Talk", "tags": "", "date": "2023-01-17 09:12:00 +0800", "snippet": "저는 개발을 참 좋아하는데 제가 소속한 조직의 문화를 개선하는 것도 그에 준할 정도로 좋아하는 편이예요.현재까지의 커리어를 전부 스타트업에 쏟아서 그런진 몰라도 “꼬우면 바꾸자” 라는 마인드가 내재 되어 있어서 그럴지도 모르겠네요 😀어쩌다가 기술 블로그를 시작했을까기술 블로그는 회사의 이미지를 바깥에 보여주고 구성원들의 기술 향상에도 도움을 주는 등 긍정적인 효과를 많이 얻을 수 있어서 우아한 형제들, 당근마켓, 요기요 등 이름만 들으면 알법한 회사부터 시작해서 그렇지 않은 회사까지 채택하고 있는 방법이에요.이전 직장에서도 기술 블로그를 도입하고자 노력했지만 만들기만 하고 관리가 되지 않는 상태로 실패했던 경험이 있어서 이 회사에서 만큼은 기술 블로그 문화를 정착시키고 싶었어요.기술 블로그 TF 참여대표님과 같이 점심을 먹을 기회가 있었는데 어쩌다보니 기술 블로그에 대한 얘기가 나왔고 회사 내부의 분위기를 외부에 알리는걸 좋아하시는 분이라 엄청 긍정적으로 생각하셨기에 실제로 행동에 옮기기로 했어요.픽소에서는 구성원 한 명이 생각한 아이디어가 다른 구성원의 니즈에 맞다면 TF를 구성할 수 있어요.기술 블로그 TF도 대표님의 니즈와 구성원들의 호응으로 쉽게 창설 될 수 있었고 1대 멤버로 참여하게 되었어요. (안타깝게도 첫 삽을 뜬건 제가 아니지만요 😅)TF 굴리기TF에서 한 일은 다음과 같아요. 운영 플랫폼 정하기 정기 회의 일정 정하기 TF가 종료 될 때 이루어야 할 목표 주제 선정운영 플랫폼 정하기TF를 진행하면서 알게 된건 이 회사에서 기술 블로그를 운영한게 이번이 처음이 아니라는거예요.회사 창립 초창기 때 기술 블로그 운영을 미디엄으로 시작했었으나 새 글이 올라오지 않고 방치 된 블로그가 있는 상태였거든요.겸사겸사 이 블로그도 살려보고자 기술 블로그 플랫폼은 미디엄으로 정했어요.정기 회의 일정 정하기지속적으로 트래킹하지 않으면 열정이 식음과 동시에 또 다시 방치 될 것이 뻔하니 정기 일정을 잡아서 미팅을 진행하기로 했어요.미팅 일정은 모두의 합의 하에 ‘화요일 오후 4시’로 정했습니다.TF가 종료 될 때 이루어야 할 목표TF 구성원 모두가 글을 하나 이상은 퍼블리싱 하는 것을 목표로 정했어요.공개 될 때 글이 한 개 밖에 없으면 블로그 자체가 외로워 보이기도 하고, 다른 구성원들의 참여를 독려하기 위해 앞장 서겠다는 목적인거죠.주제 선정다른 기술 블로그를 보니까 기술 블로그라고 해서 오로지 ‘기술’만을 작성하는 것은 아니더라구요.토스 기술 블로그우아한 형제들 기술 블로그이처럼 새로 런칭한 기능에 대해서 혹은 조직 내부에 있는 팀에 대한 소개 등을 작성하여 회사의 내부의 분위기와 장점을 널리 알리고 좋은 인재를 데려올 수 있도록 활용하고 있었어요.수많은 리서칭을 거쳐서 기술 블로그에 올라갈 게시물의 주제는 아래와 같이 정했어요.기술적인 것, 조직에 관한 모든 것너무 포괄적이죠?그런데 이게 맞아요. 기술 블로그의 본래 목적인 ‘기술의 전파’와 우리 조직을 자랑까지 하려면 이게 딱이거든요.이제 글을 써볼까?저는 기술 블로그 TF와 동시에 진행했던 스프린트인 로고샵 웹뷰를 주제로 글을 작성했어요.모바일 앱에 내장되어 돌아가는 웹은 몇 번 만들어도 참 어렵더라구요.그래서 개발 도중 겪었던 문제들과 웹뷰 페이지를 잘 만들기 위한 방법들을 주제로 작성하여 이후 많은 사람들이 같은 문제로 고생하지 않았으면 좋겠네요 🙏날 것 작성하기날 것 그 자체주제를 선정했으면 글을 작성합니다.블로그에 글을 올리기 전에 notion에 글을 작성하여 내부 구성원들의 가감없는 리뷰를 받아야 하거든요 😨날카로운 리뷰 받기고마운 리뷰들블로그에 글을 올리기 위해서는 게시물을 작성한 사람이 리뷰어 두 명을 선정하여 리뷰어들이 피드백을 남기고 이를 반영하는 절차가 필요해요.그런데 저는 분명 두 명만 등록 했는데 어느 순간부터 열 다섯분이나 들어와서 읽어주시고 피드백을 남겨주셨더라구요 😱많은 관심을 받아서 기분이 좋았습니다.게시물 올리기검토 및 수정이 완료 된 게시글은 미디엄에서 재작성 되어 draft 상태로 대기하게 됩니다.정기 업로드 날짜에 맞춰서 publish로 변경하면 게시물 퍼블리싱이 완료 됩니다!마치며드디어 올라간 게시글게시물을 퍼블리싱 한다는 최종 목적을 이뤄내고 1대 기술 블로그 TF가 끝이 났어요!본 문서는 최대한 간단하게 적는거라 TF에서 있었던 재밌는 일들을 알려드리지 못하는게 참 아쉬워요 😭TF를 마치며 드는 생각은 기술 블로그를 만들어보고 싶었던 저의 니즈와 구성원분들의 니즈가 맞아 떨어져서 정말 재밌게 하지 않았나 생각 돼요.물론 이를 유지하기 위해서는 끊임 없는 관심이 필요하겠지만 이제 시작인걸요!여러분들도 여기를 눌러서 한번 읽어 봐주시면 감사하겠습니다!" }, { "title": "SSR 환경에서의 React Query", "url": "/posts/react-query-ssr/", "categories": "Tech, React Query", "tags": "React, Next.js, React Query", "date": "2023-01-16 17:00:00 +0800", "snippet": "React Query는 서버와 클라이언트 사이에서 데이터를 관리하기 위한 좋은 라이브러리입니다.자세한 설명은 React Query 문서를 확인 해주세요.SSR 환경에서 사용하기React Query는 useQuery라는 hook을 이용하여 사용하는 점에서 알 수 있듯이 클라이언트 렌더링 때 데이터를 호출하고 관리하는 라이브러리입니다.그러다보니 웹 서버에 제일 처음 접속하여 수신 받는 HTML 문서에는 API 호출 이후에 렌더링 되는 데이터들이 전혀 존재하지 않습니다.이는 초기 로딩 속도 및 검색 엔진 최적화에서 그다지 바람직하지 않아요.이 문제를 해결하기 위해 React Query 공식 페이지에서 알려주는 솔루션에 대해서 소개합니다.Solution 1Next.js 환경에서 SSR을 구현하기 위한 보편적인 방법은 getStaticProps 함수 혹은 getServerSideProps를 사용하는 것입니다.export const getServerSideProps = () =&amp;gt; { const data = fetch(api).then((r) =&amp;gt; r.json()).then((r) =&amp;gt; r); return { props: { data, }, };};위 코드를 사용하면 api 라는 Endpoint에 데이터를 호출하여 SSR에서 데이터를 가져온 뒤, props 객체에 데이터를 담아 페이지 렌더링을 진행할 수 있습니다.const getData = () =&amp;gt; fetch(api).then((r) =&amp;gt; r.json()).then((r) =&amp;gt; r);export const IndexPage = (props) =&amp;gt; { const data = useQuery({ queryKey: [&#39;data&#39;], queryFn: getData, initialData: props.data, // 여기 중요! }); return ( &amp;lt;div&amp;gt; { data.isSuccess &amp;amp;&amp;amp; data } &amp;lt;/div&amp;gt; );};export const getServerSideProps = () =&amp;gt; { const data = getData(); return { props: { data, }, };};getServerSideProps에서 데이터를 호출한 뒤에 useQuery의 프로퍼티 중 하나인 initialData에 데이터를 전달하면 Next.js는 서버에서 불러온 데이터를 기반으로 HTML을 생성하여 기존의 문제점을 해결할 수 있습니다.Solution 2가급적 이 방법을 사용하시길 권장합니다.두 번째 방법은 dehydrate와 hydrate를 사용하는 방법입니다.export interface AppProps { dehydratedState: DehydratedState;};export const App = ({ Component, ...rest }: AppPropsWithLayout&amp;lt;AppProps&amp;gt;) =&amp;gt; { const Layout = Component.Layout || ((page) =&amp;gt; page); return ( &amp;lt;QueryClientProvider&amp;gt; &amp;lt;Hydrate state={rest.pageProps.dehydratedState}&amp;gt; { Component } &amp;lt;/Hydrate&amp;gt; &amp;lt;/QueryClientProvider&amp;gt; );};export default App;우선 /pages/_app.tsx 파일에 Hydrate Provider를 추가합니다.pageProps 객체에는 열린 페이지 컴포넌트에 할당 되는 props가 객체로 전달 되는데, 이 안에 dehydratedState 라는 값이 포함 될 예정입니다.dehydratedState를 Hydrate Provider에 전달합니다.import { QueryClient, dehydrate } from &#39;@tanstack/react-query&#39;;const getData = () =&amp;gt; fetch(api).then((r) =&amp;gt; r.json()).then((r) =&amp;gt; r);export const getServerSideProps = () =&amp;gt; { const queryClient = new QueryClient(); await queryClient.prefetchQuery({ queryKey: [&#39;data&#39;], queryFn: getData, }); return { props: { dehydratedState: dehydrate(queryClient), }, };};이후 데이터가 실제로 호출 되는 하위 페이지에서는 getServerSideProps 함수 내에서 QueryClient를 선언한 뒤 prefetchQuery 메소드를 사용하여 API를 호출합니다.prefetchQuery 메소드는 useQuery 메소드와 유사하지만 실제로 데이터를 반환하지는 않고 해당 API에서 넘어온 데이터를 캐싱하는 역할만 합니다.dehydratedState는 페이지 컴포넌트의 props에 할당 되어 _app.tsx 파일에서 pageProps 객체로 참조가 가능합니다.Dehydrate된 QueryClient를 Hydrate라는 컴포넌트가 CSR을 시작할 때 동일한 Query를 호출하는 부분을 찾아 initialData에 할당하는 역할을 수행합니다.import { QueryClient, dehydrate } from &#39;@tanstack/react-query&#39;;const getData = () =&amp;gt; fetch(api).then((r) =&amp;gt; r.json()).then((r) =&amp;gt; r);export const IndexPage = () =&amp;gt; { const data = useQuery({ queryKey: [&#39;data&#39;], queryFn: getData, }); return ( &amp;lt;div&amp;gt; { data.isSuccess &amp;amp;&amp;amp; data } &amp;lt;/div&amp;gt; );};export const getServerSideProps = () =&amp;gt; { const queryClient = new QueryClient(); await queryClient.prefetchQuery({ queryKey: [&#39;data&#39;], queryFn: getData, }); return { props: { dehydratedState: dehydrate(queryClient), }, };};그러면 위와 같이 initialData 없이 SSR 처리가 가능합니다.마치며SSR 환경에서의 개발을 진행하시다 보면 hydrate라는 용어를 굉장히 많이 접하실거예요.이 상황에서 말하는 hydrate는 대부분 ‘서버에서 만들어진 데이터를 클라이언트에서 활용할 수 있도록 동기화 시켜주는 작업’이라고 생각하시면 될 것 같습니다.이에 대해 작성했던 문서가 있으니 한 번 쯤 읽어주시면 좋을 것 같습니다." }, { "title": "도형의 각도를 회전하는 방법", "url": "/posts/rotate-objects/", "categories": "Tech, Talk", "tags": "React, Next.js, Talk", "date": "2023-01-16 17:00:00 +0800", "snippet": "들어가며이미지 편집 서비스 Canva다중 오브젝트를 한 번에 회전 시키려고 하면 오브젝트의 각도와 위치가 동시에 변경 됩니다.본 문서에서는 위 기능을 구현하는 방법에 대해 기술합니다.회전 각도 구하기우선 두 점 사이의 각도를 구하는 함수에 대해 정의 합니다.interface Point { x: number; y: number;}const getAngleTwoPoints = (p1: Point, p2: Point) =&amp;gt; { const { x: _x, y: _y } = p1; const { x: __x, y: __y } = p2; const degree = Math.atan2(__y - _y, __x - _x) * 180 / Math.PI; return degree;};x와 y의 number 값을 가지고 있는 interface인 Point를 정의하고 매개변수로 두 개의 Point를 전달 받습니다.전달 받은 두 점의 좌표를 이용하여 degree 값을 추출하려면 Math.atan2(y2 - y1, x2- x1) * 180 / Math.PI 공식을 사용하여 계산하면 됩니다.Javascript로 회전 구현하기우리가 만들 프로젝트에서 오브젝트를 회전 시키기 위한 스토리라인을 생각해봅시다. 사용자는 오브젝트를 선택한다. 오브젝트를 회전 시킬 수 있는 UI가 나타난다. 위에서 말하는 UI란 둥근 버튼을 말하며, 이를 누른 다음 마우스를 움직이면 원하는 방향으로 오브젝트가 회전한다.아마 대부분의 편집 서비스에서 회전 기능을 이런 식으로 구현할 것이라고 생각 됩니다.우리에게는 이미 편집 가능한 오브젝트와 이를 회전 시킬 수 있는 UI가 구현 된 상태라고 가정합니다.좌표 변수 정의하기우리는 편집을 진행할 때 세 가지의 좌표 변수를 사용할 예정입니다.const startPoint = useRef&amp;lt;Point&amp;gt;();const movedPoint = useRef&amp;lt;Point&amp;gt;();const originPoint = useRef&amp;lt;Point&amp;gt;();const startAngle = useRef&amp;lt;number&amp;gt;(0);startPoint는 마우스를 누른 시점에 확보한 마우스의 좌표입니다.movedPoint는 마우스를 누른 상태에서 이동 하면서 지속적으로 변경 되는 마우스의 좌표입니다.originPoint는 내가 선택한 오브젝트들이 위치 된 좌표 지점을 기준으로 정확히 가운데를 지칭하는 x와 y값으로 구성 된 좌표입니다.startAngle은 회전을 시작할 때 originPoint의 회전각을 구해서 저장합니다.회전 시작하기회전을 시작한다는 것은 사용자가 둥근 버튼에 마우스를 올리고 버튼을 누른 시점을 의미합니다.const startRotate: React.MouseEventHandler&amp;lt;SVGCircleElement&amp;gt; = (event) =&amp;gt; { const x = event.clientX; const y = event.clientY; const point = { x, y }; startPoint.current = point; movedPoint.current = point; originPoint.current = getOriginPoint(...); startAngle.current = getAngleTwoPoints(originPoint.current, startPoint.current);};위 함수를 mousedown 이벤트의 콜백 함수로 사용하면 x, y 좌표 값을 얻을 수 있습니다.얻어낸 좌표 값을 startPoint와 movedPoint 에 할당 합니다.originPoint는 내가 선택한 모든 오브젝트들이 차지하는 좌표 범위를 하나의 큰 사각형으로 생각하고 해당 사각형의 가로와 세로 길이를 이등분하여 Point 객체로 만든 좌표 값입니다.다시 말해, 위 빨간 동그라미 영역의 좌표가 originPoint 가 되는 겁니다.회전 진행하기마우스가 눌리는 이벤트를 통해 좌표 값을 전달 받고 저장 했으니 이제는 마우스 이동 이벤트를 이용하여 이동 각도를 계산하고 실제로 회전을 해보겠습니다.const rotating = (event: MouseEvent) =&amp;gt; { const x = event.clientX; const y = event.clientY; const point = { x, y }; movedPoint.current = point; const angle = getAngleTwoPoints(originPoint.current, movedPoint.current) - startAngle.current; };위 함수를 mousemove 이벤트의 콜백 함수로 할당합니다.마우스가 이동 할 때마다 현재 마우스의 좌표를 받아오고, 위와 같은 원리로 각도를 불러올 수 있습니다.회전을 시작할 때 startAngle을 저장하여 현 시점에 활용하는 이유는, event.clientX와 event.clientY의 경우 마우스가 회전 버튼을 눌렀을 때 회전 버튼이 위치한 좌표를 뽑아오는게 아니라 내가 누른 화면의 좌표 정보를 받아오는 것이기 때문에 버튼의 왼쪽 상단을 눌렀을 때와 우측 하단을 눌렀을 때의 각도 차이가 생기게 됩니다.이를 방지하기 위해 회전을 시작 할 때의 각도를 미리 구해서 회전 시 제거하면 초기 값을 0도로 초기화 할 수 있습니다.위 방식을 통해 구한 각도를 사용하여 각 오브젝트가 기존에 갖고 있었던 각도 값에서 새로 구해진 각도를 더하면 오브젝트의 각도 회전을 구현할 수 있습니다.오브젝트 이동 시키기회전은 상대적으로 간단하게 진행 되었는데, 가장 중요한건 중심점을 기준으로 위치가 회전하도록 구현해야 한다는 것입니다.이 기능을 구현하기 위해서는 어떤 좌표에 찍힌 꼭짓점이 중심축을 기준으로 회전 했을 때 어디로 이동하게 되는 지 알아야 할 필요가 있어요.위 공식을 사용하면 이동 된 x’와 y’를 구할 수 있습니다.const left = (x - p) * Math.cos(radian) - (y - q) * Math.sin(radian) + p;const top = (x - p) * Math.sin(radian) + (y - q) * Math.cos(radian) + q;소스코드로 표현하면 위 처럼 나타낼 수 있습니다.공식에 대입 할 x와 y는 오브젝트가 위치할 좌표인데, 이 점은 각 오브젝트가 가진 각도값에 영향을 받아서는 안 되기에 중심점을 사용해야 합니다.p와 q는 회전축의 x, y 좌표입니다.주의할 점은 Math.cos와 Math.sin 함수에 들어갈 각도는 Degree 값이 아닌 Radian 값이기 때문에 한 번 변환이 필요합니다.const degree2Radian = (degree: number) =&amp;gt; { return Math.PI * degree / 180;};위 함수를 사용하면 Degree 값을 Radian으로 변환 할 수 있습니다.마치며위 과정을 통해 회전각과 이동할 좌표를 구했으니 실제 오브젝트에 반영을 하면 아래와 같은 회전 기능을 만들 수 있습니다." }, { "title": "Git 원치 않는 파일 제거하기", "url": "/posts/remove-git-file/", "categories": "Tech, Git", "tags": "", "date": "2023-01-09 17:21:00 +0800", "snippet": "들어가며가끔 .env 파일이나 개발 내용과는 전혀 상관 없는 이미지 파일, 개인적인 자료들이 실수로 Git 히스토리에 커밋 되어 원격에 올라가는 경우가 있습니다.로컬에서 파일을 삭제하고 커밋을 할 경우 최신 이력에서는 삭제 되지만 히스토리를 살펴보면 파일 조회가 가능하기에 보안상 심각한 이슈를 낳을 수 있어요.git filter-branch --force --index-filter &quot;git rm --cached --ignore-unmatch 파일명&quot; --prune-empty --tag-name-filter cat -- --allgit add *git commit -m &quot;커밋 메시지&quot;git push origin master --force위 명령어를 입력하시면 해당 파일과 관련 된 모든 커밋 내역이 원격에서도 제거 되어 해당 파일을 조회 할 수 있는 방법이 사라지게 됩니다.레퍼런스원격 저장소에서 원하는 파일 기록까지 모두 제거 하는 방법" }, { "title": "Safari SVG Blurry 현상 해결 방법", "url": "/posts/safari-svg-blurry/", "categories": "Tech, Talk", "tags": "SVG, Safari", "date": "2022-12-13 14:47:00 +0800", "snippet": "들어가며회사에서 서비스 되는 앱에서 사용할 WebView 페이지를 작업하던 중 발견한 이슈입니다.iOS 앱에서 WebView 페이지를 접속하면 SVG로 추출한 이미지인데도 불구하고 화질 저하가 일어난다는 기묘한 이슈였습니다.구글에 Safari SVG 화질 저하에 대해 검색해보니 꽤 오래 전부터 이 이슈에 대해 논의 되고 있었다는 것을 알 수 있었습니다.화질 저하가 얼마나 심한지 알아보시려면 이 페이지에 Chrome과 Safari 각각 접속하셔서 화질 차이를 보신다면 바로 아실 수 있을거예요.해결 방법SVG 파일을 &amp;lt;img /&amp;gt; 태그가 아니라 &amp;lt;object /&amp;gt; 태그로 호출하면 해결 됩니다.&amp;lt;object data=&quot;/image.svg&quot;&amp;gt;&amp;lt;/object&amp;gt;" }, { "title": "원활한 협업을 위한 .nvmrc", "url": "/posts/nvmrc/", "categories": "Tech, Talk", "tags": "nvmrc", "date": "2022-12-07 00:00:00 +0800", "snippet": "nvmrc.nvmrc 파일이란, 프로젝트 구동을 위한 Node의 버전을 기록할 수 있는 파일을 말합니다.NodeJS 프로젝트에서 타인이 만든 프로젝트를 구동할 때 버전 문제가 발생해서 실행을 못한다거나, 일부 라이브러리를 사용하지 못했던 경험이 한 번 쯤은 있을텐데요.README.md 파일에 버전명을 적어두는 것 보다 협업 대상자가 명령어 한 줄로 Version Sync를 가능하게 만드는게 훨씬 더 용이하겠죠?작성 방법 프로젝트 최상단에 .nvmrc 파일을 생성합니다. 해당 .nvmrc 파일에 버전명을 기재합니다. v18.7.0 사용 방법해당 버전이 설치 되어있지 않은 경우nvm install위 명령어를 입력하면 .nvmrc를 읽어서 기재 된 버전을 설치합니다.해당 버전으로 변경nvm use위 명령어를 입력하면 .nvmrc를 읽어서 해당 버전으로 변경합니다." }, { "title": "내가 주로 쓰는 Next.js ESLint 설정", "url": "/posts/nextjs-eslint/", "categories": "Tech, Next.js", "tags": "Next.js, ESLint", "date": "2022-11-18 08:58:00 +0800", "snippet": "Package 설치더욱 정교한 Formatting을 위해 플러그인을 설치합니다.yarn add -D eslint-plugin-simple-import-sort eslint-plugin-unused-imports# ornpm install -D eslint-plugin-simple-import-sort eslint-plugin-unused-importseslint-plugin-simple-import-sortimport한 Package를 알파벳 순서대로 Sorting 하고, 절대경로로 import 된 그룹과 상대경로로 import 된 그룹을 자동으로 분리시켜 줍니다.import React from &quot;react&quot;;import Button from &quot;../Button&quot;;import styles from &quot;./styles.css&quot;;import type { User } from &quot;../../types&quot;;import { getUser } from &quot;../../api&quot;;import PropTypes from &quot;prop-types&quot;;import classnames from &quot;classnames&quot;;import { truncate, formatNumber } from &quot;../../utils&quot;;⬇️import classnames from &quot;classnames&quot;;import PropTypes from &quot;prop-types&quot;;import React from &quot;react&quot;;import { getUser } from &quot;../../api&quot;;import type { User } from &quot;../../types&quot;;import { formatNumber, truncate } from &quot;../../utils&quot;;import Button from &quot;../Button&quot;;import styles from &quot;./styles.css&quot;;eslint-plugin-unused-importsimport한 Package를 실제로 사용하지 않았을 때 해당 Package의 Import 구문을 자동으로 제거해줍니다.import React from &#39;react&#39;import _ from &#39;lodash&#39;;export const App = React.Memo(() =&amp;gt; { return ( &amp;lt;div className=&quot;App&quot;&amp;gt;&amp;lt;/div&amp;gt; ));}⬇️import React from &#39;react&#39;export const App = React.Memo(() =&amp;gt; { return ( &amp;lt;div className=&quot;App&quot;&amp;gt;&amp;lt;/div&amp;gt; ));}ESLint 규칙 작성{ &quot;extends&quot;: &quot;next&quot;, &quot;plugins&quot;: [ &quot;eslint-plugin-simple-import-sort&quot;, &quot;unused-imports&quot; ], &quot;rules&quot;: { &quot;react/no-unescaped-entities&quot;: &quot;off&quot;, &quot;@next/next/no-page-custom-font&quot;: &quot;off&quot;, &quot;react/self-closing-comp&quot;: [&quot;error&quot;, { &quot;component&quot;: true, &quot;html&quot;: true }], &quot;react/jsx-first-prop-new-line&quot;: &quot;error&quot;, &quot;comma-dangle&quot;: [&quot;error&quot;, { &quot;arrays&quot;: &quot;always-multiline&quot;, &quot;objects&quot;: &quot;always-multiline&quot;, &quot;imports&quot;: &quot;never&quot;, &quot;exports&quot;: &quot;never&quot;, &quot;functions&quot;: &quot;never&quot; }], &quot;indent&quot;: [&quot;error&quot;, 2], &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;], &quot;eol-last&quot;: &quot;error&quot;, &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;simple-import-sort/imports&quot;: &quot;error&quot;, &quot;simple-import-sort/exports&quot;: &quot;error&quot;, &quot;no-unused-vars&quot;: [&quot;error&quot;, { &quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;none&quot;, &quot;ignoreRestSiblings&quot;: false }], &quot;unused-imports/no-unused-imports-ts&quot;: [&quot;error&quot;], &quot;comma-spacing&quot;: [&quot;error&quot;, { &quot;before&quot;: false, &quot;after&quot;: true }] }}" }, { "title": "기술 블로그에 Giscus를 추가했습니다!", "url": "/posts/add-giscus/", "categories": "Tech, Talk", "tags": "Giscus", "date": "2022-11-10 13:56:00 +0800", "snippet": "개요기술 블로그를 Github Pages로 이전하면서 정적인 웹사이트로 바뀐 이후, 기술 블로그에 방문하는 분들의 리액션을 알 수 있는 창구가 필요해졌습니다.그래서 지난번에 게시물 하단에 applause-button를 추가했었죠.가장 큰 호응을 얻고 있는 Pinia 게시글하지만 박수 횟수로는 방문자들의 니즈를 알 수가 없다는 문제가 있습니다.이 문제를 해결할 수 있는 가장 좋은 방법은 ‘댓글’을 이용하는 것인데, 기술 블로그에 추가할 수 있는 확장 프로그램이 있다는 것은 알고 있었지만 여태까지 설치를 미루다가 이제야 추가하게 되었습니다.드디어 추가한 댓글 확장 프로그램Extensions정적 웹사이트에 댓글을 추가하기 위해 사람들이 가장 많이 사용하는 확장 서비스는 총 세 가지가 있습니다. Disqus Utterances Giscus여기서 가장 유명한 서비스는 Disqus인데, 간단한 기술 블로그에 설치하기에는 너무 거창한 기능들이 많아서 후보군에서 제외하게 되었습니다.그래서 Utterances와 Giscus 둘 중 하나를 골라서 사용해야 하는 상황이였는데, 최종적으로 Giscus를 결정하게 되었습니다.Utterances vs GiscusUtterances와 Giscus는 둘 다 Github API를 사용하여 댓글을 저장한다는 공통점이 있습니다.Github의 Repository에 댓글을 저장하여 API로 불러와서 사용하는 형태예요.두 서비스의 가장 큰 차이점은 Utterances는 Issue를, Giscus는 Discussions를 사용한다는 점입니다.개인적으로 댓글을 저장하기 위한 저장소로 사용하기에 Issue는 맞지가 않는 것 같아 Giscus의 철학을 따르게 되었습니다.Giscus 앱 설치 giscus 앱을 ‘댓글을 저장할 Repository’에 설치해주세요.Discussions 활성화 Repository의 설정 페이지로 들어갑니다. ‘Features’ 섹션에서 Discussions를 활성화합니다.Giscus를 내 블로그에 추가 Giscus 설정 페이지로 들어갑니다. [설정] 섹션에서 댓글을 저장할 나의 레포지토리 이름을 입력합니다. 페이지와 Discussions를 연결할 방법을 선택합니다. (Github API에서 댓글을 조회할 수 있는 방법을 결정하는거예요.) Giscus를 이용하여 게시글에 댓글을 달면 Discussion을 생성하고 댓글이 달리는데, 해당 Discussion에 사용 될 카테고리를 선택합니다. 추가 기능을 선택합니다. 적용하실 테마를 선택해주세요. 생성 된 script 태그를 웹 페이지에 추가해주세요. 댓글창을 띄우고 싶은 위치에 giscus 클래스를 가진 Element를 배치해주세요. 스크립트가 활성화 되면서 댓글창으로 변환됩니다.마치며블로그를 방문해주시는 분들은 정말 많은데 박수 말고 다른 의견을 들을 수 있는 창구를 이제야 만들게 되었네요 😅본문 내용에 문제가 있거나, 추가로 궁금하신 내용이 있으시다면 댓글 기능을 이용해주세요!" }, { "title": "소스코드의 퍼포먼스를 벤치마킹하는 방법", "url": "/posts/benchmark-your-code/", "categories": "Tech, Talk", "tags": "Benchmark, Javascript", "date": "2022-11-09 15:58:00 +0800", "snippet": "개요프로젝트를 진행하다보면 하나의 Feature를 해결하기 위한 다양한 방법들을 마주할 때가 많아요.예를 들어, 특정 Element를 복제하고 싶을 때 사용할 수 있는 API는 크게 createElement와 cloneNode가 있습니다.둘 중 어떤걸 써도 문제의 해결은 가능하지만 가급적 좋은 길을 선택하고자 할 때, 어떤 API가 보다 좋은 성능을 내는지를 측정하고 싶을 수 있습니다.MeasureThat소스코드 Benchmark 사이트MeasureThat에서 직접 소스코드를 작성하고 실행하여 두 코드 사이의 Performance를 측정할 수 있습니다.사용법시작 페이지에서 [+ New benchmark] 버튼을 클릭하시면 위 사진과 같은 페이지가 등장합니다.이 페이지에서 코드를 작성하고 테스트 케이스를 추가하는 등의 작업을 진행하실 수 있습니다.위와 같이 코드를 입력하고 Benchmark를 실행하면Benchmark위 사진처럼 두 코드간 Performance를 비교할 수 있습니다.동일한 div를 10만번 생성한다고 가정했을 때, cloneNode보다 createElement가 상대적으로 적은 비용을 지출한다는 사실을 알게 되었네요!" }, { "title": "Nextjs에서 React Portal 사용해보기", "url": "/posts/nextjs-portal/", "categories": "Tech, Next.js", "tags": "Next.js, React, Portal", "date": "2022-11-03 09:53:00 +0800", "snippet": "React Portal웹을 제작하다보면 대부분의 경우 계층 구조로 컴포넌트를 배치하여 렌더링하는 방식으로 문제를 해결할 수 있습니다.그런데 간혹 n레벨에 배치 되어야 하는 컴포넌트가 실제로 렌더링 될 때는 Document의 최상단에 배치하고 싶을 수 있습니다.TooltipModalTooltip이나 Modal 컴포넌트가 바로 그 대표적인 예시입니다.위 두 개의 컴포넌트는 웹 페이지에 존재하는 어떤 요소보다 위에 존재해야 하기 때문에 &amp;lt;body&amp;gt; 태그의 바로 하단으로 옮겨줄 필요가 있습니다.이런 상황에 간단하게 사용할 수 있는 방법이 바로 ReactDOM.createPortal() API입니다.ReactDOM.createPortalconst Modal = (props: ModalProps) =&amp;gt; { const Component = React.createComponent(&#39;div&#39;, { ...props }, props.children); const portal = ReactDOM.createPortal(Component, document.body); return Portal};const App = () =&amp;gt; { return ( &amp;lt;Modal /&amp;gt; );}ReactDOM.createPortal은 두 개의 인자를 받습니다.첫번째 인자는 ReactNode, 즉 배치하고 싶은 컴포넌트를 넘겨주시면 됩니다.두번째 인자는 첫번째 인자에서 넘겨준 ReactNode를 배치하고 싶은 Element를 넘겨주시면 됩니다.Next정말 사용하기 쉬운 API지만 Next에서 사용할 때 한가지 문제가 있습니다.const Modal = (props: ModalProps) =&amp;gt; { const Component = React.createComponent(&#39;div&#39;, { ...props }, props.children); const portal = ReactDOM.createPortal(Component, document.body); return Portal};위 코드를 Next.js에서 사용하면 아래와 같은 이슈가 표시될 것입니다. document is not definedNext는 별도의 설정을 하지 않는다면 SSR / CSR을 동시에 진행하기 때문에 SSR 과정에서 document를 탐색할 수 없기 때문입니다.그렇다면 아래와 같이 코드를 수정해봅시다.const Modal = (props: ModalProps) =&amp;gt; { if (typeof window === &#39;undefined&#39;) return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;; const Component = React.createComponent(&#39;div&#39;, { ...props }, props.children); const portal = ReactDOM.createPortal(Component, document.body); return Portal};CSR 과정에서는 window 객체가 생성될 터이니 window 객체가 없다면 렌더링을 진행하지 않는 로직이 추가되었습니다.이러면 별 문제가 없어보이지만 아래와 같은 메시지가 나오면서 Hydration 이슈가 발생합니다. Hydration failed because the initial UI does not match what was rendered on the serverHydrationHydration의 상세한 내용은 이 문서를 참고해주세요!문제점만 간단하게 요약하자면 SSR에서 생성한 정적 페이지와 CSR에서 초기에 읽어낸 웹페이지의 코드가 서로 상이하여 생기는 문제입니다.해결 방법const Modal = (props: ModalProps) =&amp;gt; { const [isCSR, setIsCSR] = useState&amp;lt;boolean&amp;gt;(false); useEffect(() =&amp;gt; { setIsCSR(true); }, []) if (typeof window === &#39;undefined&#39;) return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;; if (!isCSR) return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;; const Component = React.createComponent(&#39;div&#39;, { ...props }, props.children); const portal = ReactDOM.createPortal(Component, document.body); return Portal};isCSR state를 생성하고, useEffect Hook으로 isCSR을 수정하여 isCSR이 true일 때 렌더링을 진행하면 Hydration 문제가 해결됩니다.레퍼런스[Next.js] Hydration failed because the initial UI does not match what was rendered on the server 에러" }, { "title": "Nextjs의 hydration이란?", "url": "/posts/nextjs-hydration/", "categories": "Tech, Next.js", "tags": "Next.js, React, Hydration", "date": "2022-11-03 09:53:00 +0800", "snippet": "HydrationHydration을 검색하면 나오는 이미지Hydration은 위 이미지처럼 ‘수분 공급’을 의미합니다.Hydration을 이해하기 전에 CSR, SSR이 무엇인지 간단하게 짚고 넘어가야 합니다.CSRClient Side Rendering의 약자입니다.Web은 단순히 홈페이지라는 개념을 넘어서 응용프로그램의 영역을 대체한지 오래입니다.사용자의 Interaction을 감지하고 Feedback을 전달하기에 기존의 정적인 웹은 애로사항이 많았습니다.CSR을 도입하면서 페이지가 이동할 때 아름다운 애니메이션을 보여주는게 가능해졌고, 이전 페이지에서 불러왔던 리소스를 다음 페이지로 이동할 때 재호출을 하지 않아도 된다는 점에서 트래픽을 아낄 수 있다는 장점도 생겨났어요.하지만 기존 웹에서는 생각치도 못했던 단점이 생겨나기 시작했습니다. 느린 초기로딩 속도 기존의 HTML, CSS, Javascript는 웹사이트를 구동하기 위한 최소한의 다운로드만 진행하면 됐었습니다. 하지만 CSR이 도입되면서 CSR을 구현해줄 라이브러리도 함께 사용하다보니 웹에 접속하는 모든 사람이 React나 Vue와 같은 라이브러리를 같이 다운로드 해야만 합니다. 검색엔진 최적화 CSR은 말 그대로 홈페이지 접속 이후 Javascript가 DOM을 생성하거나 교체하는 등의 작업을 통해 웹을 구현하는 것을 말합니다. 검색엔진들은 웹을 탐색하면서 읽어낸 HTML을 토대로 해당 웹사이트의 요소들을 파악하지만 CSR은 크롤러가 웹을 읽는 타이밍에 HTML을 생성하지 못하므로 페이지 색인에 문제가 생깁니다. 이 문제들을 해결하기 위해 도입된 개념이 SSR입니다.SSRServer Side Rendering의 약자입니다.말 그대로 서버에서 HTML 및 CSS 등을 생성하여 사용자에게 제공하는 것을 말합니다.SSR의 장점은 다음과 같습니다. 빠른 초기로딩 속도 웹서비스가 호스팅 되는 곳과 물리적으로 가까운 컴퓨터에서 HTML, CSS에 대한 구성을 끝내므로 반응속도가 상대적으로 빠릅니다. Javascript가 HTML을 생성하기 전에도 이미 만들어진 HTML을 보여줄 수 있으므로 사용자로 하여금 더 빠른 반응속도를 체감하게 해줍니다. 검색엔진 최적화 서버에서 HTML을 생성하고 제공하므로 검색엔진 최적화에 대한 문제점이 없어집니다. 본론으로 돌아와서하지만 Server Side Rendering은 한가지 치명적인 문제가 있는데, HTML을 그려줄 수는 있어도 실제로 브라우저가 렌더링 한 것이 아니기 때문에 Javascript의 코드를 DOMElement와 매칭시켜서 동적인 페이지를 구현하지는 못한다는 것입니다.그래서 SSR로 인해 렌더링 된 HTML 페이지는 뼈대만 존재하는 바싹 마른 형태로 존재하게 되는데 이렇게 건조한 웹 페이지에 수분 공급을 해줄 필요가 있습니다.이 작업을 Hydration이라고 합니다.요약하자면 본 문서의 핵심 내용은 다음과 같습니다. CSR은 동적인 웹사이트를 만들 수 있어서 좋아요. 하지만 초기로딩이 느리고 검색엔진에 잘 잡히지 않을 수 있어요. SSR은 초기로딩이 빠르고 검색엔진에도 잘 잡혀서 사용자 유입에서 이점을 가져올 수 있어요. Next.js는 SSR과 CSR을 병행해서 사용합니다. SSR에서 만든 페이지는 다 좋은데 Javascript의 동적인 이벤트들을 Element에 할당하지 못해요. 그렇기 때문에 SSR에서 만들어진 매마른 페이지에 동적 이벤트라는 수분 공급을 해주는 과정을 Hydration이라고 합니다.레퍼런스React의 Hydration에 대하여" }, { "title": "Element가 서로 같은지 비교하기", "url": "/posts/compare-elements/", "categories": "Tech, Javascript", "tags": "비교, Element, Javascript", "date": "2022-10-28 08:56:00 +0800", "snippet": "개요실제로 웹을 개발하다보면 DOM Element를 직접 핸들링 해야하는 일이 은근히 생깁니다.그럴 때, 내가 선택한 Element와 어떤 Element가 서로 동일한 Element인지 비교를 하고 싶을 때가 있는데, Javascript에서는 다행히도 isEqualNode와 isSameNode Method를 지원합니다.사용해보기코드const element1 = document.createElement(&#39;div&#39;);const element2 = document.createElement(&#39;div&#39;);const element3 = document.createElement(&#39;p&#39;);const element4 = element1;console.log( element1.isEqualNode(element2)); // trueconsole.log( element1.isSameNode(element2)); // falseconsole.log( element3.isEqualNode(element3)); // falseconsole.log( element1.isSameNode(element4)); // trueisEqualNodeisEqualNode는 A Element와 B Element가 서로 같은 성질을 가지고 있는지 판단합니다.여기서 같은 성질이란, 태그의 이름이나 속성, 하위에 존재하는 자식들이 동일한지에 따라 판단하게 됩니다.물론 자식을 보유할 수 없는 태그도 있고, 태그마다 허용하는 속성이 모두 다 다르니 노드의 유형에 따라 달라진다고 합니다. The specific set of data points that must match varies depending on the types of the nodes.isSameNodeisSameNode는 A Element와 B Element가 완전히 동일한 대상을 지칭하는지 확인합니다.단순히 태그 이름이 같을 뿐 아니라, Element의 UniqueID를 비교하여 아예 동일한 대상이라면 true를 반환합니다.레퍼런스Stackoverflow - Is there a way to check if two DOM elements are equal?" }, { "title": "React Query로 관리하는 효율적인 서버 데이터 핸들링", "url": "/posts/react-query-tutorial/", "categories": "Tech, React Query", "tags": "React, React Query", "date": "2022-10-25 23:54:00 +0800", "snippet": "React QueryReact Query는 네트워크에서 받아온 데이터를 관리하기 위해 처리해야 하는 다양하고 번거로운 절차들을 대신 처리해주는 라이브러리입니다.React Querynpm 다운로드 횟수주간 다운로드 횟수가 백만 회를 넘어갈 정도로 인기가 많은 라이브러리인데, 서버 데이터에 대해 어떤 문제점이 있길래 이렇게나 많은 호응을 얻을 수 있었을까요?사용해야 하는 이유중복 된 네트워크 호출 방지 User의 데이터를 호출하는 useUser 라는 Hook이 존재합니다. useUser라는 Hook을 사용하는 컴포넌트가 존재합니다. 동일한 페이지에 해당 컴포넌트가 여러 번 호출 되었습니다.이런 경우에는 어떻게 될까요? 동일한 데이터이기에 한번 호출했던 데이터를 계속해서 사용하는게 Best겠지만, 그런 부분들은 뒤로 미뤄두고 위 경우만 봤을 때는 사용 된 컴포넌트의 갯수에 비례하여 네트워크 호출 횟수가 증가하게 될 것 입니다.React Query는 중복 된 API 호출을 Query Key를 이용하여 구분하고 중복되는 요청에 대해서는 캐시에 저장해 둔 데이터를 활용하여 네트워크 요청을 최소화합니다.신선하지 않은(Stale) 데이터 처리‘신선하지 않은 데이터’란 실제 서버에서 갖고 있는 데이터와 클라이언트가 갖고 있는 데이터가 서로 일치하지 않을 가능성이 존재하는 데이터를 의미합니다.사용자가 서비스에 접속한 이후 아무 행동도 하지 않고 서비스를 방치하는 경우, 아무런 데이터 갱신도 이루어지지 않게 되기에 사용자에게 옳지 않은 데이터를 보여 줄 가능성이 있습니다.React Query는 이러한 상황에 대비해서 브라우저나 특정 Element에 포커스가 맞춰지면 API를 호출하거나, 일정 시간이 지난 뒤에는 데이터가 상했을 것이라 추측하고 다시 요청하는 등 다양한 방법을 이용해서 데이터를 갱신합니다.데이터 처리 상황 표시서버로부터 데이터를 불러오는 과정에서 로딩을 표시하거나, 에러가 발생한 경우 에러 메시지를 표시해야 하는 경우가 자주 있습니다.원래라면 이 모든 것을 별도의 상태를 작성하고 try catch 등을 이용하여 수동적으로 갱신해야 했지만, 이를 대신 처리해줍니다.무한 스크롤 구현Infinite Scroll 출처: https://uxdesign.cc/the-infinite-scroll-effect-how-design-can-hack-your-brain-996a9b8129d9아마 UX 개발자가 아니더라도 ‘무한 스크롤’에 대해서는 다들 아실거라고 생각합니다.무한 스크롤을 라이브러리의 도움을 받지 않고 구현한다면, 데이터 저장을 위한 상태, 페이지 저장을 위한 상태, 예외 처리를 위한 상태 등 간단한 기능에 비해 꽤나 복잡하고 수고스러운 과정이 필요합니다.React Query는 무한 스크롤의 손쉬운 구현을 위해 useInfiniteQuery Hook을 지원합니다. 페이지 정보에 대한 관리 로딩 상태 관리 데이터 관리 다음 페이지 호출 진행 여부에 대한 관리위 번거로운 과정들을 각각의 상태로 자동으로 만들어주기 때문에 UI 구현에만 집중할 수 있습니다.그 외 네트워크가 유실 되었다가 연결되면 자동으로 API를 다시 호출해줍니다. 네트워크 요청이 모종의 이유로 한 번 끊길 경우를 대비하여 재시도 횟수를 설정할 수 있습니다.위와 같이 직접 구현하기에는 정말 매우 번거로울 것 같지만 반드시 필요한 기능들을 처리해주는 라이브러리라고 이해해주시면 될 것 같습니다.시작해보기 본문에서는 바닐라 React Query가 아닌 @tanstack/react-query를 사용합니다.설치npm i -S @tanstack/react-query# oryarn add @tanstack/react-queryContext 설정import { useQuery, useMutation, useQueryClient, QueryClient, QueryClientProvider,} from &#39;@tanstack/react-query&#39;;// Create a clientconst queryClient = new QueryClient();function App() { return ( // Provide the client to your App &amp;lt;QueryClientProvider client={queryClient}&amp;gt; &amp;lt;Todos /&amp;gt; &amp;lt;/QueryClientProvider&amp;gt; )}대부분의 React 라이브러리가 그렇듯 서비스의 최상단에 Context를 래핑해줘야 합니다.래핑을 하셨다면 이제 하위 모든 페이지 혹은 컴포넌트에서 React Query의 다양한 Hook들을 사용하실 수 있습니다.HooksuseQueryuseQuery Hook은 API를 한 개 요청하고 결과값을 받아올 때 쓰이는 Hook이기에, 가장 보편적이고 많이 쓰입니다.export const App = () =&amp;gt; { const { isLoading, data } = useQuery([&#39;user&#39;, 1], () =&amp;gt; fetch(&#39;/api/users/1&#39;).then((res) =&amp;gt; res.json()));};위와 같이 사용하실 수 있습니다.첫번째 인자로 들어가는 배열에는 ‘이 요청이 어떤 API를 호출했는지 구분할 수 있는 식별 키’가 들어갑니다.아까 위에서 동일한 네트워크 요청이 여러 횟수 발생하면 있는거 재활용해서 쓴다고 했었죠? 그 로직을 처리할 때 사용됩니다. 동일한 식별 키의 요청이 들어오면 재활용 할지 새로 불러올지 라이브러리가 알아서 선택하는거죠.두번째 인자로는 Promise를 Return하는 함수가 포함되어야 합니다.여기서 반환되는 Promise가 성공적으로 완료되면 해당 Hook이 반환하는 data Property에 결과값이 적용됩니다.Promise가 아직 처리되지 않았다면 isLoading Property가 true가 되기에 로딩 UI 처리도 손쉽게 하실 수 있습니다.useQueries이름만 봐도 대충 뭔지 아시겠죠?동시에 여러 API 요청을 처리하기 위해 만들어진 Hook입니다. 그냥 단순히 useQuery를 여러개 핸들링하기 귀찮으니 이를 하나로 묶어둔거라 사용법도 완전히 동일합니다.const results = useQueries({ queries: [ { queryKey: [&#39;post&#39;, 1], queryFn: fetchPost, staleTime: Infinity}, { queryKey: [&#39;post&#39;, 2], queryFn: fetchPost, staleTime: Infinity} ]})파라미터에는 object 타입의 객체를 전달받으며, queries Property에 위 코드와 같이 배열로 처리할 요청과 고유 키, 옵션 등을 보내면 됩니다.useInfiniteQuery위에서 예시로 잠깐 나왔던 무한 스크롤 기법을 만들기 위해 필요한 보편적인 로직을 제공하는 Hook입니다.const { fetchNextPage, // 다음 페이지 데이터를 불러올 수 있는 함수 fetchPreviousPage, // 이전 페이지 데이터를 불러올 수 있는 함수 hasNextPage, // 다음 페이지가 존재하는지 구분할 수 있는 식별자 hasPreviousPage, // 이전 페이지가 존재하는지 구분할 수 있는 식별자 isFetchingNextPage, // 다음 페이지를 불러오고 있는 중인지 구분할 수 있는 식별자 isFetchingPreviousPage, // 이전 데이터를 불러오고 있는 중인지 구분할 수 있는 식별자 ...result // etc...} = useInfiniteQuery(queryKey, ({ pageParam = 1 }) =&amp;gt; fetchPage(pageParam), { ...options, getNextPageParam: (lastPage, allPages) =&amp;gt; lastPage.nextCursor, getPreviousPageParam: (firstPage, allPages) =&amp;gt; firstPage.prevCursor,})단순히 다음 페이지를 불러오는 방식만 고려한 것이 아니라 양방향 스크롤도 고려하여 만들어졌기에 유연하게 사용하실 수 있습니다.그 외가장 많이 쓰이는 세가지 Hook에 대해서 알아봤습니다.그 외에도 Parallel Queries나 Dependent Queries 등 다양한 상황에서 활용하실 수 있는 Hook들이 존재합니다.Tanstack Devtools 설치하기저는 React Query를 사용할 때 오리지널 버전보다는 Tanstack에서 만든 @tanstack/react-query를 사용하는데요.Tanstack팀에서 제작한 강력한 개발툴을 확장해서 사용할 수 있기 때문입니다.우선 Devtools를 설치하기 위해 아래 명령어를 입력해줍니다.npm i -S @tanstack/react-query-devtools# oryarn add @tanstack/react-query-devtools그 다음, React Query Context를 사용했던 위치로 돌아가서 Context 바로 아래에 &amp;lt;ReactQueryDevtools /&amp;gt;를 추가합니다.import { useQuery, useMutation, useQueryClient, QueryClient, QueryClientProvider,} from &#39;@tanstack/react-query&#39;;import { ReactQueryDevtools } from &#39;@tanstack/react-query-devtools&#39;;// Create a clientconst queryClient = new QueryClient();function App() { return ( // Provide the client to your App &amp;lt;QueryClientProvider client={queryClient}&amp;gt; &amp;lt;ReactQueryDevtools /&amp;gt; &amp;lt;Todos /&amp;gt; &amp;lt;/QueryClientProvider&amp;gt; )}그러면 다음과 같이 React Query로 호출한 모든 네트워크의 상태를 관찰할 수 있는 개발 도구가 표시됩니다. 🎉React Query Debugger" }, { "title": "취업과 이직에 실패하는 여러분께", "url": "/posts/how-to-write-resume/", "categories": "Life, Talk", "tags": "자기소개서, 이직, 취업, 이력서", "date": "2022-10-18 23:45:00 +0800", "snippet": "개요출처: https://www.hankyung.com/life/article/202007146223g저는 얼마 전, IT 업계에 정식으로 몸을 담은지 5년 차가 되었습니다.누군가가 말하길, IT 업종에서 1인분을 하기 시작할 때는 3년차이고 어느 정도 좀 한다는 취급을 듣는 시기는 5년차라고 하더라구요. 나름 노력은 하고 있지만 배우면 배울수록 배울 것만 더 많아지는 것 같은게 이쪽 업계인 것 같아요.본론으로 들어가자면, 제가 지금 몸을 담고 있는 회사에서 시니어 프론트엔드 개발자 분을 채용하고 있습니다.그러다보니 정말 감사하게도 많은 분들이 지원해주셨고 가장 적합한 인재분을 모시기 위해 정말 꼼꼼히 서류를 검토하고 있습니다.이 과정에서 제가 느낀 것들이 참 많았고 알게 된 것도 많아서 몇 가지 말씀을 드리고자 이 글을 작성하게 되었어요.좋은 이력서를 위한 조언딱딱한 이력서 양식은 자제해주세요00년대 대기업 이력서가족관계, 자소서 등의 양식이 명확히 구분 된 표 형식의 구시대적 양식은 그다지 좋은 인상을 심어주지 못합니다.회사는 지원자분의 이야기를 들으며 합류 시 어떤 시너지를 발휘해주실까 기대하며 서류를 검토합니다.그렇기에 지원자분의 개성이 담길 수 있는 자유양식의 이력서를(Notion 이력서 등) 선호합니다.형식에 얽매이지 말아주세요자기소개서, 활동경험, 수상내역 등을 기재 해주시는건 정말 좋지만, 내가 지원하고자 하는 회사나 업종의 형태와 상관이 없는 내용은 되려 이력서의 가독성을 해칠 수 있어요.물론 지원자분이 자신을 소개할 때 강점들을 어필하기 위한 무기로써 활용을 하실 수 있다면 위 내용들을 기재하시는게 100% 좋습니다.하지만 지원하는 회사와 관계가 전혀 없고, 나의 강점과도 연결짓지 못하는, 그저 분량을 채우기 위한 목적 달성을 위해 적는 것이라면 저는 개인적으로 말리고 싶어요.이력서가 쓸 데 없이 길어지는 것도 문제지만 어찌저찌 면접까지 이어진다고 하더라도 아무 생각 없이 작성한 글귀 한 줄이 발목을 잡을 수 있거든요.회사와 직원은 갑을관계가 아니예요신입 지원자분들 뿐만이 아니라 경력분들의 자소서에도 가끔 보여지는 경우인데요.겸손을 넘어서 굴종(?)에 가까울 정도로 저자세로 접근하시는 분들이 있어요.대부분 기업의 경우, 새로 뽑을 직원이 회사의 문화 및 재정에 긍정적인 영향을 가져올 것을 기대하고 채용을 진행합니다.그렇기에 자신을 사랑하고, 자신의 기술을 충분히 갈고 닦는 사람을 선호해요.만약 저자세에 비굴한 직원을 선호하는 기업이 있다면 그런 기업은 지원자분께서 쳐다도 보시면 안됩니다. 큰일나요.이력서에는 ‘나는 이런걸 할 줄 알고, 이런 경험이 있으니 이 기업에 취업하면 이런 이점을 가져다 줄 거예요.’ 형식의 자신감있고 긍정적인 형태의 어필만이 들어가야 합니다.채용은 매우 보수적이고 신중한 업무라는 사실을 잊어서는 안됩니다.지원자일 땐 몰랐던 것들내 이력서는 정말 꼼꼼히 검토되고 있었다 “이력서 검토는 5초면 끝난다.”학생 때 혹은 취업 준비생일 때 한번 쯤은 들어보셨을 겁니다.물론 틀린 말은 아닌데, 채용 공고를 오픈하면 몇 초만에 200개씩 이력서가 들어오는 기업에서나 가능한 얘기예요.대부분의 기업에서는 불가능하다는 의미이고, 또한 그게 가능하다고 해도 5초안에 이력서를 훑어보진 않아요.인사 담당자가 가장 두려워하는게 뭔지 아시나요? 본인의 실수로 인해 인재를 놓치는 것이예요.면접 보고 뽑아도 가끔 꽝이 나오는게 채용인데 이력서를 5초안에 훑어보고 지원자를 파악하는게 가능할리가 없잖아요?못해도 최소 한 번은 끝까지 읽히기 때문에 본인의 강점을 어필하기 위한 시간은 생각보다 충분히 주어지고 있다는 것을 알아주셨으면 좋겠어요.물론 그게 좀 더 빨리 찾아온다면 가능성이 높아지겠죠?“내가 부족하니까 떨어졌겠지” 과연 그럴까? 귀하의 뛰어난 역량에도 불구하고 회사의 방향성과 맞지 않아…채용을 준비해보신 분들이라면 꽤 지겹게 보셨을 문장입니다.이력서도 멋지게 작성했고, 자기 어필도 했는데 도대체 왜 서류에서부터 떨어졌을까요?“내가 별로여서 그런거겠지”라고 생각하실 분들이 대부분일거예요. 정말로 그럴 수도 있구요.그런데 정말로 방향성이 안맞아서 떨어지는 경우가 생각보다 많다는 것을 알아주셨으면 좋겠어요.React 개발자를 채용한다고 하더라도, 신입 채용이냐 경력 채용이냐에 따라 그 목적이 많이 달라요.신입 채용의 경우에는 학부생 수준에서 터득할 수 있는 기초 소양을 보고 미래 가능성을 예측해서 채용할 뿐이지만 경력 채용의 경우는 다양한 이유로 채용을 진행하거든요. 조직 내 프로젝트 리딩 경험자의 부재 UI 라이브러리 제작 유경험자가 필요 수학적 공학적 지식의 필요위처럼 React는 정말 단순히 기초 소양일 뿐이고, 그 외 부수적인 요소를 필요로해서 채용 공고를 올리는 경우가 대부분입니다.지원자분께서 리딩을 정말 오랜기간 하셨다고 해도, 리더가 필요한 자리가 아니라면 떨어질 수도 있어요.반대로, CS 지식을 정말 많이 알고 계신다고 하더라도 리딩 경험이 상대적으로 부족해서 떨어질 수도 있는거구요.고작 몇 개의 기업에서 탈락 문자가 왔다고해서 본인의 능력이 부족하다고 자책하는 일은 없었으면 좋겠습니다. 그저 해당 기업이 조금 다른 방향으로 걷고 있었을 뿐이라고 생각해주시면 좋을 것 같아요.마치며새벽에 갑자기 생각나서 작성한 글이라 두서가 없고 무례하게 전달 되었을 수도 있어요.그건 전적으로 제 어휘력과 표현력의 문제이기에 만약 불쾌한 기분을 느끼셨다면 사과드리겠습니다. 😅이 글은 순수하게 취업과 이직을 준비하시는 모든 분들이 채용을 진행하시는 회사의 입장에서 생각해보셨으면 하는 마음에서 작성한 글이기에 읽으신 뒤 조금이나마 도움이 되셨다면 좋겠습니다.짧은 글 마무리하겠습니다.감사합니다!" }, { "title": "Novel AI 디테일하게 사용해보기", "url": "/posts/novel-ai-detail-use/", "categories": "Tech, Talk", "tags": "NovelAI, 일러스트", "date": "2022-10-10 20:18:00 +0800", "snippet": "Novel AI란?Novel AI가 궁금하신 분들은 제 이전 글을 참고해주시기 바랍니다.지난 게시글 이후그 이후로 10,000 Anlas 만큼 더 충전해서 이용해보았습니다. 한화로 약 1만 5천원 정도 돼요.2일 동안 약 10시간 정도 Novel AI 서비스를 사용해 보았습니다.그래서 이젠 어느정도 사용법을 익힌 듯 하여 여기에 다시 작성합니다.태그 입력 방식Novel AI의 UIEnter your prompt here. 입력 창에 태그를 입력하는 방식으로 그림을 생성할 수 있습니다.참고로, 태그라는 이름 답게 간단한 단어나 문장 형태로 그릴 그림을 지시해야 합니다.예를 들어‘꽃 다발을 든 사람의 모습’을 그리고 싶다면, 꽃 다발을 든 여자아이가 꽃 밭에 서 있는 모습이렇게 뭉텅이로 오더를 내리는 것이 아닌, 한 명의 여자아이, 꽃 다발을 들고 있음, 꽃 밭이렇게 오더를 내려야 합니다.그러면 이런 그림이 완성됩니다.그림 지시 방식Paint New Image 버튼을 누르면 그림판이 나타납니다.이 그림판에 내가 그릴 그림의 포즈나 의상 등을 간단하게 그린 다음, 위에 기재한 태그 설명 방식을 포함하여 오더를 내리는 방식도 이용할 수 있습니다.이 방법은 설명하기 복잡한 구도 등을 오더할 때 유용합니다.하지만 구도를 그림으로 표현할 줄 알아야 하기에 다소의 실력이 요구됩니다.할 말이 없는 그림 실력저는 이 그림으로 오더를 내려보겠습니다. 1명의 여자, 교복, 파란 머리, 파란 눈그러면 이렇게 비슷한(?) 구도로 그림을 그려줍니다.바리에이션완성 된 작품에서 약간의 수정 된 버전을 요구할 수도 있습니다.제가 해본 대부분의 케이스에서는 1차 오더에서 결과물이 좋게 나오지 않더라도 ‘바리에이션’ 기능을 이용하면 나름 원하는 결과물을 뽑아주더라구요.결과물이 하나 출력되면 해당 결과물의 위쪽에 Variations 라는 버튼이 나옵니다.이 버튼을 클릭하면 방금 전에 내린 오더를 기준으로 비슷한 구도의 다른 결과물을 3장 더 가져옵니다.위쪽에서 만든 결과물에 대해 다양한 바리에이션을 요구해보겠습니다.확실히 제가 요구한 포즈와는 달라지긴 했지만 비슷한 구도의 피사체를 다양한 그림체로 표현한 것을 알 수 있습니다.피사체 추가이제 캐릭터를 얻는데는 성공했으니, 배경을 추가하고 싶을 수도 있습니다.‘놀이동산’ 배경을 추가해봅시다.인공지능이 이래서 반란을 일으키는건가대충 하늘과 관람차를 표현합니다.태그에는 기존 태그에 이어, 놀이동산과 관람차 태그를 추가했습니다. 1명의 여자, 교복, 파란 머리, 파란 눈, 놀이동산, 관람차그러면 너무 솔직하게(…) 반환해줍니다.여기서 바리에이션 기능을 한 번 더 이용하면!위와 같이 나옵니다. 이제 제법 그럴싸 하죠?그렇지만 시안들이 전부 바닥이 없어요. 때문에 많이 어색합니다.바닥도 추가해봅시다.회색으로 대충 바닥이 위치할 곳을 표시해 준 다음, 태그를 다음과 같이 전송합니다. 1명의 여자, 교복, 파란 머리, 파란 눈, 놀이동산, 관람차, 돌 바닥그러면 이러한 시안이 만들어집니다.이 상태로도 꽤 괜찮다 생각하지만, 시안을 3개 더 받아봅시다.좋은 시안들이 나왔군요!시안들 중에는 이게 가장 예뻐보이니 이걸 기반으로 다시 시안을 뽑아봅시다.뭔가 여러 시안이 뽑히긴 했는데 오리지널이 가장 좋게 뽑혔네요 (…)그럼 이걸 최종 완성본으로 합시다!이렇게 ‘놀이동산에 놀러 온 파란 머리의 여자아이 그림’이 완성 됐습니다!후기제 실력이 부족한 탓인지, 인공지능의 실력이 낮은(?) 탓인지는 몰라도 아직 뒷배경에 사람 여러 명을 추가하는게 부자연스럽습니다.그 외에도 가끔 다리나 손이 여러개로 나오는 등의 문제가 존재하기에 아직은 인공지능이 사람의 영역을 완전 대체하기는 어려울 것 같습니다.다만 초기 시안을 뽑는데는 더할나위 없이 완벽해서 간단하게 필요한 그림을 얻거나 아이디어 스케치 용도로 활용하기에는 아주 좋은 도구인 것 같아요.여담미술 관련 커뮤니티에서는 이 인공지능의 탄생으로 인해 좌절감에 빠지신 분들이 많은 것 같던데 그 모습이 많은 생각을 하게 만드는 것 같아요.‘인공지능의 발전이 인간의 일자리를 위협한다’라는 진부한 문장은 학교건 회사건 어디서건 한번 쯤은 들어봤을 법한 대사인데, 실제로 그러한 상황을 만나서 좌절감에 빠진 사람들의 글을 읽으니, “내 직업도 언젠가 인공지능에게 완벽히 대체되는 날이 올까?” 라는 생각을 안할 수가 없더라구요.하지만 직업이 한 개 소멸하면 그로인해 새로운 직업이 열 개 생겨나는 것을 무수히 많이 보았기 때문에 저는 이 또한 시대의 흐름이라 생각하고 싶어요.이렇게 빠르게 변하는 시대에서 뒤처지지 않게 트렌드를 읽고 빠르게 행동하는 사람이 되어야겠습니다." }, { "title": "Novel AI 찍먹해본 후기", "url": "/posts/novel-ai-review/", "categories": "Tech, Talk", "tags": "NovelAI, 일러스트", "date": "2022-10-08 18:40:00 +0800", "snippet": "Novel AINovel AI는 요즘 유행하는 텍스트 기반 이미지 생성 서비스입니다.Dall E와 다른 점은 실사처럼 그리는 것이 아닌, 만화나 애니메이션과 같은 화풍으로 일러스트를 생성해 준다는 점입니다.회사 Slack에 최신 기술 동향을 공유하는 채널이 있는데 여기에 심심할 때마다 나오는 얘기 중 하나가 텍스트 기반 이미지 생성 인공지능에 관한 이야기였어서 이런 서비스들이 얼마나 정밀하게 생성해줄까 하는 호기심에 사용해보게 되었습니다.제공하는 서비스Novel AI에서 제공하는 서비스는 다음과 같습니다. 키워드를 입력하면 키워드에 기반한 소설을 작성해주는 서비스 키워드를 입력하면 키워드에 기반한 일러스트를 작성해주는 서비스 이미지를 업로드하면 해당 이미지를 일러스트로 만들어주는 서비스요금제Novel AI의 서비스는 텍스트 이야기 생성을 제외하면 모두 유료입니다.그래서 한 달에 15달러, 현재 환율로는 약 22,000원(…)을 결제하여 이용했습니다.제가 이용한 플랜은 1,000 Anlas를 제공해주는데, 이미지 생성을 위해서는 5 Anlas가 필요합니다.한 장에 약 120원 정도가 소모된다고 보시면 돼요.생성한 이미지 “비 오는 여름날 일본의 버스 정류장 앞에서 빨간 란도셀을 등에 맨 어린 여자아이가 비를 맞고 있다.” “불꽃놀이를 구경하는 소녀의 눈동자에는 불꽃이 비춰지고 있다” “인파가 가득한 일본 축제 현장에서 남자아이와 여자아이가 서로를 놓치지 않기 위해 손을 잡고 걷고 있다.”후기요즘 인공지능이 무섭게 발전한다고 듣긴 했는데 이정도인 줄은 몰랐습니다…비록 다리가 4개로 그려진다거나, 란도셀의 끈이 팔을 관통하는 등의 문제가 조금 있긴 하지만 이정도면 거의 완벽하지 않나요?스토리를 생성해주는 AI도 키워드를 제공해주면 나름 그럴싸하게 생성해주던데, 이 두가지 서비스를 병합하여 비주얼 노벨을 작성할 수 있는 날도 머지 않은 것 같습니다.일러스트 한 장을 생성해보고 감명받아서 바로 쓰기 시작한 글이라 상세한 사용법이나 단점 등이 이 글에는 담기지 않았습니다.태그 생성이나 이미지 기반 일러스트 생성과 같은 기능들을 조금 더 사용해보고 나중에 좀 더 자세한 후기로 찾아뵙겠습니다.감사합니다!" }, { "title": "React Context", "url": "/posts/react-context-introduction/", "categories": "Tech, React", "tags": "React, Context", "date": "2022-09-30 22:24:00 +0800", "snippet": "ContextContext는 React에서 제공하는 기능 중 하나로, 유효범위 내부에 존재하는 컴포넌트들에서 데이터를 주고받는 방법 중 하나입니다.사용 이유기본적으로 React 공식 홈페이지에서는 컴포넌트들의 계층이 복잡해질 때 props가 아닌 다른 방식으로 데이터를 쉽게 주고 받을 수 있다고 홍보(?)하고 있습니다.하위 컴포넌트에게 넘겨주기 위해 거쳐가야하는 관문이 많다위 사진은 저번 Atomic Design 문서에서 언급했던 Prop Drilling 현상을 설명하는 사진입니다.컴포넌트가 서로 데이터를 공유하기 위해 props를 사용하다보면 상위 계층이 갖고있는 데이터를 최하위까지 넘겨주기 위해 생기는 문제가 발생하는데 이를 Prop Drilling이라고 합니다.Context는 이를 어떻게 해결해 줄 수 있을까요?사용법React.createContext우선 Context를 사용하기 위해 Context를 생성해봅시다.Context를 생성하기 위해서는 React.createContext 함수를 사용해주시면 됩니다. 매개변수로는 해당 Context가 생성 초기에 가질 데이터를 선언해주면 됩니다.const ExampleContext = React.createContext({ message: &#39;Hello world!&#39; });export default ExampleContext;Context를 선언했으니 이제 이를 사용해봐야겠죠?Context.ConsumerConsumer라는 이름을 가진 API답게 Context의 값을 사용만 할 수 있는 컴포넌트입니다.import ExampleContext from &#39;./context/ExampleContext.ts&#39;;export const App = () =&amp;gt; { return ( &amp;lt;ExampleContext.Consumer&amp;gt; {(value) =&amp;gt; { return ( &amp;lt;div&amp;gt; 오늘의 인사말은 {value.message} 입니다! &amp;lt;/div&amp;gt; ); }} &amp;lt;/ExampleContext.Consumer&amp;gt; );};export default App;Context API에서 자주 사용되는 Consumer는 Context가 갖고있는 value에 접근할 수 있는 기능을 제공합니다.Context.Consumer 태그 내부에는 함수가 적용될 수 있는데, value를 매개변수로 갖고 있으며 해당 함수에서 반환되는 JSX를 렌더링합니다.value는 일반적인 State와 마찬가지로 반응성을 가지고 있어, Context의 데이터가 변경이 된다면 Context의 값을 참조하고 있는 컴포넌트들은 모두 리렌더링이 됩니다.Context.ProviderProvider는 Consumer와 동일하게 값을 참조할 수 있지만 데이터를 이 곳에서 선언할 수도 있습니다.import ExampleContext from &#39;./context/ExampleContext.ts&#39;;export const App = () =&amp;gt; { const [message, setMessage] = useState&amp;lt;string&amp;gt;(&#39;Good bye!&#39;); return ( &amp;lt;ExampleContext.Provider value={{ message }}&amp;gt; &amp;lt;div&amp;gt;오늘의 인사말은 {message} 입니다!&amp;lt;/div&amp;gt; &amp;lt;/ExampleContext.Provider&amp;gt; );};export default App;React.useContextuseContext는 Provider 내부에 존재하는 계층구조의 컴포넌트에서 최하위 계층에서 Context값을 참조하는데 도움을 주는 API입니다.import ExampleContext from &#39;./context/ExampleContext.ts&#39;;import MessagePrintComponent from &#39;./MessagePrintComponent.tsx&#39;;export const App = () =&amp;gt; { return ( &amp;lt;ExampleContext.Provider value={{ message: &#39;good bye!&#39; }}&amp;gt; &amp;lt;MessagePrintComponent /&amp;gt; &amp;lt;/ExampleContext.Provider&amp;gt; );};export default App;위와 같이 Provider 내부에 존재하는 MessagePrintComponent가 있습니다.import ExampleContext from &#39;./context/ExampleContext.ts&#39;;export const MessagePrintComponent = () =&amp;gt; { const value = React.useContext(ExampleContext); return ( &amp;lt;div&amp;gt; &amp;lt;div&amp;gt;오늘의 인사말은 {value.message} 입니다!&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; );};export default MessagePrintComponent;useContext를 사용하면 Provider 하위에 존재하는 컴포넌트에서도 굳이 props로 받지 않더라도 데이터를 직접 참조할 수 있습니다. 그게 ‘가능’은 하다는거지 컴포넌트의 의존성이 심해지므로 일반적인 경우에는 props로 데이터를 전달받는게 훨씬 좋습니다.주의사항리렌더링 이슈React에서의 컴포넌트 리렌더링은 어떤 컴포넌트에서 사용되고 있는 state의 참조를 확인합니다.그렇다보니 만약 Context가 최상위가 아니라 페이지 전체 계층 중 중간쯤 단계에서 사용하고 있을 때 이런 문제가 발생할 수 있습니다.const Top = () =&amp;gt; { const [number, setNumber] = useState&amp;lt;number&amp;gt;(0); return ( &amp;lt;&amp;gt; &amp;lt;Middle number={number} /&amp;gt; &amp;lt;button onClick={setNumber(number + 1)}&amp;gt;number 증가&amp;lt;/button&amp;gt; &amp;lt;/&amp;gt; );};export const Middle = (props) =&amp;gt; { return ( &amp;lt;AnyContext.Provider value={{ message: &#39;Hello world!&#39; }}&amp;gt; { props.number } &amp;lt;Bottom /&amp;gt; &amp;lt;/AnyContext.Provider&amp;gt; );};export const Bottom = () =&amp;gt; { const value = React.useContext(AnyContext); return ( &amp;lt;div&amp;gt; { value.message } &amp;lt;/div&amp;gt; );}; Top 컴포넌트는 number라는 state를 갖고 있습니다. Top 컴포넌트는 버튼을 누르면 number가 1씩 증가합니다. Top 컴포넌트는 Middle 컴포넌트에게 number를 전달합니다. Top 컴포넌트는 Middle이라는 하위 컴포넌트를 갖고 있습니다. Middle 컴포넌트는 AnyContext.Provider를 갖고 있습니다. Middle 컴포넌트는 Bottom이라는 하위 컴포넌트를 갖고 있습니다. Middle 컴포넌트는 상위 컴포넌트로부터 number를 받아서 출력합니다. Bottom 컴포넌트는 useProvider라는 API를 이용하여 AnyContext의 데이터를 참조하고 있습니다.이 상황에서 Bottom 컴포넌트가 렌더링 되기 위한 최고의 상황은 AnyContext의 Value가 수정될 때 뿐일거예요.하지만 setNumber가 실행될 때마다 Bottom마저 리렌더링이 됩니다.그 이유는, Top 컴포넌트의 state를 middle 컴포넌트가 바라보고 있으니 number가 변할 때마다 middle이 리렌더링 됩니다.그 과정에서 Provider가 리렌더링 되면서 전달되는 value의 값마저 재정의 되기 때문에 React는 해당 Provider하위에서 AnyContext의 value를 참조하는 모든 컴포넌트를 리렌더링 시키게 됩니다.해결방법Provider에 전달할 value를 state로 정의하면 됩니다.export const Middle = (props) =&amp;gt; { const [message, setMessage] = useState&amp;lt;string&amp;gt;(&#39;Hello world&#39;); return ( &amp;lt;AnyContext.Provider value={{ message }}&amp;gt; { props.number } &amp;lt;Bottom /&amp;gt; &amp;lt;/AnyContext.Provider&amp;gt; );};이렇게 정의하면 상위 컴포넌트의 값이 바뀌어서 Middle 컴포넌트가 리렌더링이 된다고 해도 상태로서 정의 된 message의 값이 재정의 되지 않으니 React는 Provider의 value가 변경되었다고 판단하지 않기 때문입니다.레퍼런스React - Context" }, { "title": "Atomic Design 설계와 Container Component", "url": "/posts/atomic-design-with-container-component/", "categories": "Tech, Talk", "tags": "Atomic Design", "date": "2022-09-27 21:33:00 +0800", "snippet": "개요저는 몇 개월 전부터 Atomic Design 방법론에 빠져있어요.애초부터 비즈니스 로직과 UI 컴포넌트 로직은 완벽히 분리되어야 한다는 철학이 있었던 저에게 있어 Atomic Design은 그 어떤 설계방법보다 아름답다고 느꼈거든요.Atomic Design아토믹 디자인하면 많이 보는 이미지Atomic Design은 이미 유명한 방법론이고 컴포넌트 개발방식을 이용한 요즘 프론트엔드 프레임워크를 사용하는 프론트엔드 개발자라면 한 번 쯤은 들어보신적 있는 방법론일거예요.쉽게 말해, 컴포넌트를 현실에 존재하는 물질로서 간주하고 역할을 세분화하는 방법론이예요.Atomic Design은 보편적으로 5단계의 세분화 과정을 거쳐요.대표적인 원자 레벨 컴포넌트인 InputAtom 현실에 존재하는 원자를 비유적으로 표현한 레벨이예요. 원자 레벨이라고 불러요 실제 원자처럼 더 이상 작게 쪼갤 수가 없는 컴포넌트로서, Input이나 Text와 같은 아주 간단한 기능만을 수행하는 컴포넌트가 원자 레벨 컴포넌트예요. 앞으로 소개할 4단계 중 가장 재사용성이 높은 컴포넌트라고 볼 수 있어요.Input과 Label이 합쳐진 분자 컴포넌트 FieldMolecule 현실에 존재하는 분자를 비유적으로 표현한 레벨이예요. 분자 레벨이라고 불러요 실제 분자처럼 여러 원자 컴포넌트가 합쳐져서 만들어진 컴포넌트예요. label과 input이 공존하는 field 컴포넌트를 예로 들 수 있어요. 원자 레벨의 컴포넌트와 마찬가지로 프로젝트 전체에서 재사용 될 가능성이 높은 컴포넌트예요.다양한 Field와 Button 등이 혼합 된 대표적인 유기체 FormOrganism 현실에 존재하는 유기체를 비유적으로 표현한 레벨이예요. 유기체 레벨이라고 불러요 여기서부터는 특정 페이지에만 존재하는 컴포넌트들이 개발될 수 있어요. 경우에 따라 비즈니스 로직을 내포하거나 컴포넌트 내부에 상태나 로직을 선언하여 사용할 수 있어요 재사용 할 수 있는 구조로 만드는게 최고지만 원자나 분자 레벨의 컴포넌트처럼 반드시 준수해야 하는건 아니예요.Template 특정 페이지에 접속하면 보이게 되는 레이아웃의 원형이예요. 서버나 Redux와 같은 상태 관리자로부터 데이터를 넘겨받아 Prop으로 전달하면 실제 데이터가 바로 보여질 수 있도록 범용성있게 개발해야 하는 컴포넌트예요. 만약 데이터를 넘겨주지 않은 상태로 사용을 한다고 해도 페이지를 구성하는데 있어 임시 UI라도 보여지도록 설계하는게 좋아요Page Template 컴포넌트를 직접 사용하는 단계예요. Next.js나 Nuxt.js를 사용하면 pages 폴더 안에 페이지를 정의하잖아요? 그 레벨이예요. 여기서는 Middleware를 통해 사용자 자격 검증을 진행하기도 하고 서버와의 직접적인 통신으로 데이터를 불러올 수도 있어요. UI를 페이지에서 구현할 때는 반드시 작성 된 Template만을 사용할 수 있어요. 불러온 데이터를 Template 컴포넌트에 전달하여 유의미한 데이터를 화면상에 표시할 수 있는거죠.겁도 없이 덤비는 낯선이여위 설명만 들어보면 정말 완벽하게 독립적인 UI 컴포넌트를 만들 수 있을 것 같은 예감이 듭니다.당신은 이제 “오! 이제 알겠어! 나는 이제 컴포넌트 개발 마스터다!” 라는 패기로운 마인드로 개발을 시작하게 됩니다.하지만 곧 이론과 현실은 다름을 깨달으며 Atomic Design을 거두게 됩니다.Prop Drilling이제 Atomic Design을 마스터했다고 생각한 당신은 회사 프로젝트에 적용을 해보기로 합니다.근데 예상보다 프로젝트가 커지면서 컴포넌트의 Depth가 깊어집니다.점점 무거워지는 Props를 보며 “아 뭔가 망한 것 같은데” 라는 생각이 들게 됩니다.???: 나는 필요도 없는 데이터를 자꾸 넘겨주네Atom이나 Molecule 단계의 컴포넌트는 아무리 하찮더라도 본연의 역할을 다하기 위해서라면 Props가 반드시 필요합니다.하지만 최하위 레벨까지 값을 내려주기 위해서는 거쳐야만 하는 관문들이 너무나 많아졌어요.만약 당신이 Atomic Design 방법론과 함께 Typescript까지 같이 사용하고 있다면 상황은 최악으로 치닫게 됩니다.컴포넌트가 받아야 할 Props에 대한 Interface를 어떻게 관리해야 할지도 막막할거거든요.당장 그 컴포넌트에 필요하지도 않은 데이터들인데 Interface에 넣고 관리하고 있노라면 퇴근 생각이 절실해집니다.Tooltip이랑 Modal은 어디다가 놔야 돼?문제는 또 있습니다. 버튼을 눌렀을 때 Tooltip이나 Modal을 표시하고 싶습니다. 그렇다면 당신은 해당 컴포넌트들을 어디다가 배치해야 할까요?버튼 내부에다가 두게 되면 버튼은 더 이상 원자 레벨이 아니게 되고, 그렇다고 분자로 올리자니 최소의 단위로 쪼개야하는 방법론의 정체성을 부정하게 됩니다.페이지가 너무 무거워요가장 심각한 문제는 페이지의 무게가 너무 무거워진다는겁니다.Template 컴포넌트에 Props로 데이터를 넘기고, 이벤트를 핸들링해야 하는데 이를 처리할 레벨이 Page밖에 남아있지 않습니다.그렇다면 Page에서 API 요청도 날리고, 데이터 파싱도 진행하고, 이벤트 처리도 해야하니 페이지 코드가 심각하게 복잡해집니다.Template을 다시 쓰긴 하나?Atomic Design 방법론에 따르면 Template 레벨의 컴포넌트는 페이지의 레이아웃 자체를 재활용하는 상황에 대비하여 만드는 껍데기입니다.하지만 웹앱 개발 경험을 다수 쌓으셨다면 느끼시겠지만 일반적인 컴포넌트는 재활용을 자주 할 수 있지만 페이지 레이아웃을 여러 페이지에서 끌어다가 활용하는 경우는 없다고 봐도 무방할 정도로 드문 일입니다.쓸 확률이 희박한 컴포넌트를 만들겠다고 안그래도 힘든 Prop Drilling에 한 Depth를 추가하는 꼴밖에 되지 않아요.이와같이 완벽해보이기만 했던 이론도 실제로 사용하면서 많은 문제를 느끼게 됩니다.그렇지만 분명히 Atomic Design 방법론이 추구하고자 하는 모습은 굉장히 매력적이게 다가옵니다. 그렇기에 많은 개발자들은 Atomic Design을 프로젝트 형태에 맞게 변형하여 채택합니다.이 문서에서 소개하고자 하는 Container Component도 그 일환중 하나예요.Container Component이 방법론을 설명하기에 앞서, 여러분들은 한가지 사실을 인정하셔야 합니다.“더러운 컴포넌트는 반드시 필요하다” 라는 것을요.‘더러운 컴포넌트’란 Redux나 MobX와 같은 외부 라이브러리를 제어하거나 API 요청을 이용해 데이터를 직접 불러오는 로직 등이 포함 된, 즉 비즈니스와 매우 Deep하게 연결되어 있어서 의존성이 굉장히 큰 컴포넌트를 말합니다.우리는 이런 더러운 컴포넌트를 Container라고 부르기로 해요.Atomic Design과 함께 써보기그렇다면 이제 Atomic Design 방법론과 이를 결합해봅시다.원자와 분자, 유기체 레벨은 그대로 가져갑니다.다만 유기체 다음 레벨에 Container라는 계층을 하나 추가할거예요.Container 계층에서는 Atom Molecule Organism 그 어떤 컴포넌트도 들어올 수 있지만, 가급적 역할은 하나로 세분화 해야 합니다.많은 앱에서 사용되는 AppBar위 헤더의 역할은 다음과 같아요. 뒤로가기 버튼을 누르면 뒤로 간다. 키보드 버튼을 누르면 키 설정 Modal이 나온다. 다운로드 버튼을 누르면 파일이 다운로드 된다.이 AppBar는 하나의 Organism입니다. 그렇다면 각 버튼에 대한 이벤트 처리가 되어야 하겠죠?이를 이제 AppBarContainer 라는 Container로 포장합니다.export const AppBarContainer = (props: PropsType) =&amp;gt; { const navigator = useNavigator(); const [isVisible, setVisible] = useState&amp;lt;boolean&amp;gt;(false); return ( &amp;lt;&amp;gt; &amp;lt;AppBar onClickBackButton={navigator.goBack} onClickKeyboardButton={() =&amp;gt; setVisible(true)} onClickDownloadButton={() =&amp;gt; download()} /&amp;gt; &amp;lt;Dialog dialog={{ open: isVisible, onClose: () =&amp;gt; setVisible(false), }} visibleConfirmButton={true} onConfirm={() =&amp;gt; setVisible(false)} /&amp;gt; &amp;lt;/&amp;gt; );};이처럼 AppBar에서 수행할 로직을 Container에 정의합니다.덤으로 아까 언급했던 Modal과 같은 컴포넌트도 이 곳에 배치합니다.window.navigation에 접근하여 네비게이션을 핸들링하기도 하고 파일 다운로드 로직을 연결하여 직접 다운로드를 시킬 수도 있습니다.페이지에 과중하게 부담되는 역할을 컴포넌트마다 분산시킬 수 있어요!이렇게 Container까지 잘 만들었다면 이걸 이제 어떻게 써야할까요?Template이제 Template이 등장합니다!export const ExampleTemplate = () =&amp;gt; { &amp;lt;&amp;gt; &amp;lt;AppBarContainer /&amp;gt; &amp;lt;ContentContainer /&amp;gt; &amp;lt;FooterContainer /&amp;gt; &amp;lt;&amp;gt;};위와 같이 Template을 Container들을 묶어서 간단하게 표현할 수 있어요!이러면 Template도 오염되지 않나요?더러운 컴포넌트라고 정의한 Container가 Template 내부에 포함되었으니 Template도 의존성이 생겨버렸어요.하지만 Template 레벨의 컴포넌트는 재사용 될 가능성이 상대적으로 희박하므로 “의존성이 생겨도 별 문제가 없을 것이다” 라는 판단 하에 이렇게 사용하도록 용도를 변경했습니다.Template 레벨을 통해 Container를 묶어주면 페이지 로직은 아래와 같이 매우 깔끔하게 만들어집니다!const Page: NextPageWithLayout = (props: PropsType) =&amp;gt; { return ( &amp;lt;&amp;gt; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;{title}&amp;lt;/title&amp;gt; &amp;lt;meta property=&quot;og:image&quot; content={image} key={&#39;og:image&#39;} /&amp;gt; &amp;lt;meta property=&quot;viewport&quot; content=&quot;width=device-width,height=device-height,initiali-scale=1,minimum-scale=1,maximum-scale=1&quot; key={&#39;viewport&#39;} /&amp;gt; &amp;lt;/Head&amp;gt; &amp;lt;PageTemplate /&amp;gt; &amp;lt;/&amp;gt; );};// ...export default Page;페이지는 이제 Middleware나 라우팅 관련 로직만을 처리할 수 있도록 코드를 깔끔하게 분리할 수 있겠네요!레퍼런스Effective Atomic Design" }, { "title": "각도가 적용 된 사각형 도형의 각 꼭짓점 좌표 구하기", "url": "/posts/get-points-rotated-rect/", "categories": "Tech, Javascript", "tags": "", "date": "2022-09-26 20:04:00 +0800", "snippet": "개요회사 프로젝트를 진행하다가 어떤 영역에 배치 된 사각형이 어떤 각도로 회전했을 때, 그 사각형의 각 꼭짓점을 알아야만 하는 상황이 생겼어요.장시간의 리서칭과 사내 개발자분의 조언을 통해 완성한 소스코드입니다.소스코드export const getRectPoint = ( x: number, y: number, radian: number): Point =&amp;gt; { const left = (x) * Math.cos(radian) - (y) * Math.sin(radian) + p; const top = (x) * Math.sin(radian) + (y) * Math.cos(radian) + q; return { x: left, y: top };};위 소스코드는 아래 공식을 참고하여 만들어졌어요. 회전 된 사각형의 x 좌표는 회전 되지 않은 사각형의 x를 Math.cos(radian)과 곱한 값과, 회전되지 않은 y 좌표의 값과 Math.sin(radian) 값을 곱하여 더한 값과 동일합니다. 회전 된 사각형의 y 좌표는 회전 되지 않은 사각형의 -x를 Math.sin(radian)과 곱한 값과, 회전되지 않은 y 좌표의 값과 Math.cos(radian) 값을 곱하여 더한 값과 동일합니다.문제점다만 이 소스코드는 회전축이 매번 (0, 0)으로 고정되어 있어요. 하지만 제가 필요로 하는 것은 회전축이 상황에따라 변경되어도 정상적으로 작동하는 로직이기에 기존 소스코드에서 약간 수정하여 해당 기능을 완성했어요.완성 된 코드export const getRectPoint = ( x: number, y: number, p: number, q: number, radian: number): Point =&amp;gt; { const left = (x - p) * Math.cos(radian) - (y - q) * Math.sin(radian) + p; const top = (x - p) * Math.sin(radian) + (y - q) * Math.cos(radian) + q; return { x: left, y: top };}; 기존에 (0, 0)을 기준으로 작성 된 코드에서, 회전축의 좌표를 추가로 입력 받을 수 있는 매개변수 p와 q를 추가했어요.주의본 소스코드에 사용 된 회전 값은 radian이므로, degree 값을 넣을 시 정상 동작하지 않습니다!레퍼런스Stackoverflow - Get rotated rectangle points from x, y, width, height and rotation" }, { "title": "산업기능요원 첫번째 이직", "url": "/posts/skilled-industrial-personnel/", "categories": "Tech, Talk", "tags": "", "date": "2022-06-23 09:32:00 +0800", "snippet": "개요산업기능요원 편입이 되었던 작년 9월 6일, 이적 시장에 풀리는 기간인 6개월을 뛰어넘어 10개월간 복무하고 이직을 하게 되었습니다.이직 이유이직을 결심하게 된 계기는 여러가지가 있겠지만 가장 큰 이유는 커리어 측면에서의 이슈가 가장 컸던 것 같습니다.실력이 없는 경력자저는 일반적인 산업기능요원과는 다르게 일반 회사에서 3년이 조금 안되는 기간동안 개발자로 일을 하고 있었기에 산업기능요원 편입 당시, 이미 저는 3년의 경력을 갖고 있었습니다. (입사 이후 한 달 뒤에 받았음.)IT 업계에서 흔히 시니어라고 취급되는 시기는 5년 정도의 경력을 보유한 사람을 말합니다. 물론 시니어 취급을 받으려면 여러가지 요건들이 갖춰져야 하겠지만, 일반적으로 그런 요건들이 갖춰지는 시기를 5년으로 보는거겠죠.산업기능요원 편입 후 9개월이 지났을 무렵, 한가지 걱정이 들기 시작했습니다.“나 잘하고 있는거 맞나?”저는 개발자 커리어를 체계가 상대적으로 부족한 스타트업에서 시작했기에, 사수로부터 제대로 기술을 인계받을 기회가 없었습니다.그러다보니 내가 짜는 코드가 맞는 코드인지도 검증받지 못한 상태로 기술만을 공부하다가 어영부영 3년차가 되었고, 군문제에 쫒겨 다른 회사로 이직하고 9개월이 지났던거죠.이 무렵 저의 경력은 3년 7개월이였는데, 내가 만약 이 성장세 그대로 1년 5개월이 지난다면 “나는 과연 업계에서 시니어로서 인정 받을 수 있을까?” 라는 의문이 들게 되었습니다.만족은 하지만… 높지않은 개발 수준현재 다니는 회사가 좋은가 안좋은가를 따지면 나름 좋은 편이라고 생각합니다.물론 복지나 연봉 측면에서 서운한게 없느냐를 따져보면 할 얘기가 좀 있지만, 업무의 장벽도 높지 않고, 사람들이라던가 회사 위치라던가 나름대로 다 적당적당해서 마음 편히 다니기에는 부족함이 없었거든요.그런데 업무의 장벽이 높지 않다는건 다르게 말하면 배울게 한정적이라는 의미와 같거든요.회사에서 진행하던 업무는 관리자 CMS, 서비스 프론트 개발 등이 있었으나 이 프로젝트들을 체계적으로 관리하고, 테스트 코드를 작성하고, 페어 코딩을 하거나 코드 리뷰를 하는 등의 개발 문화가 없었기에 전임자가 구성해놓은 코드를 유지하기에도 급급한 상황이였고, 단순 개발 그 이상의 무언가를 배우기에는 적합하지 않은 환경이라고 생각 되었습니다.이직 과정산업기능요원의 이직은 조금 특별합니다.일반 직원들은 어느날 갑자기 “나 그만둡니다! 빠이!” 이러고 나오기도 한다던데, 산업기능요원이 편하게 이직하기 위해서는 이직할 직장의 협조와 더불어 현 직장의 협조도 있어야 하거든요.그렇기에 복무하는 회사에서 업무를 똑바로 해야하는거예요. 업계에 퍼지는 나의 평판도 물론 중요한 이유지만, 더 큰 이유로는 나의 사정상 협조를 받아야 할 때 원활하게 협조를 받기 위해서거든요.퇴사 사실 밝히기저같은 경우는 일반적인 다른 사람들의 퇴사 과정과 마찬가지로 이직할 회사를 미리 합격한 상태에서, 처우 협상까지 모두 끝내고 이직 사실을 현 회사에 밝혔습니다.산업기능요원을 뽑았다는건 못해도 복무 기간동안은 같이 일해보는걸 기대하면서 뽑은걸텐데 이직을 하겠다고 말한다면 아무래도 사측이 받을 충격이 있을테니 이 부분은 각오하셔야 합니다.저는 처음에 이사님께 조용히 말씀을 드리고 어느정도의 쓴소리는 각오했었는데, 의외로 덤덤하게 받아주셔서 놀랐었습니다.이전 직장에서도 많은 사람들을 관리하셨다보니 이런 경우가 많았었나봐요. 편안한 분위기로 말씀해주셔서 너무 감사했습니다.합격한 회사로부터 채용동의서 받기산업기능요원은 전직을 위해 채용동의서와 전직승인서라는 서류가 필요합니다.채용동의서는 나를 채용해주는 회사에서 받아야 하는 서류입니다.여기에는 이 사람이 여기서 할 업무들, 자격번호, 인적사항, 회사 주소 등이 적혀있습니다.전직승인서 받기사실 이걸 받아내는게 산업기능요원 이직 절차 중 가장 까다로운 절차라고 봐도 될 것 같아요.전직승인서는 내가 현재 다니는 직장으로부터 받아야 하는 서류입니다.“이 사람이 다른 회사로 가는걸 허락합니다.”라는 서류인데, 저같은 경우는 정말 감사하게도 회사 측에서 바로 써주셔서 어려움이 없었습니다만, 다른 회사의 경우에는 이걸 안써주기도 한다고 하더라구요.업무 시간에 화장실을 오래 갔다던가, 담배를 너무 자주 피웠다던가 하는 이유를 대면서 불성실 복무로 협박하는 회사도 많다고 하는데 그런거 보면 저는 참 좋은 회사에 다녔구나 싶습니다.만약 본인이 위 케이스에 해당해서 전직 승인서를 받지 못했다면 병무청에 지원요청을 해서 강제로 받아내는게 가능합니다.다만 이 경우 회사와 감정도 많이 상하고 시간도 상대적으로 곱절로 쓰이기에 원만한 합의를 하시는게 가장 베스트입니다.병무청 승인 확인하기전직승인서를 받는다는건, 내가 서류를 직접 받는 것이 아니라 이직할 직장에서 받은 채용동의서를 현 직장에 제출하고, 이를 현 직장에서 병무청에 직접 전직승인서와 함께 제출하는 것을 의미합니다.병무청으로 서류가 전달되면 얼마 뒤 승인이 되었다는 메시지가 카톡으로 날아올텐데, 반드시 이 문자를 받고 퇴사 하셔야합니다.만약 승인 이전에 퇴사를 하신다면 편입 취소로 군대를 가야합니다.퇴사날까지 인수인계 열심히 하기이제 산업기능요원으로서 이직에 필요한 모든 과정은 끝났습니다.열심히 인수인계를 해서 회사에 누를 끼치지 않게 하고, 깔끔히 퇴사하시면 됩니다.여러분들의 성공적인 커리어를 응원합니다!" }, { "title": "Svelte에 적용하는 Typescript", "url": "/posts/svelte-typescript/", "categories": "Tech, Svelte", "tags": "Svelte, Typescript", "date": "2022-06-22 14:59:00 +0800", "snippet": "개요이번에 토이프로젝트를 제작하기 위해 Sapper + Typescript를 사용해보기로 결정했습니다.원래는 Nuxt3를 써보려 했는데 아직 정식 릴리즈가 되지 않아 Sapper가 좀 더 끌리더라구요.Sapper란?Svelte에 서버 엔진을 붙인 프레임워크입니다.React의 Next.js, Vue의 Nuxt를 생각해보시면 될 것 같아요.설치패키지 설치npmnpm i --D svelte-preprocess typescriptyarnyarn add -D svelte-preprocess typescripttsconfig.json 추가{ &quot;include&quot;: [&quot;src/**/*&quot;], &quot;exclude&quot;: [&quot;node_modules/*&quot;], &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es2015&quot;, &quot;module&quot;: &quot;es2015&quot;, &quot;types&quot;: [&quot;svelte&quot;] }}rollup.config.js 편집// ...import autoPreprocess from &quot;svelte-preprocess&quot;; // add thisexport default { client: { plugins: [ svelte({ preprocess: autoPreprocess(), // add this // ... server: { plugins: [ svelte({ preprocess: autoPreprocess(), // add this // ... }), // ...d.ts 추가declare module &#39;*.jpg&#39;;출처Use Typescript with svelte sapper" }, { "title": "탁월한 개발자", "url": "/posts/the-great-developer/", "categories": "Tech, Talk", "tags": "", "date": "2022-05-27 15:26:00 +0800", "snippet": "개요최근에 여러 기업에 면접을 보러다녔는데 그 중 어떤 기업에서의 임원면접에서 들은 질문입니다.“찬영님이 생각하시기에 탁월한 개발자란 뭐라고 생각하세요?”이 질문을 처음 들었을 때 약간의 생각에 잠겼습니다.일단 질문 자체가 막연히 ‘탁월함’에 대한 정의를 요구하고 있기 때문이기도 했고, ‘일을 잘하는 사람’에 대한 기준은 가끔 생각하던 것이였지만 ‘탁월한 개발자’에 대해서 고민해본 적은 딱히 없기 때문입니다.그래서 저는 이 질문에 대해 활용할 수 있는 최선의 기술을 선택하는 능력이 있는 개발자라고 대답했습니다.사업적 측면의 개발자대부분의 개발자는 회사에 소속되어 가치를 창출합니다.물론 프리랜서로 일하는 개발자도 있긴하지만 어쨌든 실제 사용자가 존재하는 소프트웨어를 만들고 수익을 챙기는 형태는 변함이 없어요.그렇다면 이 개발자가 생각해야 하는 것은 어떤게 있을까요?좋은 기술? 깔끔한 코드? 좋은 UI?모두 정답이예요. 하지만 저는 제 경험을 토대로 생각해봤을 때, 저 질문에 대한 답변을 ‘활용할 수 있는 최선의 기술’ 이라고 정의했습니다.예를 들어보죠. 신입으로 채용 된 주니어 개발자가 갑자기 선임에게 이런 말을 합니다.“Vue3가 훨씬 좋은데 왜 Vue2를 써요?”“Javascript 코드는 보기 더러워요, Typescript로 진행하면 안되나요?”“요즘 GraphQL이 유행이던데 이걸로 바꿔봐요”신기술 예찬론자아마 회사에서 몇 년 정도 개발자로 업무를 진행해보셨다면 심심치않게 보실 수 있는 유형의 개발자인데, 저는 이런 개발자를 신기술 예찬론자 혹은 최신기술 신봉자 라고 부릅니다.물론 Vue3가 Vue2보다 좋은게 사실입니다. d.ts의 정의가 없어도 타입 추론이 가능하며, Composition API를 통해 코드를 깔끔하게 정의할 수도 있겠죠.그렇지만 비즈니스 프로젝트를 개발하는 개발자는 기술적인 측면보다 나에게 돈을 주는 쩐주를 우선으로 생각해야 합니다.보통의 고객들이 서비스에 요구하는건 어떤게 있을까요? 아마 조금씩 다르겠지만 대부분은 아래와 같을겁니다. 빠른 속도 좋은 경험 제로 버그위 세가지가 충족되기 위해서는 좋은 도구, 실력있는 개발자, 좋은 기획 등을 꼽을 수 있겠죠.좋은 도구의 관점으로 접근하면 대부분의 경우 최근에 나온 기술이 좋습니다. 애초에 예전에 있던 기술보다 안좋은 기술이였다면 내 귀에 들려오기 전에 사장 됐을거거든요.하지만 좋은 도구보다 중요한건 그 도구에 대한 숙련도입니다.만약 무턱대고 최근에 나온 라이브러리를 갖다 썼다가 예기치 못한 문제가 발생하면 어떻게 될까요?일단 그 문제를 경험해 본 적 있는 사람 자체가 없을거예요. 가장 작게는 우리 조직에서, 크게 보면 Stackoverflow에서도 해당 이슈에 대한 토론이 이루어지기 전일 수도 있습니다.그러면 이 버그를 수정하기 위해 온갖 삽질을 해야할거고, 최악의 경우에는 아예 프로젝트를 갈아야 할수도 있어요.그렇다면 해당 기술이 ‘최신기술’ 카테고리에는 들어가지만 출시 된지 어느 정도 지나서 안정성을 확보한 상태라면 괜찮을까요?그래도 고민을 해보긴 해야합니다.일단 혼자 개발하는 토이 프로젝트가 아닌 이상 해당 프로젝트에 여러 사람이 투입 되어야 하는 경우가 대부분일텐데, 당장에 개발자들이 뛰어들어도 모자란데도 우리는 그 기술 하나를 이해하기 위해서 별도의 학습 시간을 마련해야 합니다.또한, 기껏 프로젝트를 성공적으로 만들어놨더니 기존 개발자들이 퇴사하여 신규 개발자를 채용해야 할 때 해당 기술을 알고 있는 사람을 데려오는 것에도 어려움을 겪을거예요.이러한 모습은 주로 엔지니어적 성향이 강한 개발자 혹은 주니어 개발자에게서 자주 보이는 모습인데, 우리는 기억해야 합니다.여러분의 코드를 가치있게 만드는 것은 그걸 사용하는 누군가의 존재이고, 우리는 그 ‘누군가’를 우선으로 생각해야 합니다. 최소한 비즈니스 목적의 코드를 작성할 때는요.우리 모두 도구에 잡아먹히지 않는 개발자가 됩시다!" }, { "title": "JSDoc으로 Javascript 문서를 좀 더 친절하게 만들어보자", "url": "/posts/about-jsdoc/", "categories": "Tech, Talk", "tags": "Javascript", "date": "2022-05-19 10:58:00 +0800", "snippet": "JSDocJSDoc은 Javascript로 작성 된 문서에서 각 변수나 함수 등에 의미를 부여하기 위한 마크업 언어입니다.이를 이용하면 VSCode와 같은 개발 툴에서 특정 함수를 사용할 때, 이 함수가 어떤 역할을 하는지 혹은 어떤 변수를 파라미터로 전달 받는지 등을 툴팁 형태로 띄워줄 수 있습니다.태그 @author 이 코드를 작성한 개발자를 나타낼 때 사용합니다. @constructor 이 함수가 생성자의 역할을 할 때 사용합니다, @deprecated 더 이상 사용되지 않는 함수에 사용합니다. @exception @throws와 동일하게 사용됩니다. @exports 어떤 모듈에서 추출 된 멤버인지를 나타냅니다. @param 특정 함수에 넘겨야 하는 파라미터를 나타냅니다. @private private로 선언 된 함수를 표시할 때 사용합니다. @returns 이 함수가 return하는 값을 표현할 때 사용합니다. @return @returns와 동일하게 사용됩니다. @see 다른 개체와 연결 되어 있음을 명시적으로 표현합니다. @this 이 함수 내에서 갖고있는 this가 어떤 값을 의미하는지 표현할 때 사용합니다. @throws 이 함수 안에서 예외가 발생 되었을 때 어떤 값이 넘어오는지 명시적으로 표현합니다. @version 라이브러리의 버전 정보를 제공할 때 사용합니다.문법@param 처럼 태그를 열고 해당 줄에 정보를 기입합니다./** * Creates a new Circle from a diameter. * * @param {number} d The desired diameter of the circle. * @return {Circle} The new Circle object. */ const fromDiameter(d) = () =&amp;gt; { return new Circle(d / 2) }위 코드처럼 함수를 정의하시면 reates a new Circle from a diameter.라는 설명과 함께 함수의 파라미터, 리턴값 등이 보여지게 됩니다.예제/** @class Circle representing a circle. */class Circle {/** * Creates an instance of Circle. * * @author: moi * @param {number} r The desired radius of the circle. */ constructor(r) { /** @private */ this.radius = r /** @private */ this.circumference = 2 * Math.PI * r } /** * Creates a new Circle from a diameter. * * @param {number} d The desired diameter of the circle. * @return {Circle} The new Circle object. */ static fromDiameter(d) { return new Circle(d / 2) } /** * Calculates the circumference of the Circle. * * @deprecated since 1.1.0; use getCircumference instead * @return {number} The circumference of the circle. */ calculateCircumference() { return 2 * Math.PI * this.radius } /** * Returns the pre-computed circumference of the Circle. * * @return {number} The circumference of the circle. * @since 1.1.0 */ getCircumference() { return this.circumference } /** * Find a String representation of the Circle. * * @override * @return {string} Human-readable representation of this Circle. */ toString() { return `[A Circle object with radius of ${this.radius}.]` }}/** * Prints a circle. * * @param {Circle} circle */function printCircle(circle) { /** @this {Circle} */ function bound() { console.log(this) } bound.apply(circle)}" }, { "title": "평문을 HTML로 변환하기", "url": "/posts/text-to-html/", "categories": "Tech, Talk", "tags": "Javascript", "date": "2022-05-19 10:32:00 +0800", "snippet": "기능textarea 형태의 에디터에서 작성 된 글은 평문으로 작성됩니다.이를 HTML 문서에서 보여주게 된다면 줄내림 등의 양식이 적용되지 않기에, 이를 변환시켜주는 함수입니다.덤으로 https://www.naver.com 같은 링크가 들어오면 a 태그를 래핑하는 기능도 포함 되었습니다.코드/** text2html * 텍스트를 html 형태로 변환시킵니다. 줄내림, 링크 자동 변환 등을 지원합니다. * @author: 박 찬영 * @param {text} string * @return {html} string */const text2html = text =&amp;gt; { let html = text; html = uri2link(html); html = nl2br(html); return html;};export const uri2link = text =&amp;gt; { const linkRegex = /(http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&amp;amp;%@!\\-\\/]))?/gm; return text.replace(linkRegex, &#39;&amp;lt;a href=&quot;$1&quot;&amp;gt;$1&amp;lt;/a&amp;gt;&#39;);};export const nl2br = text =&amp;gt; { const nlRegex = /\\n/gm; return text.replace(nlRegex, &#39;&amp;lt;br /&amp;gt;&#39;);};export default text2html;" }, { "title": "Github Issue로 오픈소스 기여하기", "url": "/posts/comment-on-github-issues/", "categories": "Tech, Talk", "tags": "Github", "date": "2022-05-18 17:42:00 +0800", "snippet": "오픈소스오늘날의 IT업계는 수많은 오픈소스로 운영되고 있습니다.누군가는 자신의 커리어를 위해서, 누군가는 그저 취미로, 누군가는 돈을 벌기 위해서 오픈소스를 생성하고 사용합니다.결과물로 직접적인 수익을 낼 수 없음에도 불구하고 오픈소스 시장은 나날이 성장하며 많은 개발자들이 참여하고 있습니다.‘오픈소스’라는 이름을 들으면 좀 어려워보이고, 전문적인 기술을 요구할 것 같은 느낌이 듭니다.근데 사실 따지고보면 별거 없어요. 공개 되어 누구나 참여 가능한 소스코드일 뿐이기에, Github나 Gitlab에 레포 하나 만들고 printf(&quot;Hello world!&quot;) 하나 띄워놔도 오픈소스기 때문이예요.하지만 우리는 가급적 많은 사람들의 삶의 질을 높여주는 소스코드에 기여하고 싶어합니다.그렇다고해서 lodash나 react같은 킬러 라이브러리를 직접 맨땅에서부터 만들기는 많이 어렵죠. 더군다나 이미 뛰어난 실력자들이 개선하는 라이브러리이기 때문에 더 뭘 추가하기도 애매하거든요.그럼 우리는 어떻게 기여할 수 있을까요?IssueGithub나 Gitlab과 같은 버전 관리 플랫폼에는 Issue라는 기능이 있습니다.Pull Request처럼 직접 소스코드에 영향을 미칠 수 있는 기능은 아니지만, 이 라이브러리를 써보고 느낀 불편한 점, 개선 아이디어, 추가하면 좋을 기능 등을 제안하는 기능이예요.“에이 이게 어떻게 오픈소스 기여야”라고 생각하실 수도 있지만, Issue 작성도 충분한 기여에 포함됩니다. 오픈소스에서 가장 중요한건 사용자의 피드백이기 때문이예요.사례라이브러리 오동작 사례저는 바쁜 업무가 끝나고 당장에 할 일이 없으면 Github에서 오픈소스를 탐방하고, 더 나은 패턴이나 디렉토리 구조, 좋은 라이브러리를 찾아보는 편인데요.최근에는 아직 릴리즈 되지도 않은 Nuxt3에 빠져서 Nuxt3와 궁합이 좋은 라이브러리를 찾고 있었어요.그러던 와중, Varlet이라는 Vuetify 기반 모바일 친화적 라이브러리를 알게 되었고, 이를 이용하여 토이 프로젝트를 만들었어요.우여곡절 끝에 다 만들고 yarn generate 명령어를 입력하여 해당 서비스를 Static하게 빌드하려 했는데, 문제가 발생했습니다. ERROR Rollup error: Could not load raw:../../styles/common.css: ENOENT: no such file or directory, open &#39;../../styles/common.css&#39; nitro 14:11:48 ERROR Could not load raw:../../styles/common.css: ENOENT: no such file or directory, open &#39;../../styles/common.css&#39;갑자기 터미널에 이런 에러가 표시되었습니다.처음에는 제가 전역으로 import한 CSS 파일에서 발생하는 이슈인가 싶어서 이를 제거하고 빌드해봐도 마찬가지라서 도무지 원인을 알 수가 없었는데, 혹시나 싶어 varlet 라이브러리의 CSS Import 구문을 제거하고 빌드한 결과, 빌드가 정상적으로 동작하는 것을 알게 되었어요.import * as Varlet from &#39;@varlet/ui&#39;;import &#39;@varlet/ui/es/style.js&#39;; // &amp;lt;-- 이거export default defineNuxtPlugin((nuxtApp) =&amp;gt; { nuxtApp.vueApp.use(Varlet);});“아직 Nuxt3가 정식 릴리즈 되지 않았기 때문에 그런건가?” 싶다가도 공식 문서를 보아하니 Nuxt3도 지원하는 것 같더라구요.설치 방법이 잘못 됐나 싶어 해당 문서를 다시 꼼꼼히 읽어봐도 제가 이미 설정한 것에서 더 진행할 일이 없었어요.커뮤니티 탐색이런 경우에는 보통 StackOverflow에서 찾아보는 편인데, 자료가 나오질 않았습니다.이슈 탐색그렇다면 최종적으로 쓰는 방법인데, 라이브러리의 컨트리뷰터와 직접 얘기할 수 있는 창구로 찾아가는거죠.보통은 여기에 비슷한 경험을 한 다른 유저가 질문글을 올려놓거든요.하지만 검색을 해봐도 저와 비슷한 경험을 한 유저가 없었어요.이슈 작성없다면 제가 직접 물어봐야겠죠?레포지토리의 Issue 페이지에 접속하면 아래와 같은 화면이 표시됩니다.우측 상단 [New Issue]를 누르면 이슈를 작성할 수 있어요.보통 오픈소스는 많은 사람들의 참여를 전제로 만들기 때문에 균일한 포맷을 유지하기 위해 Template을 적용하고 있어요.템플릿이 있다면 아래와 같이 목록이 표시 될텐데, 지금 상황에 맞는 템플릿을 골라주세요. (템플릿이 없으면 이 화면이 안뜰거예요.)마지막으로는 Template 양식에 맞춰서 궁금한 점을 물어보시면 됩니다.만약 Template이 없다면 자유 양식으로 최대한 보기 좋게 적어주시는게 매너겠죠?이런 과정을 통해 내가 해결 못한 이슈에 대한 글을 작성했습니다!결과원했던 해결 방법을 알아냈을 뿐 아니라, “우리의 문서에 실수가 있었습니다. 곧 수정하겠습니다. 피드백 감사합니다!” 라는 답변까지 받았습니다.추후에 어떻게 될지는 모르겠지만 또 다른 누군가가 겪었을 수도 있는, 혹은 겪을 문제를 공론화해서 해당 오픈소스의 개발 계획에 영향을 미치게 되었죠. 더군다나 Github Star가 2,700개인 거대 프로젝트에 말이죠!어때요? 아직도 단순 Issue제기는 오픈소스 기여가 아니라고 생각하시나요?어렵게만 생각하지 마시고 한번 도전해보세요!" }, { "title": "텍스트 안에 있는 URL에 하이퍼링크 적용하기", "url": "/posts/get-url-in-text/", "categories": "Tech, Talk", "tags": "Regexp", "date": "2022-05-17 12:55:00 +0800", "snippet": "개요네이버 블로그, 티스토리 등 고급 에디터를 지원하는 서비스에는 게시글을 작성할 때 링크를 포함시키면 해당 링크에 &amp;lt;a&amp;gt; 태그가 자동으로 걸리는 기능이 있습니다.이 기능을 구현하기 위해서는 평문 속 URI를 찾고, replace 시켜야 합니다.소스코드&amp;lt;template&amp;gt; &amp;lt;div class=&quot;index&quot;&amp;gt; &amp;lt;div class=&quot;html&quot; v-html=&quot;html&quot; /&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { defineComponent } from &#39;vue&#39;;export default defineComponent({ name: &#39;HomePage&#39;, setup () { const text = ref(&#39;안녕하세요? https://www.naver.com 입니다. https://www.google.com 은 어떠세요?&#39;); const html = computed(() =&amp;gt; { const link = new RegExp(/((https|http):\\/\\/(\\w+(\\.?))+)/, &#39;gm&#39;); return text.value.replace(link, &#39;&amp;lt;a href=&quot;$1&quot;&amp;gt;$1&amp;lt;/a&amp;gt;&#39;); }); return { html }; }});&amp;lt;/script&amp;gt;위와 같이 작성하면 text 변수 안에 있는 텍스트에서 ((https|http):\\/\\/(\\w+(\\.?))+) 형태로 작성 된 텍스트를 탐색하고, &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;로 감싸게 됩니다." }, { "title": "내가 쓰는 Nuxt3 ESLint 설정", "url": "/posts/nuxt3-eslint/", "categories": "Tech, Nuxt", "tags": "Nuxt3, ESLint", "date": "2022-05-17 09:50:00 +0800", "snippet": "패키지 설치yarnyarn add -D eslint eslint-plugin-vue typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser vite-plugin-eslint @nuxtjs/eslint-config-typescriptnpmnpm i -D eslint eslint-plugin-vue typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser vite-plugin-eslint @nuxtjs/eslint-config-typescript.eslintrc{ &quot;env&quot;: { &quot;browser&quot;: true, &quot;es2021&quot;: true, &quot;node&quot;: true }, &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:vue/vue3-essential&quot;, &quot;plugin:@typescript-eslint/recommended&quot;, &quot;@nuxtjs/eslint-config-typescript&quot; ], &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, &quot;sourceType&quot;: &quot;module&quot; }, &quot;plugins&quot;: [ &quot;vue&quot;, &quot;@typescript-eslint&quot; ], &quot;rules&quot;: { &quot;brace-style&quot;: [&quot;error&quot;, &quot;1tbs&quot;], &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;vue/no-v-model-argument&quot;: &quot;off&quot;, &quot;vue/component-tags-order&quot;: [ &quot;error&quot;, { &quot;order&quot;: [&quot;style&quot;, &quot;template&quot;, &quot;script&quot;], } ], }}" }, { "title": "em과 rem의 차이", "url": "/posts/em-and-rem-diffrence/", "categories": "Tech, Talk", "tags": "CSS", "date": "2022-05-16 10:37:00 +0800", "snippet": "개요CSS는 DOM에 style을 적용해주기 위한 언어입니다.그러다보니 화면을 구성하는 DOM에 적절한 길이를 적용하기 위해 다양한 길이 단위를 사용합니다.대표적으로 사용되는 길이 단위는 px, em, rem 등이 있는데, px의 경우는 그 역할이 굉장히 직관적입니다.입력하는 길이만큼 크기가 지정되고 그게 끝이기 때문이예요.그런데 em과 rem은 뭘까요?상대적 길이 단위em과 rem은 모두 상대적인 길이 단위를 나타냅니다.그 대상은 상위 객체로, 상위 객체에 적용 된 크기에 기준하여 자동으로 사이즈를 재조정 해줍니다.20px: 1em = 1rem = 20px20px: 0.5em = 0.5rem = 10px20px: 1.5em = 1.5rem = 30px위에서 언급했듯, em과 rem은 상대적인 길이를 갖기 때문에 기준에서 해당 길이를 곱하여 반환되는 값이 적용됩니다.차이점그렇다면 em과 rem은 얼핏 보기에 차이가 없어보입니다.일반적인 경우에는 이 둘의 차이를 알기 힘든데, 결정적인 차이는 상위 객체에 대한 기준이 다릅니다.em은 해당 길이가 적용 된 객체의 직계 부모의 길이를 기준으로 변하는 반면, rem은 DOM Tree에서 가장 상단에 있는 객체의 길이를 기준으로 변화합니다.일반적인 웹 문서에서 최상위 객체라면 &amp;lt;html&amp;gt;이 될텐데, rem은 이 &amp;lt;html&amp;gt; 객체의 길이를 기준으로 환산합니다.그래서?만약 CSS 경험이 적고, CSS간 영향을 미치는 범위를 정확히 확신할 수 없다면 rem을 사용하는 것을 추천합니다.em은 길이 환산에 영향을 미치는 변수들이 많고, 추후 DOM Tree가 바뀌게 될 경우 이에 대한 핸들링을 하기가 상대적으로 까다롭기 때문에, 길이에 영향을 미치는 객체가 단순한 rem이 사용성 측면에서는 더욱 간단하기 때문입니다.예시Sandbox에서 예시 코드를 확인하실 수 있습니다." }, { "title": "Vue3에서 사용되는 상태 관리자, Pinia", "url": "/posts/about-pinia/", "categories": "Tech, Vue", "tags": "Pinia", "date": "2022-05-14 22:06:00 +0800", "snippet": "PiniaPinia는 Composition API 기반에서 동작하는 상태 관리자입니다.여태까지 Vue에서 사용되던 가장 보편적이고 유명한 상태 관리자는 Vuex였습니다.그런데 Vue의 개발자, Even You는 본인의 트위터에서 Vuex 5와 Pinia는 사실상 완전 동일한 프로젝트로 생각해야 한다고 말한 바 있습니다.Vuex 5에서 원하던 기능들의 대부분을 이미 Pinia에서 지원하고 있었기에, Vuex 프로젝트를 유지하는 대신 Pinia를 공식적으로 지원한다고 Pinia의 공식 문서에 적혀 있습니다.차이점Vuex를 버리고 Pinia를 써야하는 이유에는 어떤 것들이 있을까요?Typescript 지원Vuex에서Vuex를 이용하여 프로젝트를 구성해보신 적이 있으시다면, Vuex의 상태와 매칭되는 타입 정의가 매우 까다롭다고 생각하셨을 겁니다. Vuex는 module을 지원한다. module은 대부분 각각의 파일에서 구현부가 작성된다. 컴포넌트에서 store를 접근할 때는 this.$store를 통해 Vue의 Prototype에 정의 되어있는 $store객체를 통해 접근한다.위와 같은 형태로 Vuex를 이용하기 때문에 사실상 뿔뿔이 흩어져있는 module 파일들에 대한 state 타입을 추론하는게 어렵습니다.그래서 vuex를 이용하면서 타입 추론도 하려면 아래와 같은 몇가지 과정을 거쳐야합니다.// vuex.d.tsimport { Store } from &#39;vuex&#39;declare module &#39;@vue/runtime-core&#39; { // declare your own store states interface State { count: number } // provide typings for `this.$store` interface ComponentCustomProperties { $store: Store&amp;lt;State&amp;gt; }}일단, 상태가 하나 추가 및 수정 될 때마다 타입 추론을 위해 state의 구조를 나타내는 d.ts 파일을 별도로 작성합니다.import type { StateType as AType } from &#39;./A&#39;;import type { StateType as BTYpe } from &#39;./B&#39;;export type RootState = { A: AType, B: BType,};또한, RootState를 얻기 위해 필요하지도 않은 index.ts 파일을 만들어서 모든 module을 하나로 연결시켜줄 구심점을 구성해야 하며import type { RootState } from &#39;./index&#39;;export const actions: ActionTree&amp;lt;StateType, RootState&amp;gt; = { // ...actions};모듈을 만들고 Action을 하나 정의할 때마다 ActionTree의 Generic에 전달할 RootState를 index.ts로 부터 끌고 와야 한다는 점이 있습니다.물론 이 모든 과정은 최초 한 번만 하면 되는게 아니라 어떤 Module의 State가 변하거나 추가되면 다시 해야합니다!그래서 저는 Vue2 + Vuex + Typescript 환경에서 개발할 일이 있을 때는 Vuex에 대한 타입 추론은 아예 포기하고 this.$store를 any로 정의하여 구현한 적도 있습니다.Pinia에서Pinia는 defineStore라는 함수를 이용하여 각각의 파일마다 별도의 store를 정의하여 module의 기능을 대신합니다.vuex의 this.$store와는 달리 pinia는 defineStore가 반환하는 hook을 이용하여 store에 아주 쉽게 접근할 수 있습니다.그렇기에, 반환 된 hook은 내부 구성 요소에 대한 타입을 포함하고 있으며, 타입 추론에 대한 그 어떤 작업도 추가로 필요하지 않습니다.import { defineStore } from &#39;pinia&#39;;export const useCart = defineStore(&#39;cart&#39;, { state: () =&amp;gt; ({ items: [], }), actions: { addItem(item: ItemType) { this.items.push(item); }, },});cart.ts 파일을 정의하면, 실제 프로젝트에서는 아래와 같이 사용할 수 있습니다.&amp;lt;script type=&quot;ts&quot;&amp;gt;import { defineComponent } from &#39;vue&#39;;import { ItemType, useCart } from &#39;@/store/cart&#39;;export default defineComponent({ name: &#39;HomePage&#39;, setup () { const cart = useCart(); // cart.items, cart.addItem return { cart, }; }});&amp;lt;/script&amp;gt;defineStore 함수가 반환한 커스텀 hook인 useCart를 이용하여 선언만 한다면 state, actions가 모두 변수 cart에 객체로 할당되는 것을 보실 수 있습니다.구성요소Vuex에서Vuex는 아래와 같은 구성요소를 갖습니다. namespace module을 별도의 name으로 분리하여 관리할 것인지를 정의하는 프로퍼티 state 모듈 하나에 하나만 보유 가능 해당 모듈에서 보관할 상태값의 집합 mutation state를 변환할 수 있는 사실상 유일한 방법 비동기 로직을 처리할 수 없으며, mutation 함수의 첫번째 인자로 현재 state 값을 가져올 수 있다. getter state값을 단순히 반환하기만 하는 함수의 집합 state값의 수정이 불가능하며, 특정 규칙에 따라 필터링 된 state를 얻을 때 요긴하게 사용된다. actions 비동기 처리가 가능하며, state를 변환할 때 쓰는 함수의 집합 직접적으로 state를 변환할 수는 없으며, commit 함수를 통해 mutation을 호출하여 수정이 가능하다. Pinia에서Pinia는 아래와 같은 구성요소를 갖습니다. state store하나에 하나만 보유 가능 해당 store에서 관리 될 상태값의 집합 actions state를 변환할 때 사용하는 함수의 집합 비동기 처리가 가능하며, vuex와는 다르게 직접 state의 값을 제어할 수 있다. getter state값을 단순히 반환하기만 하는 함수의 집합 state값의 수정이 불가능하며, 특정 규칙에 따라 필터링 된 state를 얻을 때 요긴하게 사용된다. Vuex와는 다르게 mutation이 제거되고 actions에서 상태를 모두 제어합니다.이로 인해 actions에서 state를 제어하기 위해 mutation을 일일히 만들지 않아도 됩니다.또한, module이라는 개념이 사라지고, 개별적인 store로 관리 되기에 namespace도 없어집니다.SFC 문법 지원Vuex에서SFC 문법을 지원하지 않습니다.Pinia에서Pinia는 Composition API를 지원합니다.그러므로, Vuex와 같은 구조로 정의하지 않고, SFC의 setup을 정의할 때와 동일하게 사용할 수 있습니다.export const useCart = defineStore(&#39;cart&#39;, () =&amp;gt; { const items: ItemType[] = reactive([]); /** * items 배열에 item을 추가합니다. * @param item */ const addItem = (item: ItemType) =&amp;gt; { items.push(item); }; /** * items 배열에 들어있는 item을 name을 기준으로 변경합니다. * count 프로퍼티는 예외적으로 기존 값에 추가됩니다. * @param name * @param item * @returns */ const updateByName = (name: string, item: ItemType) =&amp;gt; { const index = items.findIndex(i =&amp;gt; i.name === name); if (index &amp;lt;= -1) { return; } const original = items[index]; items.splice(index, 1, { ...original, ...item, count: original.count + item.count }); }; return { items, addItem, updateByName };});이처럼 state, actions, getters 등을 명시적으로 구분하지 않아도, ref, reactive. computed와 같은 Composition API Hooks를 이용하여 setup API를 사용하는 SFC와 완전히 동일한 형태로 구현해도 아주 자연스럽게 동작합니다.심지어 특정 상태값의 변이를 트래킹하기 위해 watch를 사용할 수도 있습니다!요구사항Pinia는 Vue3 혹은 Vue2 + Composition API 환경에서만 동작합니다.예시 프로젝트여기를 보시면 Nuxt3 + Pinia + Element UI를 통해 제작한 아주 간단한 형태의 장바구니 프로젝트를 보실 수 있습니다." }, { "title": "Glob 패턴", "url": "/posts/glob-pattern/", "categories": "Tech, Talk", "tags": "Glob", "date": "2022-05-12 09:32:00 +0800", "snippet": "Glob 패턴Glob 패턴은 특정 경로, 특정 이름을 가진 파일들을 선택하기 위해 사용하는 패턴입니다.이는 와일드카드 문자로 이루어져 있습니다.예시{ &quot;include&quot;: [ &quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;, &quot;src/types/*.d.ts&quot; ]}타입스크립트 관련 명세를 작성하기 위한 json 파일을 예시로 들 수 있는데, 프로젝트에 포함할 type.d.ts 파일들을 자동으로 include하기 위해 사용합니다.패턴 예시 * /를 제외한 문자열과 매칭 ex) src/types/*/index.d.ts src/types/example01/index.d.ts src/types/example02/index.d.ts src/types/example03/index.d.ts ** /를 포함한 문자열과 매칭 ex) src/types/**/index.d.ts src/types/example01/example012/index.d.ts src/types/example02/index.d.ts ? /를 제외한 한 글자만 매칭 [xyz] 괄호 안에 들어간 각각의 글자와 매칭 {example01, example02, example03} 괄호 안에 들어간 각각의 문자열과 매칭 모든 패턴그 외 자세한 패턴은 여기를 참조해주세요.레퍼런스Hugo.log - Glob 패턴과 정규표현식" }, { "title": "Vite 환경에서 .env 활용하기", "url": "/posts/vite-enviroment-variables/", "categories": "Tech, Vue", "tags": "Vite, Vue", "date": "2022-05-10 17:37:00 +0800", "snippet": "Vitevite는 번들러의 일종입니다.ES6 문법을 따르기에 Webpack보다 상대적으로 빠른 것이 장점이예요.Vue3와 Nuxt3는 기본적으로 Vite를 지원하도록 설계되어 장래성이 뛰어난 개발도구입니다.Environment VariablesEnvironment Variables는 프로젝트 내에서 사용할 환경변수입니다.환경변수란, 현재 프로젝트의 구동 환경 및 서버 도메인 등 환경설정에 관한 변수를 말합니다.NodeJS 환경에서 무언가를 개발하신적이 있다면 한번 쯤 환경변수를 써보신적이 있으실텐데, 개발모드 / 프로덕션모드를 구분짓기 위하여 process.env.NODE_ENV를 사용해보셨다면 환경변수를 사용해보신 경험이 있으신겁니다.배경저는 여태까지 Vue2를 메이저 프레임워크로 사용했기 때문에 process.env로 환경변수를 사용했습니다.그런데 이번에 토이 프로젝트를 Vue3 + Vite 환경으로 제작하던 도중 process.env를 사용하니 process is not defined 에러가 뜨기 시작했습니다.직감적으로 “번들러가 바뀌어서 그런가?”라고 생각 되었고, vite에서 환경변수를 설정하는 방법을 찾기 시작했습니다.Vite에서 환경변수 설정하기환경변수 디렉토리 설정 본 섹션은 여기를 참조했습니다.module.exports = { envDir: &#39;./src/env&#39;,}vite.config.js 파일에서 envDir 프로퍼티를 활용하여 .env 파일이 저장 될 디렉토리를 설정합니다.위 코드대로라면 src/env 폴더 안에 .env 파일을 생성해주면 되겠네요!환경변수 파일 생성Vite는 다양한 상황에서 능동적으로 대응할 수 있도록 다양한 타입의 .env 파일을 지원합니다..env # 모든 상황에서 로드되는 기본 파일.env.local # 로컬에서만 갖고있는 파일입니다. Git에 업로드하는 과정에서 제외됩니다..env.[mode] # 프로젝트가 실행 된 환경에 따라 로드 됩니다..env.[mode].local # 프로젝트가 실행 된 환경에 따라 로드 됩니다. 로컬에만 존재하며, Git에 업로드하는 과정에서 제외됩니다..env 파일은 어떤 상황에서나 읽을 수 있는 환경변수를 기재할 수 있습니다..env.[mode]는 development 혹은 production와 같은 프로젝트의 구동 환경에 따라 서로 다른 환경 변수를 할당하려 할 때 사용합니다. import.meta.env.MODE에 따라서 .env.[MODE]가 할당 되며, 이렇게 할당 된 환경변수는 .env 파일로 선언 된 환경변수보다 더 높은 우선순위를 차지합니다.환경변수 정의GITHUB_REPOSITORY_URI = &quot;https://github.com/univdev/text-generator&quot;VITE_API_SERVER = &quot;https://example.com/api&quot;변수명 = &quot;값&quot; 문법대로 작성하시면 해당 이름의 환경변수를 사용하실 수 있습니다. 다만, Vite로 구동되는 실제 프로젝트에서 사용하기 위해서는 환경변수명 앞에 VITE_를 반드시 붙여주셔야 합니다.접두사 VITE_를 붙이지 않을 경우, VITE가 참조할 수 없는 환경 변수가 됩니다.실제로 사용하실 때는 import.meta.env.VITE_API_SERVER로 사용하실 수 있습니다.타입스크립트 정의interface ImportMetaEnv { readonly VITE_API_SERVER: string}interface ImportMeta { readonly env: ImportMetaEnv}위와 같이 d.ts 파일을 정의해주면 VSCode에서 타입 추론이 가능해집니다.{ &quot;include&quot;: [ &quot;src/types/*.d.ts&quot; ],}만약 d.ts 폴더가 정의가 되어있지 않다면 tsconfig.json 파일에서 위와 같이 정의해야 합니다.예시에서는 src/types 폴더 안에 파일을 정의했으니 src/types/*.d.ts로 include 했습니다." }, { "title": "Tauri로 시작하는 Desktop App 개발 생활", "url": "/posts/about-tauri/", "categories": "Tech, Talk", "tags": "Tauri", "date": "2022-05-09 17:40:00 +0800", "snippet": "TauriTauri는 웹으로 Desktop App을 빌드할 수 있는 툴킷입니다.Desktop App을 Build하기 위한 툴킷으로는 Electron이 유명하고 이미 널리 사용되고 있습니다.그렇지만 Electron은 태생부터 갖고있던 단점들이 존재하며, 이를 해결하기 위해 출시 된 것이 Tauri입니다.Electron VS Tauri출처: https://betterprogramming.pub/will-tauri-be-an-electron-killer-38fd6478004퍼포먼스실행 속도, 설치파일 사이즈, 번들 사이즈 등 모든 측면에서 Tauri가 Electron을 압도합니다.실제 프로덕션에서도 같은 결과를 보여줄지는 봐야 알겠지만 수치상 표현에서는 월등히 앞서네요.또한, Tauri는 Webview를 자체 개발한 WRY를 사용한다는 점도 런타임 퍼포먼스에 상당한 이점을 가져다줍니다.Chromium을 사용하는 Electron은 자체적으로 Chrome 브라우저를 내장하고 있기 때문에 기본적으로 브라우저만큼의 사이즈를 먹고 들어가는 반면, Tauri의 WRY는 브라우저를 자체적으로 내장한 것이 아닌 OS에 내장 되어있는 기본 브라우저에 붙여주는 접착제의 역할만을 하기 때문에 번들 사이즈가 매우 가볍습니다. 그렇기에 Tauri로 Build 된 앱을 실행하면 Mac은 Safari, Windows는 Edge로 실행되는 것을 보실 수 있습니다.모바일 기기 지원현재는 Electron Tauri 모두 모바일 기기를 지원하지 않습니다.다만 Electron은 아예 모바일 관련 언급이 없는 반면, Tauri는 로드맵에서 Mobile Build에 대한 지원을 약속한 바 있습니다.코멘트를 보면 1년 뒤에 지원이 가능할 것 같다고 적혀있는걸 봐서 22년 2분기를 예상하지만 확정은 아닙니다.하지만 Mobile Build에 대한 언급이 있다는 것 자체만으로 매우 굉장한 일이며, 추후에는 현재 React Native가 맡고있는 하이브리드 어플리케이션의 영역을 완전히 가져올 수도 있는 엄청난 가능성을 내포합니다.설치 가이드Rust Cargo 설치https://doc.rust-lang.org/cargo/getting-started/installation.htmlTauri로 프로젝트를 실행 / 빌드하기 위해서는 Cargo를 설치해야 합니다.curl https://sh.rustup.rs -sSf | sh위 명령어를 Terminal에 입력 후 실행합니다.웹 프로젝트가 이미 있는 경우yarn add -D @tauri-apps/cli# ORnpm install -D @tauri-apps/cli프로젝트의 최상위 폴더에서 위 명령어를 입력하여 @tauri-apps/cli를 설치합니다.{ &quot;scripts&quot;: { &quot;tauri&quot;: &quot;tauri&quot; }}package.json 파일의 scripts에 위 명령어 세트를 추가합니다.yarn add @tauri-apps/api# ORnpm install @tauri-apps/api만약 프로젝트가 webpack이나 vite를 이용하여 동작한다면 위 명령어를 입력해주세요.Vue 프로젝트로 시작하기https://github.com/tauri-apps/vue-cli-plugin-tauri최선의 방법은 vue-cli-plugin-tauri를 이용하는 것입니다.vue create my-tauri-app위 명령어로 ```Vue`` 프로젝트를 개설합니다.cd my-tauri-appvue add tauri만들어진 Vue 프로젝트의 root에서 vue add tauri 커맨드를 입력하여 tauri를 설치합니다.이 경우에는 알아서 package.json에 scripts를 설정해주기 때문에 명령어를 수동으로 입력할 필요가 없습니다.실행Vue CLI를 사용하지 않은 경우yarn tauri dev위 명령어를 이용하여 개발 모드를 실행할 수 있습니다.다만, 실제 프로젝트와 연결되어 있는것은 아니기 때문에 yarn dev 명령어를 통해 개발서버를 별도로 켠 다음에 위 명령어를 실행해야 합니다.yarn tauri build빌드는 위 명령어로 진행합니다.기본적으로는 프로젝트 폴더 내 dist 디렉토리 안에 있는 빌드 된 파일들을 래핑하여 실행파일을 제작합니다.만약 빌드 파일이 다른 폴더에 생성된다면 해당 폴더의 경로를 설정해야 합니다.Vue CLI를 사용한 경우yarn tauri:serveTauri를 이용하여 프로젝트를 개발모드로 실행합니다.yarn dev 명령어 없이도 서버를 자동으로 실행해줍니다.yarn tauri:buildTauri를 이용하여 빌드합니다.크로스 플랫폼 빌드Tauri는 기본적으로 멀티 플랫폼을 지원하지만 빌드를 하나의 플랫폼에서 진행할 수는 없습니다.공식 문서를 보시면 아래와 같이 적혀있습니다. 지금은 Cross Platform 빌드를 지원하지 않습니다. 만약 당신이 Cross Platform 빌드를 원한다면 VM을 사용하거나, Github Actions를 사용해야 합니다.현재 빌드가 가능한 항목은 아래와 같습니다.Windows: .exe, .msi, .msi.zipmacOS: .app, .dmg, .app.tar.gzLinux: .deb, .AppImage, .AppImage.tar.gz마치며Tauri 상대적으로 빠르다. 상대적으로 가볍다. 대부분의 프론트엔드 프레임워크(Vue.js, React, Svelte)와 호환된다. 커뮤니티가 아직 작다. 기능을 심화적으로 사용하고 싶다면 Rust를 배워야 한다. Electron 상대적으로 무겁고 느리다. (그래도 빠른편임) 역사가 오래되어 커뮤니티가 방대하고, 예시 프로젝트도 많다. NodeJS 생태계에 있다보니 러닝커브가 매우 낮다." }, { "title": "[Vue] Cannot find module &#39;...&#39; or its corresponding type declarations.", "url": "/posts/vue-typescript-without-extension/", "categories": "Tech, Vue", "tags": "Vue", "date": "2022-04-26 15:30:00 +0800", "snippet": "이슈&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;&amp;lt;template&amp;gt; &amp;lt;div class=&quot;app&quot;&amp;gt; &amp;lt;atom-button&amp;gt;&amp;lt;/atom-button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { defineComponent } from &#39;vue&#39;;import AtomButton from &#39;@/components/atoms/Button&#39;;export default defineComponent({ components: { AtomButton, },});&amp;lt;/script&amp;gt;Cannot find module &#39;@/components/atoms/Button&#39; or its corresponding type declarations.Typescript Vue 프로젝트에서 .vue 없이 파일을 import하려고 하면 위와 같은 이슈가 발생합니다.해결declare module &#39;*.vue&#39; { import type { DefineComponent } from &#39;vue&#39; const component: DefineComponent&amp;lt;{}, {}, any&amp;gt; export default component}src 폴더 안에 shims-vue.d.ts 파일을 생성하고, 해당 파일에 .vue 파일에 대한 타입을 정의합니다.위 코드는 Vue3에서 사용할 수 있으며, Vue2는 아래 코드를 사용해야 합니다.declare module &quot;*.vue&quot; { import Vue from &#39;vue&#39; export default Vue}" }, { "title": "[Vue] 절대 경로 import", "url": "/posts/vue-absolute-path/", "categories": "Tech, Vue", "tags": "Vue", "date": "2022-04-26 15:13:00 +0800", "snippet": "절대 경로절대 경로에 대한 자세한 설명은 이 문서를 참고해주세요!절대 경로 추가import { defineConfig } from &#39;vite&#39;;import vue from &#39;@vitejs/plugin-vue&#39;;const path = require(&#39;path&#39;);// https://vitejs.dev/config/export default defineConfig({ plugins: [vue()], resolve: { alias: { &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;), }, },})만약 Vite로 설치하지 않으신 분들은 vue.config.js 파일을 확인해주세요.VSCode 자동완성 설정위 설정만 한다면 파일을 import할 수 있지만, VSCode는 이를 인지하지 못하기 때문에 경로를 자동으로 완성해주지 않습니다.{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;./src/*&quot;], } }}만약 Typescript 프로젝트가 아니라면 jsconfig.json에 정의해주세요.위 코드를 작성해주시면 VSCode도 절대 경로를 인식할 수 있습니다." }, { "title": "&#39;구르미랑 반모&#39; i18n(국제화) 적용기", "url": "/posts/nuxt-i18n-review/", "categories": "Tech, Talk", "tags": "i18n", "date": "2022-04-25 16:27:00 +0800", "snippet": "i18n i18n은 Internatinalization의 약자입니다. ‘아이에이틴엔’ 혹은 ‘아이엷여덜엔’ 등으로 발음합니다.국제화란, 인터넷 서비스 등이 특정 국가나 시장에 진출하기 위해여 대상 문화권 사람들이 어려움 없이 서비스를 이용할 수 있도록 하는 작업입니다.디자인, 번역, 텍스트 진행방향 변경 등이 모두 국제화 과정에 포함 됩니다.개요회사에서 개발중인 서비스, ‘구르미랑 반모’ 서비스의 브랜드 페이지가 국제화 대상 서비스입니다.본래 해당 프로젝트는 텍스트가 정적으로 소스코드에 포함 되어 작성 되었으나, 영어권 국가 서비스 론칭을 위해 국제화 작업이 필요하다는 기획팀의 요구사항이 있었습니다.@nuxtjs/i18n사용 이유본 프로젝트는 SEO 최적화를 위해 Nuxtjs로 개발 되어 있었기에 Nuxtjs 환경에서 사용할 수 있는 국제화 라이브러리가 필요했습니다.그래서 몇 분 간의 인터넷 서핑 결과 Nuxtjs 전용으로 포팅 된 @nuxtjs/i18n 모듈을 발견하게 되었고, 이를 적용하였습니다.초기 설정우선 한국어 언어팩을 만들어야 합니다.lang/ko.js 파일을 만들고, 아래와 같이 작성합니다.export default { pages: { main: { first: { caption: &#39;반려인의 하나된 마음&#39;, title: &#39;건강하고 행복하게&amp;lt;br&amp;gt;오랫동안 함께하는 반려생활&#39;, }, } }, // 실제 언어팩의 일부 발췌};한국어 언어팩을 만들었다면 각국의 언어팩을 통합으로 관리 할 index.js 파일을 작성합니다.앞으로 새로운 국가의 언어팩이 추가 된다면 이 페이지에서도 해당 파일을 import하여 export해야 합니다.import ko from &#39;./ko&#39;;export default { ko,};그 다음 언어팩과 @nuxtjs/i18n 모듈을 연결하기 위해서 nuxt.config.js 파일에 아래와 같이 작성합니다.import messages from &#39;./lang&#39;;export default { modules: [ // ... &#39;@nuxtjs/i18n&#39;, ], i18n: { detectBrowserLanguage: { // 브라우저의 언어 설정에 맞춰 기본 언어를 설정함 useCookie: false, // true면 언어 설정에 관한 내용을 쿠키에 저장하여 할당할 수 있음 }, defaultLocale: &#39;ko&#39;, // 기본 언어 설정 (한국어) locales: [ // 지원할 언어의 명세를 작성합니다. 한국어와 영어만 지원할 예정이니 ko, en을 작성했습니다. { code: &#39;ko&#39;, name: &#39;KOR&#39;, iso: &#39;ko-KR&#39;, dir: &#39;ltr&#39; }, { code: &#39;en&#39;, name: &#39;ENG&#39;, iso: &#39;en-US&#39;, dir: &#39;ltr&#39; }, ], vueI18n: { fallbackLocale: &#39;ko&#39;, // 만약 설정 된 국가코드와 매칭되는 언어팩 데이터가 없다면 대체어로 한국어 언어팩에서 데이터를 추출합니다. messages, // 위에서 작성한 lang/index.js를 messages라는 key로 할당합니다. }, },};이렇게 하면 기본적인 i18n 모듈 설정이 끝났습니다.사용해보기이제 실제 페이지에 정적으로 기입 되어 있는 텍스트를 동적으로 변경합니다.&amp;lt;template lang=&quot;pug&quot;&amp;gt; section.content-wrap .main-row-box.st-main-01 .inner-base-box p.p1.wow.fadeInLeft(data-wow-delay=&#39;.5s&#39;) 반려인의 하나된 마음&amp;lt;/template&amp;gt;&amp;lt;!-- 실제 프로젝트의 코드 일부 발췌 --&amp;gt;기존에 이렇게 정적으로 기입되어 있던 텍스트를 아래와 같이 변경해야 합니다.&amp;lt;template lang=&quot;pug&quot;&amp;gt; section.content-wrap .main-row-box.st-main-01 .inner-base-box p.p1.wow.fadeInLeft(data-wow-delay=&#39;.5s&#39;) {{ $t(&#39;pages.main.first.caption&#39;) }}&amp;lt;/template&amp;gt;&amp;lt;!-- 실제 프로젝트의 코드 일부 발췌 --&amp;gt;위 코드는 아래와 같은 구조의 언어팩에서 해당 텍스트를 가져오는 것을 의미합니다.export default { pages: { main: { first: { caption: &#39;반려인의 하나된 마음&#39;, }, }, },};설정 언어 변경언어팩을 적용했으니 활성화 하고싶은 언어팩을 설정할 수 있는 기능이 필요할 수 있습니다.본 프로젝트에는 우측 상단에 아래와 같은 버튼을 배치했습니다.설정할 수 있는 언어팩 목록 불러오기export default { computed: { locales() { return this.$i18n.locales; }, },};computed Property를 활용하면 nuxt.configs.js에서 설정했던 locales를 Array 형태로 불러올 수 있습니다.&amp;lt;template lang=&quot;pug&quot;&amp;gt; .lang-box a( v-for=&quot;(locale, key) in locales&quot; :key=&quot;key&quot; href=&quot;#&quot; @click.prevent.stop=&quot;onChangeLanguage(locale.code)&quot;) {{ locale.name }}&amp;lt;/template&amp;gt;불러온 locales 정보를 기반으로 UI를 배치합니다.그런데 단순히 UI를 배치하는 것뿐 아니라 선택 된 언어에 대응되는 버튼에 특수 효과를 부여하고 싶을 수 있습니다.export default { computed: { currentLocale() { return this.$i18n.locale; }, },};$18n.locale Property에는 현재 선택 된 언어의 code 정보가 담겨 있습니다.이를 기반으로 class를 할당하여 특수 효과를 넣을 수 있습니다. 아래와 같이 말이죠.&amp;lt;template lang=&quot;pug&quot;&amp;gt; a( v-for=&quot;(locale, key) in locales&quot; :key=&quot;key&quot; :class=&quot;{ &#39;on&#39;: locale.code === currentLocale }&quot; href=&quot;#&quot; @click.prevent.stop=&quot;onChangeLanguage(locale.code)&quot;) {{ locale.name }}&amp;lt;/template&amp;gt;그럼 이제 언어를 변경할 수 있는 UI도 만들었으니 실제로 언어를 변경할 수 있게끔 해줘야겠죠?export default { methods: { onChangeLanguage(code) { this.$i18n.setLocale(code); }, },}$18n.setLocale Method를 사용하시면 매개변수로 전달 된 코드에 맞는 언어팩으로 변경 됩니다.그런데 $i18n.setLocale 함수를 사용하고나면 언어를 변경할 때 URI의 Segment 부분이 좀 특이하게 바뀝니다.기존에는 /usage 페이지로 되어 있었는데 $i18n.setLocale(&#39;en&#39;)을 사용하니까 /en/usage로 변경된 것을 볼 수 있습니다.@nuxtjs/i18n 모듈은 설정 된 언어 코드에 기반해서 URI를 자동적으로 매핑해줍니다. (검색엔진 최적화를 위해서예요!)아주 만약, 언어팩 설정에 따라 동일한 페이지의 경로를 다르게 보여주고 싶다면 이 방법을 고려해보실 수도 있어요.nuxt-link 수정하기기존에 작성 된 nuxt-link로 네비게이션을 이용하여 /en/usage 페이지에서 /en/careticons 페이지로 이동하고자 했는데 네비게이션을 클릭하니까 en/usage에서 /careticons 페이지로 이동하는 문제가 발견되었습니다.&amp;lt;template&amp;gt; &amp;lt;nuxt-link v-for=&quot;locale in availableLocales&quot; :key=&quot;locale.code&quot; :to=&quot;switchLocalePath(locale.code)&quot;&amp;gt;{{ locale.name }}&amp;lt;/nuxt-link&amp;gt;&amp;lt;/template&amp;gt;공식 문서를 참고하니 switchLocalePath라는 함수를 이용해야 하는 것 같습니다.그런데 이미 모든 페이지에서 네비게이션을 사용하고 있기에 이를 모두 수정하기는 매우 번거롭고, nuxt-link 태그마다 switchLocalePath 함수를 사용하여 경로를 래핑해주는 것도 별로 보기 좋지 않습니다.그렇기에 switchLocalePath 함수를 기본적으로 래핑해주는 컴포넌트를 따로 만들어야 합니다.components/I18nLink.vue 파일을 만들고, 아래와 같이 작성해줍니다.&amp;lt;template lang=&quot;pug&quot;&amp;gt; nuxt-link( v-bind=&quot;{ ...$attrs, ...$props }&quot; :to=&quot;localePath(to)&quot;) slot&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default { props: { to: { type: [String, Object], require: false, default: null, }, },};&amp;lt;/script&amp;gt;컴포넌트를 위와 같이 제작하면 nuxt-link 컴포넌트에서 사용 가능한 모든 Property를 별도의 수정 없이 그대로 활용하실 수 있습니다.이제 Visual Studio Code의 파일 전체 탐색(Command + Shift + F)을 이용하여 nuxt-link를 모두 찾아내고, i18n-link로 대체해줍니다." }, { "title": "[React] 절대 경로 import", "url": "/posts/react-absolute-import/", "categories": "Tech, React", "tags": "React", "date": "2022-04-22 00:00:00 +0800", "snippet": "import 지옥import Component from &#39;../../../../../../../components/BasicComponent&#39;;// ...React로 프로젝트를 개발하다보면 위와 같은 import 지옥이 되는 경우가 잦습니다.보통 실제 라우트 구조에 맞춰서 페이지 컴포넌트를 제작하기 때문에 depth가 깊은 페이지에서 root 폴더까지 올라가려면 어쩔 수 없는 상황이예요.절대경로 선언절대경로란절대경로는 이름 그대로 어떤 상황에서도 변하지 않는 경로를 의미합니다.import를 선언하는 페이지의 위치와는 상관 없이 일관성 있는 경로를 작성하기 때문에 추후 파일 위치가 이동해도 import를 다시 맞추지 않아도 되는 장점이 있어요.방법타입스크립트 프로젝트라면 tsconfig.json, 자바스크립트 프로젝트라면 jsconfig.json 파일에 아래와 같이 작성합니다.{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;src&quot; }, &quot;include&quot;: [&quot;src&quot;]}절대 경로의 진입점을 compilerOptions/baseUrl에 작성하시고, 불러 올 폴더를 include에 작성하시면 됩니다. (보통은 src를 사용하시니 그대로 쓰셔도 괜찮을 거예요.)위와 같이 작성하고나면 프로젝트에서 컴포넌트를 import할 때 아래와 같이 사용하실 수 있습니다.import Button from &#39;components/Button&#39;;출처React - Importing a component" }, { "title": "[Vue] Teleport", "url": "/posts/vue3-teleport/", "categories": "Tech, Vue", "tags": "Vue, Vue3, Portal, Teleport", "date": "2022-04-21 17:12:00 +0800", "snippet": "개요Vue3에서는 정말 많은게 새로 추가되고 삭제 되었습니다.Composition API, ref, reactive 등의 변경점이 있는데, 이들 중 제가 가장 관심이 있었던건 Teleport였습니다.Teleport란 React의 Portal과 같은 기능을 합니다.Teleport는 컴포넌트 내부의 특정 객체를 페이지 내 원하는 위치에 렌더링하는 기술입니다.아마 SPA 개발 툴을 사용해보지 않은 분들께서는 “고작 엘리먼트 위치 변경하는게 그렇게 관심받을 일인가?”라고 생각 하실 수도 있습니다.그런 분들은 이 문서를 꼭 읽어주세요!컴포넌트 주도 개발의 문제점컴포넌트 주도 개발이란, UI를 아주 작은 단위로 쪼개서 이를 서로 연결하여 하나의 기능을 만드는 형태의 개발 방식입니다.React, Vue와 같은 프레임워크는 이 방식을 따르고 있어요.그럼 여기서 예시를 하나 들어봅시다.Dialog위 움짤과 같은 Dialog는 컴포넌트를 어떻게 구성하면 좋을까요?아마 대부분 아래와 같은 구성 요소를 가질겁니다. 백그라운드 마스크 컨텐츠가 보여질 팝업컨텐츠가 보여질 팝업이야 일반적인 UI를 만들 듯 구성하면 아무런 문제가 될 게 없을 것 같습니다.그런데 백그라운드에 씌워질 마스크는 어떻게 구현해야 할까요?깊게 생각할 것 없이 아래와 같은 CSS를 갖도록 구현될 것 같습니다..dialog-mask { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, .45);}일반적인 상황에서는 문제 없이 동작하겠지만, 아주 만약에 position: fixed가 적용 된 Element의 하위에서 Dialog를 사용해야 할 일이 생긴다면 어떻게 될까요?아마 부모 Element에 종속적으로 동작하게 될 것입니다.그렇기에 이 마스크만 부모의 간섭을 받지 않는 페이지의 최상단, 즉 body 태그의 직계 자식으로 올려 줄 필요가 있습니다.Teleport 없이 마스크 옮기기Javascriptexport default { // ... mounted() { const mask = document.createElement(&#39;div&#39;); mask.setAttribute(&#39;class&#39;, &#39;mask&#39;); window.document.body.append(mask); }, beforeDestroy() { document.querySelector(&#39;.mask&#39;).remove(); }, // ...};이런 식으로 컴포넌트가 마운트 되는 순간에 document.createElement를 이용하여 body의 뒤쪽에 추가하는 방법이 있을 수 있습니다.물론 이렇게 하면 body 태그에 마스크를 추가하는 것 자체는 문제가 없을거예요.그런데 이제 마스크에 이벤트를 추가하거나, 또 다른 Element를 자식으로 배치하는 등의 상황에서는 문제가 심각해집니다.정상적인 프레임워크의 흐름을 따르지 않으므로 라이프사이클 및 Element Rendering 등의 상황에서 프레임워크가 주는 이점을 얻지 못하게 됩니다. 커스터마이징이 죽고 싶을 정도로 어려워지는건 덤이구요.또한 Scoped CSS를 사용하지도 못하겠네요.최상단 컴포넌트에 마스크를 배치하기&amp;lt;template&amp;gt; &amp;lt;div class=&quot;mask&quot;&amp;gt; &amp;lt;child /&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;template&amp;gt; &amp;lt;div class=&quot;dialog&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;이런식으로 제어한다면 컴포넌트의 제어 하에 마스크를 그렸으니 위에서 말한 문제점은 해소가 된 듯 합니다.parent.vue 파일에서 CSS를 정의하면 마스크에도 적용이 될거고, 컴포넌트에서 그려졌으니 생명주기도 정상적으로 적용이 될겁니다.그렇지만 Dialog를 끄고 켜는 모든 상황에서 부모와 자식간 데이터와 이벤트를 전달받아야 한다는 점이 굉장히 큰 리스크로 다가오게 되었습니다.parent.vue에서 isVisibleDialog 변수를 들고있고, 이 변수에 따라 마스크를 활성 / 비활성 해야한다면 child.vue에서 Dialog를 표시하는 버튼을 누를 때마다 emit으로 마스크가 존재하는 부모까지 이벤트를 전달해야 마스크의 활성 / 비활성 여부를 제어할 수 있어요.&amp;lt;template&amp;gt; &amp;lt;Child&amp;gt; &amp;lt;Child&amp;gt; &amp;lt;Child&amp;gt; &amp;lt;!-- 여기에 버튼이 있다면? --&amp;gt; &amp;lt;/Child&amp;gt; &amp;lt;/Child&amp;gt; &amp;lt;/Child&amp;gt;&amp;lt;/template&amp;gt;만약 위와 같은 구조로 이루어져있다면 정말 너무 끔찍하네요.또한, 인적 실수로 인해 이벤트를 상단까지 전달하는 것에 실패하여 마스크를 제어하지 못하게 된다면 Dialog는 표시 되는데 마스크는 표시 되지 않는 현상이 일어날 수 있어요.Dialog와 마스크는 사실상 하나의 컴포넌트라고 봐도 무방한데도 서로의 행동에서 결과를 예측하기 어렵게 됩니다.Teleport 이용하기사용법&amp;lt;template&amp;gt; &amp;lt;teleport to=&quot;css-selector&quot;&amp;gt; &amp;lt;component /&amp;gt; &amp;lt;/teleport&amp;gt;&amp;lt;/template&amp;gt;위 처럼 teleport 태그를 활용하시면 됩니다.teleport 태그는 to Property를 받는데, 이 Property에 CSS Selector를 넣으면 teleport 태그 안에 있는 Element들이 해당 셀렉터 내부로 이동합니다. scoped CSS도 정상적으로 동작하고, 컴포넌트의 Life cycle대로 탄생하고 소멸합니다.예시&amp;lt;style scoped&amp;gt; .dialog__bg { position: fixed; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; } .dialog__bg.dialog__bg--active { background-color: rgba(0, 0, 0, .4); pointer-events: inherit; } .dialog__content { border-radius: 4px; background-color: #FFF; max-width: 500px; width: 100%; position: fixed; right: 50%; top: 50%; transform: translate(50%, -50%); z-index: 11; } .dialog__content .dialog-title { padding: 16px; font-weight: bold; font-size: 21px; } .dialog__content .dialog-content { padding: 16px; padding-top: 0; font-size: 14px; }&amp;lt;/style&amp;gt;&amp;lt;template&amp;gt; &amp;lt;div v-if=&quot;visible&quot; class=&quot;dialog&quot; &amp;gt; &amp;lt;teleport to=&#39;body&#39;&amp;gt; &amp;lt;div :class=&quot;{ &#39;dialog__bg&#39;: true, &#39;dialog__bg--active&#39;: visible }&quot; @click=&quot;onClickModal&quot; /&amp;gt; &amp;lt;/teleport&amp;gt; &amp;lt;div class=&quot;dialog__content&quot;&amp;gt; &amp;lt;div class=&quot;dialog-title&quot;&amp;gt; &amp;lt;slot name=&quot;title&quot;&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;dialog-content&quot;&amp;gt; &amp;lt;slot name=&quot;content&quot;&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { defineComponent, PropType } from &#39;vue&#39;export default defineComponent({ props: { visible: { type: Boolean as PropType&amp;lt;boolean&amp;gt;, required: false, default: false, }, }, setup(props, { emit }) { const onClickModal = () =&amp;gt; { emit(&#39;update:visible&#39;); }; return { onClickModal, }; },});&amp;lt;/script&amp;gt;&amp;lt;template&amp;gt; &amp;lt;div class=&quot;dialog-example&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; @click=&quot;onClickShowDialogButton&quot;&amp;gt; Dialog 표시 &amp;lt;/button&amp;gt; &amp;lt;Dialog v-model:visible=&quot;isVisible&quot;&amp;gt; &amp;lt;template v-slot:title&amp;gt; 제목 &amp;lt;/template&amp;gt; &amp;lt;template v-slot:content&amp;gt; 내용 &amp;lt;/template&amp;gt; &amp;lt;/Dialog&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { defineComponent, ref } from &#39;vue&#39;import Dialog from &#39;./components/Dialog/index.vue&#39;;export default defineComponent({ components: { Dialog, }, setup() { const isVisible = ref(false); const onClickShowDialogButton = () =&amp;gt; { isVisible.value = true; }; return { isVisible, onClickShowDialogButton, }; },});&amp;lt;/script&amp;gt;위 코드처럼 Teleport 태그를 이용하면 아주 깔끔하고 간단한 방법으로 Dialog를 만들 수 있습니다.예시 코드는 여기에서 확인 가능합니다.Vue2는 못써요?안타깝지만 Vue2에서는 Element를 특정 위치로 보내는 기능이 기본적으로 내장 되어 있지 않습니다.하지만 다행스럽게도 Vue Community에서 이 기능을 지원하는 라이브러리를 제작했습니다." }, { "title": "프론트엔드와 백엔드의 역할과 책임", "url": "/posts/frontend-backend-roles/", "categories": "Tech, Talk", "tags": "", "date": "2022-04-21 10:52:00 +0800", "snippet": "들어가기에 앞서이 글은 지극히 제 개인적인 의견과 경험에 의하여 작성되었습니다.아래 사례에 등장하는 백엔드 개발자분들과 비슷하게 프론트에 대한 오해를 갖고 계신 분들의 오해를 해소하기 위해서 작성 된 글입니다.사례제가 같이 일했던 백엔드 개발자분과 있었던 케이스 몇 개를 말씀드리겠습니다.Case 1메일 시스템은 본문에 1,000글자 이내로 본문을 작성할 수 있습니다.위와 같은 요구사항이 들어왔을 떄, 제가 백엔드 개발자로부터 받았던 요구사항입니다. 아 찬영씨, 메일 1,000글자 이상으로 넘어간 상태에서 컨펌누르면 안되게 막아주세요~이 기능은 별다른 Javascript 로직 없이 HTML5의 maxlength 프로퍼티로 구현하였고, 보안성 테스트를 위해 브라우저의 DOM 편집기에서 maxlength 프로퍼티를 제거하고 서버에 전송하는 형태로 테스트를 해봤더니 2천, 3천자의 텍스트도 별다른 필터없이 전송되는 사태가 벌어졌습니다.Case 2관리자는 CMS에서 회원을 등록할 수 있습니다.회원 테이블의 휴대전화 번호는 필수로 들어가야 하는 값입니다.회원가입 폼을 만들고 필수 값을 입력하지 않은 채 가입 API를 사용했더니 회원이 별 다른 Validation 절차 없이 가입에 성공하는 사태가 벌어졌습니다.이를 백엔드 개발자분께 말씀드리니 “휴대전화 필드는 required 걸어주세요” 라는 말씀을 듣게 되었고, 저는 백엔드에서도 어느 정도의 validation은 걸어주셔야 한다고 말씀드려서 재개발을 요청 드렸고, 추후에 같은 방식으로 가입을 시도했더니 validation이 걸리긴 하는데 500 Exception만 터져나올 뿐, 어떤 사유로 인해 반려가 되었는지는 나오지 않았습니다.Case 3관리자에서 게시물의 카테고리를 등록할 때 &#39;행사&#39; 타입의 카테고리는 게시물에 &#39;행사 시작일&#39;과 &#39;행사 종료일&#39; 필드가 나타나야 한다.&#39;행사&#39; 타입의 카테고리의 하위에 등록 된 카테고리를 설정해도 마찬가지로 추가적인 UI가 보여져야 한다.이를 위해 카테고리에는 isEvent라는 플래그가 존재하며, 이를 카테고리 추가 및 수정시 설정할 수 있어야 한다.프론트에서는 카테고리를 등록하는 UI를 작성하고, isEvent 플래그에 따라 활성 / 비활성 되는 스위치를 배치하였습니다.또한, 하위 카테고리를 추가할 때는 isEvent를 제어할 수 있는 스위치를 노출하지 않도록 구현했습니다.그렇게 하위 카테고리를 추가하니 isEvent가 true인 부모의 하위 카테고리를 생성해도 기본값인 false가 들어가도록 설정되어 있어서 백엔드 개발자분께 여쭤보니 isEvent 값은 부모값에서 가져와서 등록해야 한다는 말을 들었습니다.위 케이스의 문제점일부 백엔드 개발자분들이 프론트의 역할에 대해 오해가 있는 경우가 있습니다.프론트는 사용자가 엉뚱한 길로 빠지게 하지 않고, 정보를 기입하기 위해 최대한 편한 UI를 제공하는 역할을 합니다.마치 호텔 프론트에서 투숙객을 맞이하는 스태프와 같은 역할이라고 생각하시면 이해가 쉬울 것 같습니다.호텔의 프론트에서 업무를 보시는 스태프 분들은 호텔의 매니저가 정한 룰을 고객님께 안내하고 최대한 편하게 해드리는 역할을 할 뿐, 정책 그 자체에 손을 대는 역할은 아닌 것처럼 프론트엔드도 이미 사전에 정해진 룰에서 최대한 편한 UI를 제공하는 것이 역할입니다.Data Validation이나 isEvent와 같이 실제 데이터에 영향을 주는 정책 이슈를 해결하는 것이 백엔드의 역할입니다.만약 이를 프론트에서 제어한다면, 소프트웨어를 정해진 규격 하에서 사용하는 일반 사용자들에게는 문제가 없겠지만 클라이언트 변조 기술을 가진 일부 사용자들은 이를 파훼하고 서버에 악영향을 주는 데이터를 삽입할 수도 있기에 실제 보안 정책은 백엔드에서 이루어져야만 합니다.또한 isEvent 플래그 제어의 경우에도 ‘부모 카테고리 수정 시 하위 데이터에 대한 상태 변경’ 등 데이터를 탐색해야 하는 경우의 수가 많아지는데, 이를 프론트에서 제어하게 되면 웹 퍼포먼스를 저하하고 사용자 경험에 악영향을 줍니다. 그러므로 데이터의 깊은 탐색 및 변경에 대한 구현은 백엔드에서 이루어지는게 더 나은 결과를 얻을 수 있습니다." }, { "title": "Javascript 애니메이션 라이브러리", "url": "/posts/Javascript_animation_libraries/", "categories": "Tech, Talk", "tags": "Animation, Javascript", "date": "2022-04-19 12:14:00 +0800", "snippet": " 개요오늘날의 웹사이트에는 다양한 애니메이션 효과가 기본적으로 포함됩니다.CSS, Javascript를 통해서 DOM을 제어하기에 가능한 일입니다.그런데 단순한 애니메이션 정도면 몰라도 복잡한 애니메이션이나 스크롤 애니메이션, 3D그래픽을 이용한 애니메이션 등은 직접 만들기에는 무리가 있습니다. 그런 복잡한 애니메이션을 쉽게 만들 수 있도록 도와주는 라이브러리를 소개합니다.Typeit웹사이트에 타이밍 애니메이션 효과를 줄 수 있습니다.장점 SSR 최적화 가벼운 사이즈 간편함ScrollOut웹사이트의 특정 영역이 Viewport안에 들어오거나 나갈 경우 요소가 나타나고 사라지는 등의 애니메이션 효과를 구현할 수 있습니다.HTML Attribute와 CSS Transition, keyframe만을 이용하여 애니메이션을 구현하기 때문에 애니메이션의 퍼포먼스가 좋고 라이브러리의 사이즈가 가볍습니다.장점 매우 가벼운 라이브러리 높은 성능의 애니메이션 간편함Anime.js상대적으로 구현하기 복잡한 애니메이션을 구현하도록 도와주는 라이브러리입니다.Javascript 기반으로 실제 DOM의 위치를 변경하여 다시 그리는 형태로 애니메이션을 구현합니다.상대적으로 사용하기 어려운 라이브러리지만 원하는 애니메이션을 폭넓게 구현할 수 있습니다.Rellax패럴랙스 스크롤을 쉽게 구현할 수 있도록 도와주는 라이브러리입니다.패럴랙스 스크롤패럴랙스 스크롤이란, 스크롤 정도에 따라서 DOM의 일부 객체가 서로 다른 속도로 이동하는 효과를 말합니다." }, { "title": "해피해킹 키 세팅", "url": "/posts/happy_hacking_key_setting/", "categories": "Tech, Talk", "tags": "Happyhacking", "date": "2022-04-19 10:30:00 +0800", "snippet": "해피해킹해피해킹 키보드는 사용자들 사이에서도 호불호가 정말 많이 갈리는 키보드 중 하나입니다.고작 해봐야 키보드인데도 키세팅 하나 익히자고 몇 십년간 사용했던 일반적인 키보드의 배열을 정면으로 거슬러야 하기 떄문이죠.그럼에도 불구하고 개발자 커뮤니티에서 꾸준히 회자되고 있다는 것은 익숙해지면 분명 쓸만한 키보드이기 때문일 것입니다.그래서 평소 생각은 하고 있었으나 마땅히 살만한 타이밍을 잡지 못했었기 떄문에 고민을 많이 했는데 네이버 스토어에 가격이 적당한게 나와서 구매하게 되었습니다.딥스위치딥스위치는 해피해킹 키보드에만 있는 특별한 키세팅 방식입니다.키보드의 뒷면을 열어보면 아래와 같이 스위치가 6개 존재합니다.이미지 출처: https://kim-dragon.tistory.com/114맥을 사용하는 유저는 1, 3, 5번 스위치를 ON으로 전환하면 우리가 흔히 아는 맥 키보드 세팅을 사용할 수 있습니다.카라비너카라비너 사이트에서 프로그램을 다운받습니다.해피해킹은 위에서도 말했다시피 키 배열이 절대 평범하지 않습니다.그렇기에 키보드를 본인 손에 맞도록 여러가지 커스터마이징을 할 필요가 있습니다.카라비너는 키보드 자판 세팅을 도와주는 소프트웨어입니다.Karabiner-Elements Preferences 소프트웨어를 켜면 상단에 8개의 탭이 보일텐데, Misc탭을 눌러줍니다.해당 탭에서 하단에 보면 Export &amp;amp; Import 영역이 보일텐데, 하단에 있는 Open config folder 버튼을 눌러줍니다.해당 버튼을 누르면 파인더가 열리고, 해당 폴더 안에 karabinder.json 파일이 보일텐데, 해당 파일에 카라비너에서 사용할 키 세팅 명세를 작성할 수 있습니다.흔히 볼 수 있는 json파일이지만 카라비너가 이해할 수 있는 문법으로 작성해야 하기에 이를 직접 커스터마이징 하기 위해서는 어느정도의 러닝커브가 존재합니다.그렇기에 당장 급하게 해피해킹 키보드를 세팅하고 싶은 분들은 카라비너의 Complex modifications 탭을 누르고, 해당 탭에서 Rules를 선택합니다.이미지 출처: https://karabiner-elements.pqrs.org/docs/manual/configuration/configure-complex-modifications/하단에 있는 Add Rules 버튼을 누르면 현재 보유한 규칙들을 활성 / 비활성 시킬 수 있는데 기본적으로 갖고있는 키세팅이 거의 없을겁니다.이미지 출처: https://karabiner-elements.pqrs.org/docs/manual/configuration/configure-complex-modifications/상단에 있는 import more rules from the internet 버튼을 누르면 웹브라우저가 열리며, 다른 사람들이 만들어둔 카라비너 키세팅을 다운 받을 수 있습니다.제가 사용하는 키세팅 파일도 공유해드립니다!만약 이를 적용하고자 하신다면 ~/.config/karabiner 경로에 karabiner.json 파일로 저장하시면 됩니다.긴 글 읽어주셔서 감사합니다!" }, { "title": "ESLint - &#39;process&#39; is not defined", "url": "/posts/process-eslint-issue/", "categories": "Tech, Talk", "tags": "", "date": "2022-04-18 17:51:00 +0800", "snippet": "이슈if (process.env.NODE_ENV === &#39;production&#39;) // ...// &#39;process&#39; is not definedprocess가 일반적인 변수처럼 취급되어 해당 페이지 내 코드에서 정의 되어 있지 않다고 에러를 표시합니다.해결법{ &quot;env&quot;: { &quot;node&quot;: true, }}.eslintrc.json 파일 내 env 객체에 node 속성을 추가하면 해결 됩니다.레퍼런스Stackoverflow - ‘process’ is not defined" }, { "title": "[React] memo 함수를 이용한 메모이제이션", "url": "/posts/react-memo/", "categories": "Tech, React", "tags": "React, memo, memoization", "date": "2022-04-14 10:18:00 +0800", "snippet": "React 렌더링React의 컴포넌트는 state라고 불리는 상태값과 props라고 불리는 전달값이 있습니다.상태값과 전달값은 컴포넌트의 렌더링와 아주 직접적인 관계가 있습니다. 상태가 변이함에 따라 컴포넌트가 보여지는 형태도 달라져야 하기 때문입니다.그러기에 React의 컴포넌트는 state와 props의 변이를 계속 관찰하고 있고, 변이가 발생하게 되면 메모리에 저장해 둔 Virtual DOM에 변이 된 상태값을 대입하여 브라우저에 렌더링하는 과정을 거칩니다.이 과정에서 컴포넌트 안에 정의 된 로직을 다시 수행하게 되는데, 만약 복잡한 로직의 연산 과정이 포함 되었을 경우 사소한 상태값의 변이로 인해 재연산을 수행하게 됩니다.심지어 변이 된 상태값이 해당 연산의 결과에 아무런 영향을 끼치지 않는다고 해도 말입니다.그런데 React 프로젝트에는 수많은 컴포넌트들이 존재하고, 이 컴포넌트들은 유기적으로 연결 되어 하나의 페이지가 됩니다.컴포넌트들이 긴밀하게 연결되는 과정에서 자연스럽게 부모 / 자식 관계가 형성이 될 것이고, 부모의 상태값이 변경된다면 부모를 렌더링하는 과정에서 해당 컴포넌트와 연결 된 자식 컴포넌트들도 모두 렌더링을 다시 수행합니다. 부모의 상태값이 변했다고 해서 무조건 자식 컴포넌트에게 영향을 미치는 것은 아닌데도 말이죠.React.memo위에서 설명한 상황에서 사용할 수 있는 유용한 함수가 있습니다.React.memo(component)는 컴포넌트 본인의 state와 props에 변이가 발생한 상황이 아니라면 해당 컴포넌트는 재연산 과정을 수행하지 않는다고 선언해주는 함수입니다.아래와 같이 사용합니다.import { FC, memo } from &#39;react&#39;;const Component: FC&amp;lt;Props&amp;gt; = (props: Props) =&amp;gt; { return (&amp;lt;div /&amp;gt;);};export default memo(Component);주의할 점 “컴포넌트에게 영향을 미치는 상태값의 수정이 이루어지지 않는다면 렌더링을 하지 않는다.”위에서 설명한 것만 들어보면 React.memo 함수는 단점이 없어보입니다.그런데 잘 생각해보면, 컴포넌트에 영향을 미치는 상태값의 수정인지 아닌지는 어떻게 알 수 있을까요?React.memo 함수는 매개변수로 전달 된 컴포넌트의 state와 props를 탐색하고, 이전 값과 현재 값이 다른지 비교하는 로직을 수행하게 됩니다.부모 컴포넌트와 대상 컴포넌트의 모든 변이 때마다 비교 로직을 수행하면 발생 될 오버헤드가 상당히 우려스럽습니다.그렇기 때문에 비교 로직에 의한 오버헤드보다 재연산을 수행하지 않았을 때 얻는 이점이 더 크다고 판단 될 때만 선택적으로 사용하는 것이 중요합니다.레퍼런스Use React.memo() wisely" }, { "title": "ESlint와 Prettier 설치하기", "url": "/posts/eslint-prettier-installation/", "categories": "Tech, Talk", "tags": "ESLint, pritter, clean code", "date": "2022-04-13 09:24:00 +0800", "snippet": "ESLintESLint는 코드를 보다 예쁘고 일관성있게 관리하기 위한 최소한의 제한사항입니다.VSCode 에디터를 사용하고 있다면 ‘저장 시 자동으로 포맷’ 기능을 활용하여 ESLint에 비준하지 않는 코드 스타일로 작성하더라도 저장만하면 자동으로 에디터가 포맷을 맞춰주는 편리한 기능을 사용할 수 있습니다.설치ESLint를 간편하게 세팅하기 위한 패키지를 설치합니다. (이미 설치 되어 있다면 아래 명령어는 생략합니다.)npm i -g eslintESLint를 설치하고 싶은 프로젝트의 루트에 진입한 다음 eslint --init 명령을 실행합니다.초기화❯ eslint --initYou can also run this command directly using &#39;npm init @eslint/config&#39;.? How would you like to use ESLint? … To check syntax only❯ To check syntax and find problems To check syntax, find problems, and enforce code style다음과 같은 세 가지 선택지가 나오는데, 이는 아래와 같습니다. 문법 오류만을 체크한다. 문법 오류를 체크하고 문제점을 찾는다. 문법 오류, 문제점을 탐색하고 지정한 코드 스타일을 강제한다.ESLint 비준 엄격성을 체크하는건데, 기본값이 2번으로 맞춰져있으니 2번이 아마 가장 많은 사람들이 선택하는 설정이 아닐까 싶습니다.그런데 전 엄격한거 좋아하니 3번으로 설정합니다.? What type of modules does your project use? … ❯ JavaScript modules (import/export) CommonJS (require/exports) None of these이번에는 프로젝트 유형을 물어봅니다. import/export로 모듈을 내보내고 불러온다. require와 exports로 모듈을 내보내고 불러온다. 모듈 안써요만약 Vue나 React 프로젝트를 개설하여 사용하고 계신 분들이라면 대부분 1번일겁니다.express 프로젝트에 적용하고 싶으신 분들은 대부분 2번을 선택할 것이라고 생각합니다. (모든 사람에게 해당되는 경우는 아닙니다.)프로젝트의 유형을 보고 결정하시면 됩니다.? Which framework does your project use? … ❯ React Vue.js None of these무슨 프레임워크로 개발하는지 물어봅니다.React.js, Vue.js에 대한 설정값은 기본적으로 포함되어 있으나 그 외의 프레임워크로 개발을 한다면 None of these를 선택하면 됩니다.Does your project use TypeScript? › No / Yes타입 스크립트 쓰고 있냐는 얘기입니다.? Where does your code run? … (Press &amp;lt;space&amp;gt; to select, &amp;lt;a&amp;gt; to toggle all, &amp;lt;i&amp;gt; to invert selection)✔ Browser✔ Node코드가 어디에서 실행되는거냐고 묻습니다.내가 Vue나 React를 사용하여 웹 페이지를 개발하고 있는 것이라면 브라우저에서 실행 되므로 ‘Browser’를 선택하시면 되고, Express와 같은 터미널에서 실행하는 프로그램의 경우 ‘Node’를 선택하시면 됩니다.? How would you like to define a style for your project? … ❯ Use a popular style guide Answer questions about your style보편적으로 사용되는 코드 스타일을 불러올건지, 본인만이 사용하는 코드 스타일이 있는지 물어봅니다.ESLint 환경설정에 익숙하신 분들은 2번을 선택하시면 되지만, 대부분의 개발자들이 사용하는 코드 스타일에 익숙해지는게 범용적이고 좋겠죠? 저는 1번을 선택합니다.? Which style guide do you want to follow? … ❯ Airbnb: https://github.com/airbnb/javascript Standard: https://github.com/standard/standard Google: https://github.com/google/eslint-config-google XO: https://github.com/xojs/eslint-config-xo어디서 만든 코드 스타일을 불러올건지 물어봅니다.아마 대부분의 개발자들은 Airbnb에서 만든 ESlint를 사용할 것이라고 생각합니다. 저도 여태까지 그렇게 개발을 해왔으니 1번을 선택합니다.? What format do you want your config file to be in? … ❯ JavaScript YAML JSONESLint 파일을 어떤 확장자로 생성할 것인지 물어봅니다.ESLint의 설정은 .eslintrc 파일로 생성되는데, 이 파일은 여러 확장자로 구성될 수 있습니다.가장 보편적으로 사용되는 확장자는 json과 js인데, json의 경우 따옴표 맞춰주는게 귀찮으니 문법이 상대적으로 자유롭고 편한 javascript를 선택합니다.eslint-plugin-react@^7.28.0 @typescript-eslint/eslint-plugin@latest eslint-config-airbnb@latest eslint@^7.32.0 || ^8.2.0 eslint-plugin-import@^2.25.3 eslint-plugin-jsx-a11y@^6.5.1 eslint-plugin-react-hooks@^4.3.0 @typescript-eslint/parser@latest? Would you like to install them now with npm? › No / Yes마지막 질문입니다. “내가 지금 위에 나열한 패키지들이 필요한데 저것들을 npm으로 설치해도 될까?” 라고 묻는겁니다.거절할 이유 없겠죠? yes 누릅니다.주의사항이 글을 작성하는 시점에서 @types/react의 최신 버전은 18.0.2입니다.그런데 이 라이브러리를 통해 ESLint를 설치하면 이상하게 자꾸 @types/react가 설치 안됐다고 오류가 표시됩니다.18.0.1로 다운그레이드하여 사용하면 정상적으로 적용 됩니다.PrettierPrettier도 ESLint와 마찬가지로 일관성 있는 코드 스타일을 지키기 위한 제한 사항입니다.다만 ESLint보다 좀 더 범용적인 코드 스타일을 적용할 수 있습니다. 자세한 설명은 아래 섹션에 기재하겠습니다.설정법프로젝트 루트 폴더에 .prettierrc 파일을 생성합니다.{ &quot;tabWidth&quot;: 2, &quot;useTabs&quot;: false, &quot;singleQuote&quot;: false, &quot;printWidth&quot;: 80}위 코드를 예시로 들 수 있는데, .prettierrc 파일은 JSON으로 이루어지며, 여기에서 규칙을 볼 수 있습니다.만약 프로젝트에 이미 ESLint가 설정 되어 있다면 ESLint에서 Prettier도 인식할 수 있도록 확장할 필요가 있습니다.module.exports = { env: { browser: true, es2021: true, }, extends: [ &#39;plugin:@next/next/recommended&#39;, &quot;eslint:recommended&quot;, &#39;airbnb&#39;, ], parser: &#39;@typescript-eslint/parser&#39;, parserOptions: { ecmaFeatures: { jsx: true, }, ecmaVersion: &#39;latest&#39;, sourceType: &#39;module&#39;, }, plugins: [ &#39;react&#39;, &#39;@typescript-eslint&#39;, ], rules: { &#39;react/react-in-jsx-scope&#39;: &#39;off&#39;, &#39;react/jsx-filename-extension&#39;: &#39;off&#39;, &#39;react/function-component-definition&#39;: [2, { namedComponents: &#39;arrow-function&#39; }], &#39;react/jsx-props-no-spreading&#39;: &#39;off&#39;, },};위 코드는 제가 적용하고 있는 ESLint입니다. extends 항목을 보시면 eslint:recommended라고 적혀있는 것을 확인하실 수 있는데, 이 부분을 추가하여 .prettierrc 설정도 ESLint에 추가할 수 있습니다.물론 이를 확장하기 위하여 추가적인 패키지 설치도 필요합니다. 아래 명령어를 입력하시면 됩니다.NPMnpm i prettierYarnyarn add prettierPrettier와 ESLint의 차이ESLint는 사용하는 프레임워크와 개발 툴에 따른 코드 스타일을 확장하여 적용할 수 있습니다.아래 코드로 예를 들겠습니다.const App: FC&amp;lt;Props&amp;gt; = () =&amp;gt; { return ( &amp;lt;div /&amp;gt; );};export default App;위 코드의 경우 로직 상 문제는 전혀 없지만, React ESLint의 기본 값을 준수한다면 에러가 나올 것입니다.React의 컴포넌트들은 기본적으로 import React from &#39;react&#39;가 위에 무조건 포함 되도록 설정 되어 있기 때문입니다.이처럼 사용하는 개발 툴에 대해 종속적인 설정을 하는데 사용되는데 비해, Prettier는 어떤 프로젝트에 갖다놔도 적용할 수 있는 포맷팅에 사용되기 때문입니다.들여쓰기, 탭 문자를 공백으로 할지, 세미콜론을 끝에 찍을 것인지, 작은 따옴표만을 사용할 것인지, 한 줄에 들어갈 수 있는 코드는 몇 자 제한인지 등을 설정할 수 있습니다." }, { "title": "SEO 친화적인 인피니티 스크롤", "url": "/posts/seo-friendly-infinite-scroll/", "categories": "Tech, Talk", "tags": "SEO, Web", "date": "2022-04-12 10:25:00 +0800", "snippet": "출처: https://im-developer.tistory.com/196무한 스크롤웹 혹은 앱을 사용하다보면 위와 같은 방식의 페이징 기법을 많이 볼 수 있습니다.핀터레스트, 페이스북 등 많은 서비스들이 이를 채택하고 있어요. 방대한 양의 컨텐츠들을 복잡한 공수 없이 사용자 친화적인 UX를 이용해 보여줄 수 있다는 것이 가장 큰 장점이죠. 세로 혹은 가로 방향으로 우선순위가 높은 컨텐츠부터 낮은 컨텐츠까지 배치한다. 스크롤이 가능하게 만든다. 스크롤이 끝에 거의 도달하면 다음 컨텐츠들을 불러와서 스크롤 영역을 확장한다. 불러 올 컨텐츠가 없어질 때 까지 반복한다.위와 같은 로직을 이용합니다.단점아마 웹을 어느정도 개발해보신 분들이라면 위 로직을 보고 한가지 의문을 가질 것입니다.SEO는 어떻게 충족하면 되지? 라고 말입니다.검색 엔진들은 서비스 되고 있는 웹사이트에 크롤러 봇이 방문하여 현재 로드 된 컨텐츠들의 HTML 코드를 읽어서 이를 검색 엔진에 뿌려주는 형태로 동작합니다.그런데 컨텐츠들이 페이지 호출 시 전부 로드 된 상태가 아니라, 스크롤을 할수록 점진적으로 나타난다면 크롤러는 이를 이해하지 못하고 초기 로드 된 컨텐츠를 제외한 나머지 컨텐츠들을 검색 엔진에서 제외할 것입니다.해결 방법위 이슈를 해결하기 위한 방법은 &amp;lt;a&amp;gt; 태그를 이용하는 것입니다.크롤러 봇은 웹 서비스의 진입점으로 진입하여 사이트를 탐방하는데, 이 진입점에 존재하는 각종 링크 정보들을 읽어들여서 크롤링 할 다른 페이지들에 대한 정보를 받아옵니다.이를 계속 반복하여 더 이상 탐색할 링크가 없을 때까지 진행하게 됩니다.이러한 점을 이용하여, 무한 스크롤 페이지 어딘가에 눈에 안보이는 &amp;lt;a&amp;gt; 태그를 사용하여 다음 컨텐츠가 로드 되는 페이지의 URL을 기입하면 됩니다. const InfiniteScroll = () =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;Card /&amp;gt; &amp;lt;Card /&amp;gt; &amp;lt;Card /&amp;gt; ... &amp;lt;InfiniteScrollTrigger /&amp;gt; &amp;lt;a href=&quot;/infinite-scroll?page=5&quot;&amp;gt; &amp;lt;a href=&quot;/infinite-scroll?page=7&quot;&amp;gt; &amp;lt;/div&amp;gt; ); }; export default InfiniteScroll; // 현재 페이지는 6페이지다만 좀 더 복잡해질 수 있어요일반적인 페이지 스크롤 로직을 구현한다고 한다면 현재 보여지는 페이지만 대응하면 되는 일이지만, SEO를 대응하려 한다면 URL에 넘기는 페이지 쿼리에 따라 SSR 로직을 따로 구현해야하고 중간 페이지부터 진입하는 사람들을 위해 양방향 스크롤 페이징도 지원해야 하는 추가적인 비용이 들어갈 수 있습니다." }, { "title": "React의 Life Cycle", "url": "/posts/react-life-cycle/", "categories": "Tech, React", "tags": "React, Lifecycle", "date": "2022-04-08 17:22:00 +0800", "snippet": "개요라이프사이클, 즉 생명주기라는 단어는 Vue나 React와 같은 프론트엔드 개발 도구를 사용해본 경험이 있다면 누구나 한 번 쯤 들어봤을 단어입니다.그만큼 해당 개발 도구를 사용하는데 중요한 역할을 하며, 이 부분을 잘 알고 있어야 좋은 서비스를 개발할 수 있습니다.LifecycleVue나 React는 컴포넌트 단위로 아주 작게 기능들을 쪼개서 개발을 하는데, 컴포넌트가 생겨나면서 사라지기까지의 모든 과정을 Lifecycle이라고 합니다.ReactReact의 생명주기의 경우 세 단계로 구분 됩니다.Mount컴포넌트가 렌더링 된 단계를 Mount라고 합니다.클래스 컴포넌트class Component { componentDidMount() { // 로직 }}클래스 컴포넌트의 경우, componentDidMount라는 메소드로 해당 단계에 실행할 로직을 작성합니다.함수형 컴포넌트useEffect(() =&amp;gt; {}, []);함수형 컴포넌트의 경우, useEffect 함수를 이용합니다.두번째 매개변수로 []를 전달하여, 해당 컴포넌트가 탄생하는 순간에만 실행하도록 구현합니다.Update컴포넌트가 렌더링 된 이후, state나 props 등의 변경으로 인하여 새로 컴포넌트를 렌더링 하는 단계를 Update라고 합니다.클래스 컴포넌트class Component { componentDidUpdate() { // 로직 }}컴포넌트가 갱신 될 때 실행할 로직을 componentDidUpdate에 작성합니다.Unmount컴포넌트가 완전히 소멸하는 단계를 Unmount라고 합니다.클래스 컴포넌트class Component { componentWillUnmount() { }}클래스 컴포넌트는 해당 단계에 실행할 로직을 componentWillUnmount라는 메소드에 작성합니다.함수형 컴포넌트useEffect(() =&amp;gt; { // 로직 return () =&amp;gt; { // Unmount 때 실행할 로직 };}, []);기본적으로 함수의 형태는 Mount 단계와 동일하지만, Unmount 때 실행할 로직을 담은 함수를 return한다는 점에서 차이가 생깁니다." }, { "title": "[React Native] APK와 AAB", "url": "/posts/react-native-APK-and-AAB/", "categories": "Tech, React Native", "tags": "React Native, Android", "date": "2022-04-08 16:48:00 +0800", "snippet": "개요지난번에는 RN으로 제작한 앱을 APK로 빌드하는 방법에 대하여 알아보았습니다.하지만 이를 Playstore에 직접 올려 배포하기 위해서는 APK 빌드가 아닌, AAB 빌드에 대하여 알아봐야 합니다.AABAPK는 윈도우에서의 EXE처럼 운영체제에서 구동되는 소프트웨어의 확장자입니다. 개발자는 물론이고 사용자들 사이에서도 널리 알려져있죠.그렇다면 AAB는 무엇일까요? 다소 생소한 이름인데, 이는 APK를 사용자의 단말기에 설치하는 것을 도와주는 번들 파일의 확장자입니다.번들파일번들러로 유명한 Webpack번들파일이란 위 사진과 같이 뿔뿔이 흩어져있는 각종 파일들을 병합하여 생성 된 파일입니다.이 작업을 번들링이라 하고, 이 작업을 수행해주는 도구를 번들러라고 합니다.장점AAB 파일은 사용자의 단말기에 APK를 설치하기 위한 모든 정보를 갖고 있는 파일입니다.이를 Playstore에 업로드하여 배포하면 사용자 단말기의 여러 특성을 고려하여 반드시 필요한 파일들로만 이루어진 APK를 설치하게 만들 수 있습니다.한국어 사용자에게 영어 언어팩을 설치한다던가, 구형 단말기에서 신형 단말기의 기능을 구현하기 위한 코드를 설치하는 등의 불필요한 작업을 생략하여 보다 가벼운 어플리케이션을 배포하는 것이 가능하게 됩니다.또한, 기존에는 각각의 단말기에 설치하기 위한 APK 파일을 여러 개로 빌드하여 관리해야 한다는 단점도 존재했는데 AAB 배포를 이용한다면 앱 개발자는 AAB 파일 하나에만 집중할 수 있으니 생산성의 증가도 생각해볼 수 있겠죠.단점AAB 파일은 Google의 Playstore를 통해서만 배포할 수 있습니다.그렇기 때문에 원스토어, 아마존 앱스토어와 같은 서드파티 스토어에 배포하는 것이 불가능합니다.APK를 이용한 배포과거에는 Playstore에도 APK를 이용하여 앱을 배포할 수 있었으나, 구글 플레이스토어 정책 변경으로 인하여 더 이상 APK를 이용한 배포가 불가능합니다.AAB 파일 빌드./gradlew bundleRelease위 명령어로 빌드하면 android/app/outputs/bundle/release 폴더 안에 생성됩니다.위 명령어를 수행하기 이전 까지의 과정을 보시려면 이 문서를 참고해주세요.레퍼런스요즘 IT - 구글이 안드로이드 앱 배포를 APK 대신 AAB로 바꾸는 이유" }, { "title": "좋은 개발자가 되는 법", "url": "/posts/be-good-developer/", "categories": "Tech, Review", "tags": "Review", "date": "2022-03-29 10:00:00 +0800", "snippet": "개요얼마 전 Github를 둘러보던 중 좋은 게시글 하나를 발견하였습니다.능력있는 개발자는 어떻게 알아볼 수 있나? 라는 제목으로 투고 된 게시물인데, 회사가 개발자를 선별하기 위해 하면 좋은 방법에 대해 알려주는 글이였습니다.지금 당장 제가 개발자를 채용해야 한다거나, 개발자를 채용할만한 위치에 있는 상황은 아니지만 좋은 개발자가 되기 위한 목표를 둔 사람으로서 회사의 시선으로 바라보는 개발자 평가법도 알아두면 좋을 것 같아 해당 게시글을 보게 되었습니다.시장의 문제점우리나라의 개발자 시장, 특히 압도적인 규모를 자랑하는 SI 시장에서는 개발자를 초중고급으로 레벨을 나누며 몸값을 받습니다.이것이 문제인 이유는 단계를 나누는 기준이 학력과 경력에만 치중해있다는 것입니다.개발을 해보신 분들이나 개발자들의 기술에 대해 알아보신 분들이라면 이것이 얼마나 위험한 일인지 알 것입니다.비전공자, 지방대, 고졸 등의 경력 1, 2년차 주니어가 5년, 6년의 경력을 보유한 개발자보다 개발 실력이 무조건 열등(?)하다고 볼 수가 없기 때문이죠.좋은 개발자가 되는 법코드를 공개하라개발자들의 대다수가 본인의 코드를 공개적으로 드러내는 것을 두려워합니다.애초에 이건 코드에만 국한 된 얘기가 아니라, 본인이 가진 기술을 드러내고 비평을 들어야 한다는게 꺼려지는 것은 사람이라면 당연한 일입니다.하지만 본인의 기술을 꽁꽁 숨겨두면 당신보다 잘하는 누군가의 피드백을 받을 수 있는 기회를 날려버리는 일이 될 수 있기 때문에 코드는 가급적 공개해야 합니다.다른 사람의 코드를 봐라당신이 당신의 코드를 만천하에 공개하는 것 처럼, 당신 또한 다른 사람의 코드를 볼 수 있는 권리가 있습니다.더 나은 사람의 코드를 중점적으로 보고, 이 사람의 코드를 이해하지 못하더라도 이 사람의 코드를 모방하도록 노력하세요.당신보다 더 낫다고 생각하는 사람이 짠 코드라면 분명 그 사람의 코드에는 그 사람이 겪은 모든 이슈에 대한 해결책이 녹아들어있기 때문입니다.나만 잘하지 말라많은 사람들이 착각하고, 저 또한 착각하고 있던 대목 중 하나인데, 프로젝트를 빠른 기간 안에 많이 끝내는 사람이 유능한 개발자라고 생각하면 안된다는 점입니다.물론 이 또한 분명 회사에 많은 수익을 가져다주는 좋은 덕목이긴 하지만 이는 단기적인 사업적 관점에서 바라보는 개발자의 유능함이고, 진정 유능한 개발자는 본인의 속도를 조금 희생하더라도 구성원 모두가 좋은 코드를, 최대한 버그가 적게, 기한 내에 만들도록 유도하는 사람입니다.전산학적으로 바라보라예를 들어 아래와 같은 코드가 있다고 칩니다.this.coords = [];this.coordsMarker = [];this.coordsInfoWindows = [];팀의 구성원이 코드를 이렇게 구성했다고 하고, 이를 여러분들이 리뷰해야 하는 상황이라면 어떻게 해야할까요?coords라는 접두사를 통해 연관성이 있는 변수임을 어필하고는 있지만, 컴퓨터의 시선에서 바라볼 때 각 변수간 연관성이 있다. 라고 설명할 수는 없겠죠.그래서 이 점을 해결하기 위해, 클래스를 사용하는 것이 베스트입니다.class Map { constructor() { this.coords = []; this.marker = []; this.windows = []; }}이렇게 묶는다면 공통의 관심사를 갖는 변수의 묶음을 그 어떤 표현 방법 보다 확실하게 표현할 수 있습니다.또한, coords와 marker가 특정한 로직으로 엮여있는 변수여야 한다면, setter를 작성하여 두 변수를 어떠한 규칙으로 강제할 수 있습니다.이렇게 구현한다면 coords와 marker 변수 간 무결성을 검증하기 위한 코드를 작성할 수고를 덜 수 있겠죠.마치며저도 위에서 소개한 글을 읽어보며 알게 된 점이 많습니다.특히 예문에서 들었던 prefix로 변수 간 규칙성을 표현한 코드가 저한테도 실제로 있었던 사례인데, 이 부분에 대해서 다시금 돌아보게 되는 계기가 되었습니다." }, { "title": "[Nuxt] Failed to execute put on cache 이슈", "url": "/posts/nuxt_Failed_to_execute_put_on_cache/", "categories": "Tech, Nuxt", "tags": "Tech, Nuxt, ServiceWorker", "date": "2022-03-17 15:28:00 +0800", "snippet": "개요Nuxt로 개발을 하던 도중, 어느 순간부터 개발자 도구를 열면 다음과 같이 service-worker.js라는 곳에서 에러를 쭉쭉 뱉고 있었습니다.찾아본 결과, 다음과 같은 방법으로 해결할 수 있었습니다.해결 방법navigator.serviceWorker.getRegistrations().then(function(registrations) { for(let registration of registrations) { registration.unregister()} });Chrome에서 개발자도구 -&amp;gt; console 탭을 열고, 위 소스코드를 입력해서 실행시키면 해당 이슈가 발생하지 않습니다!" }, { "title": "[React Native] Webview SSL Error: The Certificate authority is not trusted", "url": "/posts/Webview_SSL_Error/", "categories": "Tech, React Native", "tags": "React Native, Webview, Android", "date": "2022-03-08 22:42:00 +0800", "snippet": "개요회사에서 하이브리드 어플리케이션을 개발하기 위해 웹뷰를 통해 포팅을 하고 있는데 기껏 개발해서 구축해놓은 웹사이트를 웹뷰에서 보니까 이런 에러가 나옵니다.인증서 날짜가 유효하지 않다는데 도무지 원인을 모르겠어서 해당 이슈를 어떻게 해결할까 하다가 Webview에서 SSL 관련 처리를 변경하는 방식으로 해결했습니다.해결 방법node_modules 폴더 안에 설치 된 패키지 중에서 react-native-webview/android/src/main/java/com/reactnativecommunity/webview/RNCWebviewManager.java 파일을 열면 onReceivedSslError라는 메소드가 있을텐데, handler.cancel() 부분을 handler.proceed()로 변경합니다. @Override public void onReceivedSslError(final WebView webView, final SslErrorHandler handler, final SslError error) { // onReceivedSslError is called for most requests, per Android docs: https://developer.android.com/reference/android/webkit/WebViewClient#onReceivedSslError(android.webkit.WebView,%2520android.webkit.SslErrorHandler,%2520android.net.http.SslError) // WebView.getUrl() will return the top-level window URL. // If a top-level navigation triggers this error handler, the top-level URL will be the failing URL (not the URL of the currently-rendered page). // This is desired behavior. We later use these values to determine whether the request is a top-level navigation or a subresource request. String topWindowUrl = webView.getUrl(); String failingUrl = error.getUrl(); // Cancel request after obtaining top-level URL. // If request is cancelled before obtaining top-level URL, undesired behavior may occur. // Undesired behavior: Return value of WebView.getUrl() may be the current URL instead of the failing URL. handler.proceed(); // &amp;lt;--- 여기가 원래 handler.cancel()로 되어 있는데 handler.proceed()로 수정하면 됩니다. ...해당 부분은 SSL 인증서가 유효하지 않은 특정 웹사이트에 웹뷰가 접근하려 할 때, handler.cancel()을 실행하면 해당 웹페이지로 접속하는 것을 차단하고, handler.proceed()를 실행하면 웹사이트로 연결하는 역할을 합니다." }, { "title": "[React Native] 물리적 Back 버튼으로 Webview 네비게이션 제어하기", "url": "/posts/React-Native-Hardware-Back-Button-Control-Webview-History/", "categories": "Tech, React Native", "tags": "React Native, Webview, Android", "date": "2022-03-08 11:49:00 +0800", "snippet": "개요하이브리드 어플리케이션을 제작할 때 실제 앱 기능은 웹으로 만들고 앱은 웹뷰를 띄워주는 용도로만 사용하는 형태로 개발을 진행합니다.그런데 안드로이드의 경우 물리적인 뒤로가기 버튼이 존재하는데 이를 그냥 방치할 경우 물리적 Back 버튼을 눌렀을 때 웹뷰가 뒤로 가지는게 아닌, 앱이 꺼져버리는 현상이 나타나게 됩니다.실제로 인앱의 네비게이션을 사용한 것이 아닌 웹뷰의 네비게이션이 사용 되었기 때문이죠.이럴 경우 Webview의 Navigation Event와 React Native의 HardwareBackButton Event 등을 이용하여 직접 제어를 해줘야 합니다.Case 1 (실패)import React, { useRef, useState, useEffect } from &#39;react&#39;;import { BackHandler } from &#39;react-native&#39;;import { WebView } from &#39;react-native-webview&#39;;export default () =&amp;gt; { const webview = useRef(); const onPressHardwareBackButton = () =&amp;gt; { if (webview.current) { webview.current.goBack(); return true; } else { return false; } }; useEffect(() =&amp;gt; { BackHandler.addEventListener(&#39;hardwareBackPress&#39;, onPressHardwareBackButton); return () =&amp;gt; { BackHandler.removeEventListener(&#39;hardwareBackPress&#39;, onPressHardwareBackButton); } }, []); return ( &amp;lt;WebView ref={webview} style={{ overflow: &#39;hidden&#39;, opacity: .99, }} source={{ uri: &#39;https://...&#39;, }} /&amp;gt; );};React Native의 BackHandler 모듈을 사용하여 뒤로가기 이벤트에 대한 핸들링을 진행할 수 있습니다.hardwareBackPress 이벤트를 생성하고 두번째 인자로 callback 함수를 넘겨줍니다. 이 callback 함수가 true를 반환하면 하드웨어의 BackNavigation 기능을 prevent 처리합니다.false를 반환하면 원래대로 앱 종료 기능이 동작합니다.useRef를 통해 Webview 객체를 받아오고 이 Webview가 현재 네비게이션을 수행할 수 있는 상태에 있는지 current의 존재 여부로 체크합니다.네비게이션 수행이 가능하다면 webview.current.back 메소드를 실행하여 webview 내에서 뒤로가기 처리를 진행합니다.실패 이유webview.current는 웹뷰가 정상적으로 로드 된 시점에서는 무조건 객체가 들어있기 때문에 제일 첫 페이지에서 뒤로가기 버튼을 눌렀을 때 앱이 종료되는 기능을 수행할 수 없습니다.Case 2 (실패) 참조: ricale.log - React Native Webview 안드로이드 백버튼 처리export default () =&amp;gt; { const webview = useRef(); const [navState, setNavState] = useState(); useEffect(() =&amp;gt; { const onPress = () =&amp;gt; { if(navState.canGoBack) { // 뒤로 갈 수 있는 상태라면 이전 웹페이지로 이동한다 webview.current.goBack(); return true; } else { return false; } } // 안드로이드 백버튼이 눌렸을 때 이벤트 리스너를 등록한다. BackHandler.addEventListener(&#39;hardwareBackPress&#39;, onPress); return () =&amp;gt; { BackHandler.removeEventListener(&#39;hardwareBackPress&#39;, onPress); } }, [navState.canGoBack]) return ( &amp;lt;WebView ref={webview} style={{ overflow: &#39;hidden&#39;, opacity: .99, }} source={{ uri: &#39;https://...&#39;, }} ref={webview} onNavigationStateChange={setNavState} /&amp;gt; );}onNavigationStateChange 이벤트는 Webview 페이지가 이동을 하게 되면 실행되는 이벤트입니다.여기에는 라우트 정보가 파라미터로 담겨져오게 되는데 canGoBack이라는 Property도 넘어옵니다. 이 Property는 현재 라우트에서 뒤로 갈 수 있는 페이지가 존재하는지 true false로 알려주는 Property입니다.해당 Property를 state로 관리하여 값이 true면 webview.current.back을 실행하여 웹뷰 이동을 하고, 아닐 경우 하드웨어 뒤로가기 버튼의 본래 기능을 사용하면 됩니다.실패 이유onNavigationStateChange는 일반적인 웹에서 잘 동작하지만 Vue나 React와 같은 프레임워크를 사용하여 제작 된 SPA 웹의 경우 History API로 페이지 이동을 하기 때문에 onNavigationStateChange가 실행되지 않습니다.Case 3 (실패) 참조: ricale.log - React Native Webview 안드로이드 백버튼 처리import React, { useRef, useState, useEffect } from &#39;react&#39;;import { BackHandler } from &#39;react-native&#39;;import { WebView } from &#39;react-native-webview&#39;;export default () =&amp;gt; { const INJECTED_CODE = ` (function() { function wrap(fn) { return function wrapper() { var res = fn.apply(this, arguments); window.ReactNativeWebView.postMessage(&#39;navigationStateChange&#39;); return res; } } history.pushState = wrap(history.pushState); history.replaceState = wrap(history.replaceState); window.addEventListener(&#39;popstate&#39;, function() { window.ReactNativeWebView.postMessage(&#39;navigationStateChange&#39;); }); })(); true; `; const onPressHardwareBackButton = () =&amp;gt; { if (webview.current) { webview.current.goBack(); return true; } else { return false; } }; useEffect(() =&amp;gt; { BackHandler.addEventListener(&#39;hardwareBackPress&#39;, onPressHardwareBackButton); return () =&amp;gt; { BackHandler.removeEventListener(&#39;hardwareBackPress&#39;, onPressHardwareBackButton); } }, []); const webview = useRef(); return ( &amp;lt;WebView ref={webview} style={{ overflow: &#39;hidden&#39;, opacity: .99, }} source={{ uri: &#39;https://...&#39;, }} ref={ref} onLoadStart={() =&amp;gt; ref.current.injectJavaScript(INJECTED_CODE)} onNavigationStateChange={setNavState} /&amp;gt; );}javascript 로직을 Webview에 삽입하여 History API가 사용 되었음을 감지하고 onpopstate 이벤트가 실행 될 때마다 onNavigationStateChange 이벤트를 Webview로 전달합니다.실패 이유원문 작성자의 글을 읽어보면 CSR 타이밍에 해당 로직을 Webview에 삽입하기 위해서 injectedJavascript Property가 아닌 onLoadStart 이벤트에서 사용한다고 나와있습니다.그런데 이렇게 작성을 하니까 window.ReactNativeWebView 객체를 찾지 못해 이벤트 전달이 되지가 않았습니다.Case 4 (성공) 출처: React Native Webview 24번 이슈import React, { useRef, useState, useEffect } from &#39;react&#39;;import { BackHandler } from &#39;react-native&#39;;import { WebView } from &#39;react-native-webview&#39;;export default () =&amp;gt; { const webview = useRef(); const [isCanGoBack, setIsCanGoBack] = useState(false); const onPressHardwareBackButton = () =&amp;gt; { if (webview.current &amp;amp;&amp;amp; isCanGoBack) { webview.current.goBack(); return true; } else { return false; } }; useEffect(() =&amp;gt; { BackHandler.addEventListener(&#39;hardwareBackPress&#39;, onPressHardwareBackButton); return () =&amp;gt; { BackHandler.removeEventListener(&#39;hardwareBackPress&#39;, onPressHardwareBackButton); } }, [isCanGoBack]); return ( &amp;lt;WebView ref={webview} style={{ overflow: &#39;hidden&#39;, opacity: .99, }} source={{ uri: &#39;https://...&#39;, }} injectedJavaScript={` (function() { function wrap(fn) { return function wrapper() { var res = fn.apply(this, arguments); window.ReactNativeWebView.postMessage(&#39;navigationStateChange&#39;); return res; } } history.pushState = wrap(history.pushState); history.replaceState = wrap(history.replaceState); window.addEventListener(&#39;popstate&#39;, function() { window.ReactNativeWebView.postMessage(&#39;navigationStateChange&#39;); }); })(); true; `} onMessage={({ nativeEvent: state }) =&amp;gt; { if (state.data === &#39;navigationStateChange&#39;) { // Navigation state updated, can check state.canGoBack, etc. setIsCanGoBack(state.canGoBack); } }}/&amp;gt; );};injectedJavascript Property로 Javascript 로직을 전달하여 실행하고 onNavigationStateChange로 받는게 아닌 onMessage로 모든 메시지를 받은 다음 state.data가 navigationStateChange인 데이터만 선별하여 canGoBack을 받아 state에 적용합니다.useEffect는 state가 변경 될 때마다 뒤로 가기가 가능한지 불가능한지를 구분해야 하기 때문에 useEffect의 실행 조건을 [isCanGoBack]으로 설정합니다." }, { "title": "[React Native] Android 빌드", "url": "/posts/react-native-android-%EB%B9%8C%EB%93%9C/", "categories": "Tech, React Native", "tags": "React Native, Android", "date": "2022-03-07 17:35:00 +0800", "snippet": "Keystore 생성cd android/appkeytool -genkey -v -keystore custom-key-name.keystore -alias custom-alias-name -keyalg RSA -keysize 2048 -validity 10000React Native 프로젝트 폴더 안에 있는 android/app 폴더로 이동한 다음, keytools 명령어를 실행합니다.keytools 명령어 부분의 custom-key-name과 custom-alias-name을 취향에 맞게(?) 변경합니다.그러면 사용자의 이름이 뭐고, 조직이 뭐고, 조직 이름이 뭐고 등등 여러가지 질문이 나올텐데 맞게 입력하면 마지막에 해당 답변들이 모두 맞는지를 다시 여쭤봅니다. 이 때 y를 입력하고 엔터를 누르면 keystore 파일이 android/app 폴더에 생성 됩니다.Keystore 정보 기재앱을 빌드할 때 해당 서명 파일에 대한 정보를 넘겨주기 위해 android/gradle.properties 파일에 Keystore에 대한 정보를 입력합니다.MYAPP_RELEASE_STORE_FILE=custom-key-name.keystoreMYAPP_RELEASE_KEY_ALIAS=custom-alias-nameMYAPP_RELEASE_STORE_PASSWORD=passwordMYAPP_RELEASE_KEY_PASSWORD=passwordcustom-key-name과 custom-alias-name은 위에 Keystore 파일을 생성할 때 입력했던 것과 동일하게 설정해주시고, Release Store Password와 Release Key Password는 Keystore 파일을 생성할 때 물어봤던 질문에 답변했던 비밀번호를 똑같이 입력합니다.Keystore 실제 적용android/app/build.gradle 파일을 열어 아래 내용을 추가합니다.android { ... defaultConfig { ... } signingConfigs { release { if (project.hasProperty(&#39;MYAPP_RELEASE_STORE_FILE&#39;)) { storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD } } } buildTypes { release { ... signingConfig signingConfigs.release } }}android/app/build.gradle 파일을 열어보시면 이미 기존에 생성되어 있던 android Property가 있는데, 그 내부를 살펴보면 defaultConfig이라는 Property가 존재합니다.해당 Property 바로 아랫줄에 위에 적힌 signingConfigs 객체를 추가합니다.그 다음, androidProperty 내부를 살펴보면 buildTypes라는 Property가 이미 있을텐데, 그 내부에 release Property 안에 signingConfig signingConfigs.release 를 추가합니다.빌드하기cd android./gradlew assembleRelease위 명령어를 입력하면 빌드가 완료되고, android/app/build/output/apk/release 안에 .apk 파일이 생성됩니다." }, { "title": "새로운 Javascript 생태계, Deno에 대해 핥아보자", "url": "/posts/About_Deno/", "categories": "Tech, Talk", "tags": "", "date": "2022-03-05 20:44:00 +0800", "snippet": " 이 문서는 Deno 전문가의 의견을 담은 게시물이 아닙니다. 필자는 Deno를 사용해 본 적도 없고 전문적인 지식을 가지지도 않았기에 “아 그냥 이런게 있나보다” 정도의 정보만을 제공합니다.데노? 디노?2018년 처음 소개 될 당시에는 ‘데노’ 라고 발음 되었지만, 심볼의 공룡과 어감으로 인해 ‘디노’라고 불리게 된 Javascript Runtime입니다.개발 계기Deno는 Ryan dahl이라는 개발자에 의해서 개발이 되었습니다.아는 사람은 아시겠지만 Ryan dahl은 NodeJS의 아버지입니다. Javascript를 지금과 같은 메이저 언어로 부상시킨 위인이죠.Deno는 NodeJS 개발 이후 마음에 들지 않는 부분들을 수정하고 개편하여 만든 새로운 에코시스템이라고 합니다.중앙 집중 형태NodeJS는 이미 굉장히 거대해진 오픈소스 생태계입니다.이 생태계에는 수많은 오픈소스들이 관리되고, 새로 생성이 되는데 이를 중앙에서 관리하는 서비스가 바로 NPM입니다.그런데 이 NPM은 Closed Source 회사가 관리한다는 아이러니가 존재합니다. 이미 수많은 오픈소스가 존재하고 새로 생겨나는 이 거대한 플랫폼이 누구 하나의 전유물이라는거죠.물론 현재의 소유주인 Microsoft는 개발자 친화적으로 행동하고 있고, NPM의 소유 권한을 행사하여 오픈소스의 의미가 퇴색될만한 일을 벌일 것이라고 생각이 되지는 않습니다만 사람 일이라는건 모르는거니까요.보안오픈소스를 사용하실 때 해당 라이브러리의 코드를 모두 열어보고 해석하여 사용하시는 분 계신가요?그런 분이라면 이 부분에 딱히 공감을 못하시겠지만, 대부분의 개발자는 “아 그런가보다” 하고 Usage만 대충 읽은 다음 npm install ...을 입력합니다.사실 이건 다른 산업 분야의 관점으로 바라보자면 매우 이상한 일입니다.일면식도 전혀 없는 사람에게 집 열쇠, 계좌 비밀번호, 인감 도장, 신분증 등을 모두 공개한 다음 “자 이제 이걸로 나에게 이로운걸 해줘!” 라고 말하는 꼴이거든요.현재 오픈소스 생태계는 개발자 전원의 신뢰로 이루어지고, 이게 또 잘 돌아가니까 딱히 별 다른 문제를 느끼지는 않습니다만 만약 오픈소스 개발자가 자신의 패키지에 보안 상 위험한 코드를 집어넣는다면 무슨 일이 벌어질까요?NodeJS는 사용자 컴퓨터에 존재하는 모든 리소스에 대한 접근 권한을 가집니다. 그렇기에 NodeJS 환경에서 구동되는 라이브러리도 실행자의 컴퓨터 자원에 접근이 가능합니다.당연한거겠죠. 컴퓨터에 설치하고 실행하는 소스코드니까요.그런 생태계에서 마음만 먹는다면 불특정 다수의 컴퓨터 자원을 특정 서버로 전송하는 일까지도 가능합니다.Deno는 코드를 직접적으로 다운로드 받는 것이 아닌, Sandbox에서 실행을 하기에 해당 이슈를 발생시킬 원인 자체를 차단한다고 합니다.패키지 관리node_modules는 의존성 패키지가 설치 되는 폴더입니다. 그 디펜던시는 package.json 파일에 의해서 관리됩니다.그런데 node_modules 폴더 안에 있는 패키지를 하나 열어보시면 그 안에도 package.json 파일이 존재하며, 이 파일 안에는 해당 패키지가 의존하는 또 다른 패키지들의 목록이 존재합니다.이렇게 되면, 내가 필요해서 직접적으로 설치한 패키지와, 디펜던시의 디펜던시가 서로 중복 설치 될 가능성이 존재합니다. 번들 파일의 사이즈가 불필요하게 무거워지게 되는거죠.유령 의존성예를 들어, A라는 패키지는 B라는 패키지와 의존성을 갖습니다.내가 필요한건 A 패키지라서 프로젝트에는 A만을 설치했는데, B 패키지도 사용이 가능하다는 문제가 있는거죠.이럴 경우, A 패키지만 삭제해도 A와 의존관계에 있는 B까지 같이 삭제되어 B 패키지를 사용하는 모든 부분에서 이슈가 발생한다는 문제를 야기합니다.Deno는 package.json node_modules를 모두 제거하였기 때문에 위 문제점들이 발생하지 않습니다.마치며2018년에 처음 발표가 된 생태계이고, 이미 대다수의 Javascript 개발자가 NodeJS 진영에 포진해 있는 점에서 생각해보면 Deno는 현재 모든 회사들이 필수적으로 고려해야 할 정도로 영향력을 가졌다고 생각되진 않습니다. 다만, Deno의 탄생 배경에서 설명하는 문제점들이 실제로 NodeJS 진영에서 벌어지고 있고 이를 개선하는데 동참하는 사람들이 결코 적지도 않습니다. 그러니 추후에는 여러 개발자들이 회사의 프로젝트에서 Deno를 고려해보는 시대가 올 것이라 추측해볼 수도 있을 것 같습니다." }, { "title": "SPA에서 Cookie를 사용할 때의 주의점", "url": "/posts/caution-use-cookie-on-spa/", "categories": "Tech, Talk", "tags": "Web, Cookie, SPA", "date": "2022-03-04 22:13:00 +0800", "snippet": " 본 문서는 서론이 좀 깁니다. 만약 Cookie에 대해서 잘 알고 계신다면 여기를 눌러서 본론으로 바로 넘어가주세요!웹에서 데이터 유지하기웹에서 사용되는 데이터들은 연결이 끊어지면 모두 날아가는 휘발성 데이터가 대부분이기에, 다음 접속 시에도 정보를 유지하기 위한 몇 가지 수단이 있습니다.대표적으로 Cookie, Session, LocalStorage가 있습니다.각각이 가진 데이터의 특징이 너무나 명확해서 적재적소에 활용하면 좋은 퍼포먼스를 낼 수 있지만 세 가지 방식 중 SSR 타임에 이용할 수 있는 데이터는 Cookie가 유일하기에 대부분의 개발자들이 로그인 정보 등을 보관하기 위해 Cookie를 사용합니다. 이 문서에서는 Cookie만을 알아볼 예정입니다.CookieCookie는 사용자의 컴퓨터에 직접적으로 다운로드 되는 텍스트 형태의 데이터입니다.비휘발성덕분에 웹과의 연결이 끊겨도 유실 될 일이 없어서 배너 다시 보지 않기나 자동 로그인 등의 기능에 활용 됩니다.문자열만 저장Cookie는 텍스트 형태의 파일이라고 위에서 언급했습니다.그렇기 때문에 JSON이나 배열과 같은 데이터들이나, Boolean, Number와 같은 자료형을 모두 문자로 변환하여 저장해야 합니다.기본형의 경우에 문자열로 변환하는 것은 그리 어렵지 않으나, 객체같은 경우 JSON.stringify를 통해 문자열로 변환하고, 추후 데이터를 꺼낼 때 JSON.parse를 이용하여 원복하는 형태로 이용해야 합니다.저장 된 도메인에서만 이용Cookie는 로그인 정보를 저장하는데 주로 사용하는 방식인 만큼 보안이 중요합니다.그렇기 때문에 Javascript로 사용자의 컴퓨터에 저장 된 모든 Cookie를 불러오는 것은 불가능합니다.Cookie를 만약 www.naver.com에서 token이라는 Key로 저장을 했다면, 이를 www.facebook.com에서 token이라는 Key로 참조했을 때 undefined가 반환되게 됩니다.데이터 저장 규칙 정의해당 Cookie를 얼마나 유지 할 것인지, 어떤 Location에서 사용할 것인지 등 다양한 옵션을 정의할 수 있습니다.expiresCookie가 만료 될 일자를 Date 형태로 삽입하면 해당 일자가 되었을 때 브라우저에서 사라집니다.max-ageCookie의 수명을 초 단위로 삽입할 수 있습니다. 설정한 수명이 끝나면 소멸합니다. 다만 구형 IE 브라우저에서는 해당 옵션을 지원하지 않습니다. 만약 expires와 max-age를 둘 다 설정했다면, max-age를 무시하고 expires에 기준합니다.path어떤 페이지에서만 사용할 수 있는 데이터인지 제한할 수 있습니다.path에는 String 형태로 URI의 Segment 부분이 들어갑니다.예를 들면, https://www.naver.com/blog 주소 내부에 있는 모든 라우트에서만 token을 유지하고 싶다면, path를 /blog로 설정하면 됩니다.그러면 해당 토큰은 /blog 혹은 /blog/my-first-blog와 같은 /blog의 하위 페이지에서만 사용할 수 있습니다.SPA에서 Cookie 사용 시 주의할 점 SPA라고 말은 했지만, 실제로 제가 이 상황을 마주한 케이스는 Nuxt입니다.다만, SPA의 특징으로 인해 발생되는 이슈이기 때문에 다른 프레임워크도 마찬가지일 것이라 생각하고 작성합니다.대부분의 경우에서 Cookie를 사용하는 것은 아무런 문제가 되지 않지만, path를 통해 Cookie의 사용 범위에 제약을 두는 순간 예상과는 다른 방식으로 Cookie가 동작합니다.Test Case동일한 프로젝트에 관리자와 부관리자 라는 두 유저가 있습니다.두 유저는 동일한 CMS를 통해 웹사이트를 관리하는데 관리자는 /admin으로 진입하여 사용하고, 부관리자는 /semi-admin로 진입하여 사용합니다.관리자가 로그인을 하면 token은 token이라는 Key로 관리되며, path는 /admin으로 지정합니다.부관리자는 마찬가지로 Key를 token으로 설정하고, path를 /semi-admin으로 지정합니다.만약 프로젝트에 진입할 때 /로 진입한다면 /admin으로 강제 Redirect를 시킵니다.문제점보기에는 아무 문제 없어보입니다. 다만 이 로직을 SPA 프레임워크로 작성한다면 문제가 생깁니다.최초 진입 시, /admin이나 /semi-admin을 통해 진입하지 않고 /에 접속하여 /admin으로 이동 된 경우, 브라우저는 현재 사용자의 진입 위치를 /admin이 아닌 /로 착각하기 때문에 /admin Path에 지정 된 Cookie의 참조가 불가능합니다.그렇기 때문에 이후 /admin에서 진행되는 모든 자격 검증에 이슈가 발생하게 됩니다.SPA에서의 페이지 이동은 실제 페이지 이동이 아닌, History State를 Javascript로 변경하여 페이지가 이동한 것 처럼 보이게 만든 것이기 때문입니다.해결방법내키진 않지만 path를 /로 선언하여 전체 페이지에서 통합적으로 관리하게 만들어야 합니다.그리고 각각의 페이지에서 동시 로그인을 지원해야만 한다면 Token을 저장할 때 Key를 서로 다르게 저장한다면 별 문제 없이 프로그램이 동작하게 됩니다." }, { "title": "광택용 천을 샀습니다", "url": "/posts/bought-clothe/", "categories": "Life, Review", "tags": "Life, Apple", "date": "2022-03-02 22:54:00 +0800", "snippet": "이게 뭔데2021년 말쯤에 선보인 애플의 야심작(?), 광택용 천입니다.좋은 의미이건 안좋은 의미이건 여러모로 많은 사람들의 입에서 회자된 제품이기도 하죠.그도 그럴 것이, 고작 해봐야 유리닦개를 25,000원이라는 다소 비싼 가격에 출시함과 더불어 홈페이지에서 해당 제품을 홍보할 때 ‘애플의 모든 제품군과 호환이 가능하다.’ 라는 식으로 상품 소개를 작성한 사실이 회자되어 “애플이 만든 제품 중 가장 호환성이 좋은 제품”이라는 식으로 놀림감이 되었기 때문입니다.이걸 왜 샀는데최근에 제가 M1 Pro 맥북을 깡통으로 하나 장만하기도 했고, 기존에 사두고 한동안 안썼던 아이패드 Pro 4도 Sidecar 기능을 활용한답시고 최근에 꽤 사용하고 있기에 기기들의 액정을 닦아낼 천이 필요했습니다. 예전에는 안경닦이로 닦았었는데 라섹을 한 이후로 딱히 안경닦이를 갖고 있지도 않고, 물티슈로 대충 닦자니 물티슈의 거친 표면에 의해 액정의 코팅이 손상되면 정말 마음이 아플 것 같았기에 액정 청소를 미루던 상황이였습니다.그러다가 문뜩, “애플에서 제작한 광택용 천은 애초에 700만원 짜리 디스플레이를 청소하기 위해서 만들어진 천인데 액정을 닦기에 적합한 소재로 만들어져 있겠지?” 라는 생각이 들었고, 의외로 놀림을 당한 것 치고는 출시 초기에 배송이 12주까지 지연되기도 했었으며 실제로 사용해 본 사람들의 의견이 대체적으로 괜찮아서 구입하게 되었습니다.출시 초기와는 다르게 지금은 1~2 영업일 이내에 배송이 완료 된다고 나오니 금방 받아볼 수 있을 것 같습니다.받아보면 리뷰 게시글 한 번 작성해보도록 하겠습니다. 감사합니다!" }, { "title": "HTML을 Jade(PUG)로 바꿔주는 사이트", "url": "/posts/html-to-jade/", "categories": "Tech, Talk", "tags": "Tech, Jade, PUG, HTML", "date": "2022-02-24 13:52:00 +0800", "snippet": "서비스 html2pug개요저는 Vue로 작업을 할 때 HTML작업은 pug를 사용하여 작업을 합니다.처음부터 제가 개발을 했던 프로젝트라면 pug로 개발을 시작했겠지만, 기존에 개발되던 프로젝트를 인수받아 작업하는 것이라면 얘기가 좀 달라집니다.기존에 작성 되어 있던 템플릿을 HTML에서 pug로 변환하는 작업이 필요해지는데, 이를 쉽게 도와주는 서비스를 소개합니다.차별점다른 변환 사이트 한글을 강제로 HEX로 인코딩 하기 때문에 소스코드의 가독성을 해칩니다. HTML Attribute의 따옴표를 강제로 큰 따옴표로 변환하거나, 작은 따옴표로 변환합니다. 트리 탐색 알고리즘의 문제로 인해 트리가 깊어지면 해당 부분이 잘리는 이슈가 있습니다. Depth를 커스터마이징 할 수가 없어서 코드 컨벤션을 맞추기 힘든 부분이 있습니다.해당 사이트 한글은 한글 그대로 변환해줍니다. HTML Attribute의 따옴표를 어떻게 설정하고 싶은지 체크할 수 있습니다. 트리 탐색 알고리즘에 대한 이슈가 없습니다. Depth를 입맛대로 커스터마이징 할 수 있습니다. Vue에 맞는 문법으로 변환할 수도 있습니다." }, { "title": "[Svelte] 스벨트에서 사용하는 Computed", "url": "/posts/reactivity-on-svelte/", "categories": "Tech, Svelte", "tags": "Svelte, Computed", "date": "2022-02-21 08:58:00 +0800", "snippet": "Vuejs의 ComputedComputed는 Vue.js에서 사용되는 컴포넌트의 Property입니다.export default { computed: { sum() { // 3 const { a, b } = this; return a + b; }, }, data() { return { a: 1, b: 2, }; },}위 코드와 같이 computed Property 내부에 로직을 정의하면 내부에서 사용 된 상태값이 변경 될 때마다 해당 상태값도 같이 변경되어 반환되는 기능을 하고 있습니다.Svelte의 ComputedSvelte에서는 Declarations라는 이름으로 불립니다.&amp;lt;script&amp;gt;let number = 1;$: pow = Math.pow(number, 2);&amp;lt;/script&amp;gt;&amp;lt;div&amp;gt; {number}의 제곱은 {pow}입니다.&amp;lt;/div&amp;gt;이런 식으로 $: 키워드를 사용하여 정의할 수 있습니다." }, { "title": "나를 칭찬해주세요 페이지 제작 완료! (feat. Svelte)", "url": "/posts/recommend-for-me/", "categories": "Tech, Talk", "tags": "", "date": "2022-02-20 19:36:00 +0800", "snippet": "구축한 웹사이트 찬영이를 칭찬해주세요! 웹사이트개요원래는 추천사를 Github의 README 형태로 관리하고 있었습니다.그러다보니 비개발자인 친구 혹은 버전 관리 경험이 전무한 개발자들에게 추천사 작성을 부탁하기가 어려웠다는 점이 문제로 다가왔습니다.그럼에도 불구하고 Fork와 Pull Request를 공부하여 추천사를 작성해준 고마운 친구들이 있었지만 방치해도 될 문제는 아니라고 생각되어 보다 쉽게 추천사를 작성해줄 수 있도록 에디터를 하나 만들어야겠다고 생각하게 되었습니다.개발 도구본 웹사이트는 Svelte + Sapper를 사용하여 제작되었습니다.백엔드는 Firebase Functions가 사용 되었고, Database는 NoSQL 기반의 Firebase Firestore가 사용되었습니다.Svelte2021년 스택오버플로우에서 조사한 프론트엔드 개발자에게 가장 많은 사랑을 받는 개발 도구 1위SapperSvelte를 기반으로 한 SSR 및 자동 라우트 기능을 지원하는 프레임워크 (Vue의 Nuxt와 비슷한 포지션)익숙하지도 않은 Svelte를 사용한 이유일단 개발자들이 사용해보면서 긍정적인 경험을 느꼈다고 한 것에는 이유가 있었을 것이고, 현업에 당장 적용하기 힘든 개발 방식에 대한 학습은 토이 프로젝트에서 진행하면서 하나씩 배워나가는게 좋을 것 같다고 생각되어 굳이 적용 해보게 되었습니다.Firebase를 사용하게 된 이유Firebase는 꽤 예전부터 많은 개발자들의 개발 비용을 줄여준 유용한 Serverless 플랫폼입니다.그럼에도 불구하고 회사에서 웹앱을 개발할 때 Push Notification이나 Dynamic Link 정도를 구현하기 위해서 사용 했던 것을 제외한다면 어차피 자체적으로 개발 된 백엔드 API를 사용했기 때문에 Firebase에 대해서 굳이 공부하려고 하지도 않았던 것 같습니다.그러던 도중 어쩌다가 기회가 되어 Firebase의 Firestore를 연결하여 사용해보았는데, 별도의 데이터베이스 설계, 백엔드 API 작성의 수고가 없다는게 어떤 의미인지 몸소 깨닫게 되었고 그 이후부터 Firebase의 팬이 되었기 때문에 본 프로젝트에 사용하였습니다.의존성 패키지FirebaseGoogle의 Firebase 플랫폼 서비스와 NodeJS의 개발 환경을 손쉽게 연동 및 사용할 수 있는 라이브러리입니다.본 어플리케이션에서 사용한 서비스는 Firestore와 Functions가 있습니다.Papercss보다 귀여운 웹페이지를 제작할 수 있게 도와주는 CSS Library입니다.moment손쉽게 날짜를 계산할 수 있는 패키지입니다.canvas-confettiCanvas를 통해 다양한 파티클 효과를 사용할 수 있는 라이브러리입니다.node-sensNaver의 Sens 서비스를 쉽게 이용할 수 있도록 설계한 NodeJS 라이브러리입니다.Sens는 외부 프로그램에서 문자를 전송할 수 있도록 API를 지원하는데, 이 과정에서 Header에 담아서 보내야 할 정보의 암호화가 번거로워 사용하게 되었습니다." }, { "title": "Visual studio code에서 깃 메시지 상세하게 남기기", "url": "/posts/visual_studio_code%EC%97%90%EC%84%9C_%EA%B9%83_%EB%A9%94%EC%8B%9C%EC%A7%80_%EC%83%81%EC%84%B8%ED%95%98%EA%B2%8C_%EB%82%A8%EA%B8%B0%EA%B8%B0/", "categories": "Tech, Git", "tags": "Git, Commit, Tech", "date": "2022-02-17 10:33:00 +0800", "snippet": "개요저번에 포스팅한 Git 메시지 컨벤션 문서에서 보면 HEAD와 BODY에 대한 소개가 간단하게 나옵니다.해당 글을 요약하자면, “많은 개발자들이 커밋 메시지에 대해서 무신경하니까 컨벤션에 맞게 상세하게 작성하는게 좋다”라는 내용을 말하는 글이였습니다.저는 Git을 사용할 때 별도의 GUI 툴을 사용하지 않고 CLI로만 처리하거나, Visual studio code에 내장 되어 있는 소스 관리 툴을 사용하는 편입니다.그런데 Visual Studio Code에 있는 Commit Message 입력창은 너무 작아서 HEAD, BODY 구분이 없이 HEAD만 작성하게 되는 경향이 있는 것 같습니다.어떻게 하면 Visual Studio Code에서도 HEAD, BODY 구분 지어 메시지를 작성할 수 있을까요?방법제일 첫 줄에는 HEAD에 들어갈 메시지를 작성해주시고, 엔터를 이용하여 줄을 두 번 내린 다음 작성하시면 해당 문구는 BODY로 작성되게 됩니다.결과이렇게 보기 좋게 커밋이 올라갑니다!" }, { "title": "NodeJS 설치 및 NPM 사용 예시", "url": "/posts/nodejs-and-npm/", "categories": "Tech, NodeJS", "tags": "NodeJS", "date": "2022-02-15 13:42:00 +0800", "snippet": "개요NodeJS는 Google이 제작한 Javascript 엔진인 V8 엔진을 이용하여 만들어진 Javascript 런타임입니다.본래 Javascript라고 하면 브라우저 상에서만 동작하여 홈페이지를 만들 때 제외하고는 아예 쓸 수가 없는 언어 중 하나였습니다.그런데 NodeJS라는 생태계가 생겨나면서 웹, 서버를 포함한 거의 대부분의 분야에서 Javascript를 사용할 수 있게 되었습니다.설치 방법여기에 들어가서 원하는 버전을 다운 받으시면 됩니다.안정적인 구동을 원하신다면 LTS 버전을, 최신 기능을 이용하고 싶다면 현재 버전을 다운받아주세요.NPMNodeJS를 설치할 때 npm이라는 패키지 매니저도 같이 설치됩니다.npm은 NPM 커뮤니티에 업로드 된 패키지를 프로젝트에 손쉽게 적용하기 위해 사용하는 툴입니다.사용 예시Moment라는 라이브러리가 있습니다.많은 Javascript 개발자들이 사용하는 날짜 계산 라이브러리인데, 이걸로 예제를 들어보겠습니다.프로젝트 폴더 생성mkdir my-first-npmcd my-first-npmnpm init위 명령어를 입력하면 my-first-npm이라는 폴더를 생성하고, 이 폴더 내부를 npm에 의해서 관리되는 프로젝트라고 선언하게 됩니다.package.json파일이 폴더 내부에 생기게 될텐데, 이는 아직 몰라도 됩니다.패키지 설치npm i -S moment이 명령어를 입력하면 해당 프로젝트 내부에서 moment 패키지를 사용할 수 있도록 다운로드를 받게 됩니다.코드 작성폴더 내부에서 index.js 폴더를 생성하고 해당 파일에 아래와 같은 코드를 작성합니다.const moment = require(&#39;moment&#39;);(() =&amp;gt; { const now = moment().format(&#39;YYYY-MM-DD&#39;); const tomorrow = moment().add(1, &#39;day&#39;).format(&#39;YYYY-MM-DD&#39;); const yesterday = moment().add(-1, &#39;day&#39;).format(&#39;YYYY-MM-DD&#39;); console.log(&#39;now: &#39;, now); console.log(&#39;tomorrow: &#39;, tomorrow); console.log(&#39;yesterday: &#39;, yesterday);})();작성한 코드 실행node index.js터미널에서 위와 같은 명령어를 실행하면 오늘 날짜, 내일 날짜, 어제 날짜 순서대로 표시가 됩니다.now: 2022-02-15tomorrow: 2022-02-16yesterday: 2022-02-14원래라면 날짜를 계산하고 포맷팅을 하기까지 상당량의 코드가 들어갔겠지만 이를 npm 생태계의 라이브러리를 이용한다면 매우 쉽게 구현할 수 있습니다.npm보다는 yarn저는 패키지 매니저로 npm보다는 yarn을 주로 사용하기 때문에 yarn으로 설명 된 문서가 많습니다.문서의 흐름을 매끄럽게 따라가고 싶으시다면 아래 명령어를 입력하여 yarn을 설치해주세요!npm i -g yarn" }, { "title": "Puppeteer 라이브러리를 이용한 웹 크롤러 제작 방법", "url": "/posts/puppeteer-crawler/", "categories": "Tech, NodeJS", "tags": "Tech, Crawler, Puppeteer, Chromium", "date": "2022-02-15 13:13:00 +0800", "snippet": "웹 크롤러개발자라면 한번 쯤 특정 사이트의 자료들을 자동으로 탐색하고 긁어와야 하는 경우가 생깁니다. (아마도…)예를 들어, 인기가 많은 어떤 쇼핑몰이 있습니다. 이 쇼핑몰은 신상품이 발매 될 때마다 공전의 히트를 치면서 신상품 공개 몇 분만에 매진이 되기 때문에 매 분 단위로 웹사이트를 봐야만 합니다. 내가 시간이 아주 많은 사람이라서 새로고침 신공을 할 수 있다면 정말 좋겠지만, 대부분은 그렇지 않죠.이럴 때 사용하는게 웹 크롤러입니다. 웹 크롤러는 홈페이지의 소스코드를 읽는 봇이라고 보면 됩니다.이러한 크롤러에게 타이머 모듈을 붙여서 사용하면 일정 주기마다 코드를 긁고, 이전에 긁었던 코드와 이번에 긁은 코드가 다를 때 알림을 울리게 만들면 쇼핑몰을 매 분마다 직접 읽을 필요가 없어지죠.PuppeteerPuppeteer는 NodeJS 환경에서 웹 크롤러를 만들 때 많은 사람들이 이용하는 패키지입니다.Chromium을 사용하여 Headless 환경에서 특정 웹사이트에 방문, 제어 등을 가능하게 합니다. (물론 Headless 옵션을 끌 수도 있습니다.)ChromiumChromium은 Google이 주도하는 웹 브라우저 오픈소스입니다.오늘날의 많은 브라우저는 이를 이용하여 제작되었습니다.Puppeteer 사용해보기Crawler 프로젝트 생성하기mkdir my-first-crawlercd my-first-crawlernpm init위 명령어를 실행하여 my-first-crawler 폴더가 npm 프로젝트라고 선언합니다.패키지 설치yarn add puppeteer위 명령어를 실행하여 Puppeteer 라이브러리를 설치하세요.Example 사이트의 스냅샷을 촬영하고 PDF로 만들어보기파일 생성방금 전에 만든 my-first-crawler 폴더 최상단에 index.js 파일을 생성합니다.코드 작성index.js 파일 안에 다음과 같이 코드를 작성합니다.const puppeteer = require(&#39;puppeteer&#39;);(async () =&amp;gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&#39;https://example.com&#39;); await page.pdf({ path: &#39;hn.pdf&#39;, format: &#39;a4&#39; }); await browser.close();})();작성한 코드 실행하기node index.js결과프로젝트 최상단에 hn.pdf 라는 파일이 생기게 되고, A4 사이즈로 https://example.com 페이지가 캡처되어 저장 된 것을 볼 수 있습니다." }, { "title": "기술 블로그에 Clap을 추가했습니다! (feat. Applause Button)", "url": "/posts/added-clap/", "categories": "Tech, Talk", "tags": "Talk, Blog, Extension, Jekyll, Applause Button", "date": "2022-02-14 16:27:00 +0800", "snippet": "개요Github Pages와 같은 정적 웹사이트는 기본적으로 사용자에게 이미 결과가 정해진 콘텐츠를 보여주기 위해 탄생한 솔루션이라서 사용자와의 상호작용이 상대적으로 덜 중요합니다.하지만 그렇다고 해서 “사용자와의 상호작용이 완전 불필요한가?” 생각해보면 그건 또 아닙니다.내가 작성하는 게시물이 옳은 게시물인지, 얼마나 많은 호응을 얻고 있는지에 대해서 알 수 있어야 추후 올라오는 게시물에도 더욱 많은 신경을 쓸 수 있기 때문이죠.그래서 많은 기술 블로그들은 정적 웹사이트에서 댓글을 사용할 수 있도록 Disqus와 같은 서비스를 연동하여 사용하기도 합니다.본 문서에서 소개할 Clap도 사용자의 호응 척도를 측정하기 위한 서비스입니다.Applause Button제가 블로그에 적용한 서비스는 Applause Button입니다.특정 플랫폼에 구애받지 않고 모든 유형의 웹사이트에 쉽게 삽입할 수 있다는 장점이 있죠.원리Applause Button 서비스는 CDN 혹은 NPM 패키지 두가지 방식으로 적용할 수 있습니다.applause-button라는 Custom Element를 정의하여, 해당 태그를 사용하기만 하면 현재 접속한 URL에 기반하여 박수 횟수를 누적할 수 있는 것이죠.적용 방법CDN 추가페이지의 최상단에 Applause Button을 적용하기 위한 CDN을 적용합니다. &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/applause-button/dist/applause-button.css&quot;&amp;gt; &amp;lt;script src=&quot;https://unpkg.com/applause-button/dist/applause-button.js&quot;&amp;gt;&amp;lt;/script&amp;gt;CSS 추가applause-button 태그의 사이즈를 정하기 위해서 Custom CSS도 추가합니다.applause-button { width: 80px; height: 80px; margin: 0 auto; .count-container { color: inherit; }}혹은applause-button { width: 80px; height: 80px; margin: 0 auto;}applause-button .count-container { color: inherit;}페이지에 추가박수 버튼을 표시할 위치에 태그를 추가해줍니다.&amp;lt;applause-button class=&quot;mb6&quot;color=rgb(79,177,186)url=https://univdev.github.io/posts/added-clap/ &amp;gt;&amp;lt;/applause-button&amp;gt;Propertycolor Property는 박수 버튼에 적용할 색상을 적어주시면 됩니다.url Property는 해당 웹 페이지의 URL을 적어줍니다. 박수는 url property에 작성 된 URL에 따라 누적되기 때문에 반드시 고유한 URL이 되도록 작성해주셔야 합니다.마무리이처럼 아주 간단한 방법으로 독자들과 상호작용이 가능한 창구를 적용하는게 가능합니다.그러니 제가 작성한 글이 마음에 드신다면 다들 박수 한번 부탁드려요!참고Lazy Ren - Add Applause Button for Jekyll Post" }, { "title": "프론트엔드 개발자가 알아야 할 Mobile UI 이름들", "url": "/posts/front-end-ui-names/", "categories": "Tech, Talk", "tags": "Frontend, Mobile, UI", "date": "2022-02-14 12:58:00 +0800", "snippet": "원문Nomenclature of mobile app visual elements — Android vs iOS 해당 문서에 나오는 용어 이름과 사진을 참고하여 제 방식대로 간단하게 설명하였습니다.개요프론트엔드 개발자는 개발자이기도 하면서 디자이너이기도 합니다.사용자에게 어떻게 하면 보다 클릭 횟수가 적고 부드러운 사용자 경험을 줄지 생각해야 하는게 디자이너의 업무와 상당량 겹치기 때문입니다.그러다보니 개발자인데도 디자이너와 원활한 대화를 하기 위한 스킬이 필수적입니다. 그런 이유로 프론트엔드 개발자는 특정 UI를 업계에서 뭐라고 부르는지에 대해서 자세히 알고 있어야 합니다.Top App bar vs Naivgation barAndroid - Top App BariOS - Navigation Bar상단에 고정적으로 위치하여 앱 탐색에 직접적인 도움을 주고, 메뉴를 통해 사용자가 다양한 기능을 이용할 수 있도록 배치되는 UI입니다.Top Navigation vs Segmented ControlsAndroid - Top NavigationiOS - Navigation Bar하나의 페이지에서 각각 다른 섹션을 표시하고자 할 때 사용하는 네비게이터입니다.Bottom Navigation vs Tab BarAndroid - Bottom NavigationiOS - Tab Bar하단에 위치하여 페이지를 탐색할 수 있도록 도와주는 네비게이션입니다.Dialog vs AlertAndroid: DialogiOS: Alert상호작용이 일어날 때, 해당 기능에 대해서 사용자의 의견을 묻거나 해당 기능으로 인해 발생할 상황에 대해 안내할 때 사용합니다.Full Screen Dialog vs PopoverAndroid - Full Screen DialogiOS - Popover기본적으로는 Dialog처럼 기존 화면 위에 표시 되는데, 보여주거나 입력 받아야 할 내용이 많아서 전체 영역을 덮어야 하는 Dialog를 나타냅니다.Confirmation Dialog vs PickersAndroid: Confirmation DialogiOS: Pickers사용자로부터 일정 범위 안에 들어오는 값을 선택하여 받을 때 사용하는 UI 입니다.Modal Bottom Sheet vs Activity ViewsAndroid - Modal Bottom SheetiOS - Activity Views화면 아래부터 올라오는 형태를 가진 UI입니다.본래 화면과 추가 정보를 동시에 봐야하는 상황에 주로 쓰입니다.Dropdown Menu vs Action SheetAndroid - Dropdown MenuiOS - Action Sheet사용자에게 여러가지 기능 중 하나를 선택하게 하기 위해 사용하는 UI 입니다.Floating Action Button vs Call to Action ButtonAndroid: Floating Action ButtoniOS: Call to Action Button해당 화면에서 고정적으로 사용하는 기능을 어떤 상황에서도 사용할 수 있도록 화면의 특정 영역을 항상 차지하고 있는 UI를 뜻합니다." }, { "title": "[React Native] 유저 위치 트래킹", "url": "/posts/react-native-tracking/", "categories": "Tech, React Native", "tags": "React Native, GPS, Coordinates", "date": "2022-02-14 10:25:00 +0800", "snippet": "개요가끔 어플리케이션을 만들 때 사용자의 위치를 추적해야 하는 경우가 있습니다.주변 맛집을 찾아주거나, 운전 중 도로 상황을 알려주기 위한 어플리케이션을 제작할 때를 예로 들 수 있는데요.사용자의 위치 정보를 추적하는 방법을 아래에 기재합니다.패키지 설치사용자의 위치 정보를 손쉽게 추적하기 위한 패키지를 설치합니다.yarn add react-native-geolocation-service추적 권한사용자의 현재 위치를 추적하는 것은 매우 민감한 사항입니다.그러다보니 위치에 접근하는 기능은 웹, 안드로이드, iOS 불문하고 사용자에게 위치 정보 접근 동의를 받는 절차를 거쳐야 합니다.iOSimport Geolocation from &#39;react-native-geolocation-service&#39;;const App = () =&amp;gt; { Geolocation.requestAuthorization(level);};export default App;iOS는 react-native-geolocation-service 패키지에서 제공하는 requestAuthorization 메소드를 통해 쉽게 동의를 받을 수 있습니다.대부분의 경우에서 앱을 접속하고 처음 보는 페이지에 적용하여 동의를 받아둔 상태에서 서비스를 제공합니다.AndroidAndroid는 Android 정책에서 제공하는 권한 부여 방식을 사용해야 합니다. &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&amp;gt; &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&amp;gt;/android/app/src/main/AndroidManifest.xml 파일에 위에 기재한 코드를 적용합니다.import { PermissionsAndroid } from &#39;react-native&#39;;export default () =&amp;gt; { useEffect(() =&amp;gt; { PermissionsAndroid.requestMultiple([ PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION, PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION, ]); }, []); // ...}마지막으로, 권한을 부여받을 상황에 맞는 페이지에 해당 코드를 추가합니다. 보통은 앱에 접속하자마자 권한을 받으므로, App.jsx 파일에 적용합니다.사용자의 위치를 한 번만 얻기Geolocation.getCurrentPosition( (position) =&amp;gt; { console.log(position); }, (error) =&amp;gt; { // See error code charts below. console.log(error.code, error.message); }, { enableHighAccuracy: true, timeout: 15000, maximumAge: 10000 });Geolocation 패키지의 getCurrentPosition 메소드를 사용하면 사용자의 디바이스가 있는 위치를 받아올 수 있습니다.사용자의 위치를 계속 추적하기Geolocation.watchPosition((position) =&amp;gt; { const { latitude, longitude } = position.coords; console.log(latitude, longitude);});Geolocation 패키지의 watchPosition 메소드를 사용하면 사용자의 디바이스의 위치가 변경 될 때마다 callback이 실행되어 사용자의 위치를 갱신할 수 있습니다.같이 보면 좋을 문서react-native-geolocation-service API 문서[React Native] 네이버 지도 연동" }, { "title": "[React Native] 네이버 지도 연동", "url": "/posts/react-native-naver-map/", "categories": "Tech, React Native", "tags": "React Native, Map", "date": "2022-02-14 10:25:00 +0800", "snippet": "개요웹, 앱을 불문하고 사용 될 정도로 지도 서비스는 굉장히 범용적이고 유용한 서비스입니다.전세계적으로 구글 지도를 사용하지만 국내에서는 구글 지도의 한계 때문에 국내에서 서비스하는 지도를 사용해야 하는데, 보통 네이버 지도와 카카오 지도를 사용합니다.이 문서에서는 네이버 지도를 연동하는 방법에 대해서 기술합니다.패키지 설치네이버 지도를 이용하기 위하여 패키지를 설치해줍니다.yarn add react-native-nmap초기 설정패키지를 설치하고 React Native에 연동하기 위해 거쳐야만 하는 과정이 있습니다.어플리케이션 등록네이버에서 제공하는 API 서비스를 이용하기 위해서는 개발하고 있는 어플리케이션을 등록해야 합니다.자세한 내용은 여기를 참고해주세요. 아래부터는 Application을 네이버에 등록했다는 전제 하에 기술합니다.AndroidClient ID 연동allprojects { repositories { ... // 네이버 지도 저장소 maven { url &#39;https://naver.jfrog.io/artifactory/maven/&#39; } }}/android/build.gradle 파일에 //네이버 지도 저장소 아래에 적힌 maven을 추가합니다. &amp;lt;meta-data android:name=&quot;com.naver.maps.map.CLIENT_ID&quot; android:value=&quot;YOUR_CLIENT_ID_HERE&quot; /&amp;gt;/android/app/src/AndroidManifest.xml 파일의 &amp;lt;application&amp;gt; 태그 안쪽에 해당 구문을 추가합니다.YOUR_CLIENT_ID_HERE를 네이버에서 발급 받은 CLIENT ID 토큰으로 대체해줍니다. com.naver.maps.map.CLIENT_ID의 CLIENT_ID는 대체하지 마세요!iOSClient ID 연동&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;&amp;lt;plist version=&quot;1.0&quot;&amp;gt;&amp;lt;dict&amp;gt;... &amp;lt;key&amp;gt;NMFClientId&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;YOUR_CLIENT_ID_HERE&amp;lt;/string&amp;gt;...&amp;lt;dict&amp;gt;&amp;lt;plist&amp;gt;info.plist 파일에 key와 string 태그를 한 쌍으로 추가합니다.YOUR_CLIENT_ID_HERE 문자열을 CLIENT ID 토큰으로 대체해줍니다.git-lfs 설치 및 적용npm i -g git-lfscd iosgit-lfs installiOS에서는 네이버 맵을 원활하게 사용하기 위해서 git-lfs를 설치해야 합니다.네이버 지도는 아무래도 저장되는 정보가 방대하다보니 Git에 업로드 할 때 문제가 발생합니다. Git 서버에서 제공하는 용량에 제한을 받지 않기 위해서 사용합니다.패키지 설치pod install마지막으로 ios 폴더에서 pod install을 입력하여 iOS에서 사용할 패키지를 연동해줍니다.실제 사용import NaverMapView, {Circle, Marker, Path, Polyline, Polygon} from &quot;react-native-nmap&quot;;function MyMap() { const P0 = {latitude: 37.564362, longitude: 126.977011}; const P1 = {latitude: 37.565051, longitude: 126.978567}; const P2 = {latitude: 37.565383, longitude: 126.976292}; return &amp;lt;NaverMapView style={{width: &#39;100%&#39;, height: &#39;100%&#39;}} showsMyLocationButton={true} center={{...P0, zoom: 16}} onTouch={e =&amp;gt; console.warn(&#39;onTouch&#39;, JSON.stringify(e.nativeEvent))} onCameraChange={e =&amp;gt; console.warn(&#39;onCameraChange&#39;, JSON.stringify(e))} onMapClick={e =&amp;gt; console.warn(&#39;onMapClick&#39;, JSON.stringify(e))}&amp;gt; &amp;lt;Marker coordinate={P0} onClick={() =&amp;gt; console.warn(&#39;onClick! p0&#39;)}/&amp;gt; &amp;lt;Marker coordinate={P1} pinColor=&quot;blue&quot; onClick={() =&amp;gt; console.warn(&#39;onClick! p1&#39;)}/&amp;gt; &amp;lt;Marker coordinate={P2} pinColor=&quot;red&quot; onClick={() =&amp;gt; console.warn(&#39;onClick! p2&#39;)}/&amp;gt; &amp;lt;Path coordinates={[P0, P1]} onClick={() =&amp;gt; console.warn(&#39;onClick! path&#39;)} width={10}/&amp;gt; &amp;lt;Polyline coordinates={[P1, P2]} onClick={() =&amp;gt; console.warn(&#39;onClick! polyline&#39;)}/&amp;gt; &amp;lt;Circle coordinate={P0} color={&quot;rgba(255,0,0,0.3)&quot;} radius={200} onClick={() =&amp;gt; console.warn(&#39;onClick! circle&#39;)}/&amp;gt; &amp;lt;Polygon coordinates={[P0, P1, P2]} color={`rgba(0, 0, 0, 0.5)`} onClick={() =&amp;gt; console.warn(&#39;onClick! polygon&#39;)}/&amp;gt; &amp;lt;/NaverMapView&amp;gt;}react-native-nmap 패키지는 지도를 구성하기 위한 각종 컴포넌트를 제공합니다.NaverMapView는 우리가 보는 지도 그 자체를 표시하는 View이고, 이 지도 내부에서 사용할 Marker Polygon Circle도 사용할 수 있습니다.자세한 내용은 여기에 기재 된 문서를 확인해주세요!" }, { "title": "Firestore Database 데이터 읽기", "url": "/posts/firestore-read-data/", "categories": "Firebase, Firestore", "tags": "Firebase, Firestore, Serverless", "date": "2022-02-10 22:06:00 +0800", "snippet": "개요Firestore는 NOSQL Base의 데이터베이스입니다.프론트엔드 및 백엔드 개발자가 직접 구현하기에는 까다롭고 시간도 많이 걸리는 데이터 캐싱, 실시간 조회 등을 아주 간단하게 사용할 수 있는 솔루션입니다.단일 데이터 읽기import { doc, getDoc } from &quot;firebase/firestore&quot;;const docRef = doc(db, &quot;cities&quot;, &quot;document-id&quot;);const docSnap = await getDoc(docRef);if (docSnap.exists()) { console.log(&quot;Document data:&quot;, docSnap.data());} else { // doc.data() will be undefined in this case console.log(&quot;No such document!&quot;);} doc 함수를 통해서 가져올 Document를 선택하고, getDoc 함수를 통해서 실제 데이터를 불러올 수 있습니다.단일 데이터 실시간으로 읽기import { doc, onSnapshot } from &#39;firebase/firestore&#39;;const docRef = doc(db, &#39;collection-name&#39;, &#39;document-id&#39;);const unsubscriber = onSnapshot(docRef, (snapshot) =&amp;gt; { const item = snapshot.data(); return item;});unsubscriber(); // 구독을 해제할 때 사용 doc으로 바라볼 문서를 선택하고, onSnapshot의 첫번째 인자로 넘겨주면 해당 문서가 변경 될 때마다 두번째 인자로 넘긴 Callback이 실행됩니다.두 개 이상의 데이터 읽기import { collection, getDocs } from &#39;firebase/firestore&#39;;const col = collection(db, &#39;collection-name&#39;);const docs = await getDocs(col);const items = [...docs].map((doc) =&amp;gt; doc.data());return items; 데이터가 들어있는 Collection을 collection 함수로 선택하여 getDocs로 추출할 수 있습니다.Where로 원하는 데이터만 불러오기import { collection, query, where, getDocs } from &#39;firebase/firestore&#39;;const col = collection(db, &#39;collection-name&#39;);const q = query(col, where(&#39;attribute-name&#39;, &#39;&amp;gt;=&#39;, value));const docs = await getDocs(q);const items = [...docs].map((doc) =&amp;gt; doc.data());return items; query 함수와 where 함수를 통해 불러올 데이터를 선택할 수 있습니다. orderBy나 limit도 query를 통해 사용할 수 있습니다.두 개 이상의 데이터를 실시간으로 읽기import { collection, onSnapshot } from &#39;firebase/firstore&#39;;const col = collection(db, &#39;collection-name&#39;);const unsubscriber = onSnapshot(col, (snapshot) =&amp;gt; { const docs = snapshot.docs(); const items = [...docs].map((doc) =&amp;gt; doc.data()); return items;}); onSnapshot 함수를 이용하여 Collection을 실시간으로 확인할 수 있습니다. onSnapshot의 첫번째 인자로 doc collection query 등이 들어갈 수 있으며, 첫번째 인자에 따라 바라보는 문서의 유형과 결과값이 달라집니다." }, { "title": "Firestore Database 개요", "url": "/posts/firestore-introduction/", "categories": "Firebase, Firestore", "tags": "Firebase, Firestore, Serverless", "date": "2022-02-09 09:03:00 +0800", "snippet": "개요Firebase의 Firestore Database는 NoSQL 기반의 Database입니다.아마존과 같은 Serverless 플랫폼에서 지원하는 일반적인 Database이며, 사용법이 간단하여 많은 주니어 개발자 혹은 서버 개발에 익숙하지 않은 사람들이 많이들 사용하는 서비스입니다.초기 화면위 화면이 Firestore Database의 초기 화면입니다.Firebase Project를 개설하고나면 이렇게 모든 컬렉션이 비어있음을 확인할 수 있습니다.Data 구조Collection컬렉션이란 관계형 데이터베이스(e.g MySQL)의 Table과 같다고 보면 됩니다.다시 말해, 동일한 형태의 데이터들이 모이는 집합입니다.Document문서란 관계형 데이터베이스의 Tuple과 같다고 볼 수 있습니다.다시 말해, 컬렉션 안에 들어가는 수많은 데이터 중 하나입니다.Field필드란 관계형 데이터베이스의 Attribute와 같다고 볼 수 있습니다.문서 내부에 있는 수많은 데이터 유형 중 하나를 의미합니다." }, { "title": "Svelte 가볍게 찍먹 해본 후기", "url": "/posts/svelte-review/", "categories": "Tech, Svelte", "tags": "Svelte", "date": "2022-02-05 22:17:00 +0800", "snippet": "SvelteSvelte는 새롭게 웹 개발 생태계의 강자로 떠오르고 있는 개발 도구입니다.특징Svelte가 주장하는 자신들의 세 가지 특징이 있습니다. 적은 코드 가상 DOM을 사용하지 않는다 진정한 반응성적은 코드Svelte를 이용하여 직접 Todo 앱을 만들어 본 결과, Hook처럼 다른 프레임워크에서 사용할만한 부분들을 사용하지 않아 차지하는 코드의 양이 적어지는 것이 체감되었습니다.다만 단순 Todo앱만 개발해 보았기 때문에 실제 현업에 적용했을 때도 코드가 간결해질지는 아직 잘 모르겠습니다.가상 DOM을 사용하지 않는다제가 Svelte를 라이브러리나 프레임워크라고 칭하지 않는 이유도 이 특징에서 비롯합니다.공식 문서에서도 Svelte를 개발 툴이라고 칭하고 있죠.Virtual DOM 원리React와 Vue는 UI의 원본을 메모리에 집어넣고 실제 사용자에게는 모습이 보이지 않는 상태로 관리하는데, 이를 Virtual DOM이라고 부릅니다.해당 Virtual DOM과 연결 된 State가 변경되면 우선 메모리에서 변경 된 상태를 집어넣은 UI를 가상으로 그린 후에 이를 실제 화면에 반영하는 형태로 구성되어 있습니다.하지만 이 방식은 한가지 문제점이 있는데, 브라우저 상에 UI를 표시하는 과정에서 Reflow 과정을 피할 수가 없습니다. Reflow는 화면 상에서 Layout들이 배치 되어 있는 구조를 나타낸 Tree를 Layout의 변경 등으로 인해 재탐색 하는 것을 말합니다.Reflow는 렌더링 과정에서 가장 많은 자원과 시간을 쏟는 작업인데, Virtual DOM 과정으로 UI를 변경하게 되면 Virtual DOM을 어디에 배치해야 할 지 레이아웃 구조를 처음부터 다시 살펴보기 때문에 탐색 과정을 피할 수 없는 것입니다.Compile 원리반면 Svelte는 Virtual DOM 방식이 아닌 Compile 방식을 사용하기 때문에 어떤 변수가 어떤 UI에 묶여있는지 이미 알고 있는 상태에서 시작합니다. 그러므로 해당 변수를 건드리는 이벤트가 실행이 된 것을 감지한다면, 변경된 값은 이미 들고 있고 해당 값을 어디에 배치해야 하는지도 알고 있으니 Reflow 과정 없이도 즉각적으로 UI를 다시 그릴 수 있는 것입니다.번들 파일의 가벼움심지어 Compile 타임에 UI와 Javascript 로직에 대한 연결을 모두 끝내놓으니 React나 Vue처럼 Runtime에 관여할 이유가 없기 때문에 Runtime 로직을 번들 과정에서 제거하게 됩니다. React, Vue, jQuery의 경우에는 사용자가 해당 서비스에 접속했을 때 개발자가 작성한 코드와 함께 React, Vue, jQuery 라이브러리도 같이 다운 받습니다. 해당 코드가 없으면 서비스가 동작할 수 없기 때문이죠.하지만 Svelte는 위에 기재한 이유로 Runtime때 관여하지 않아도 서비스가 동작하기 때문에 번들 파일이 굉장히 가벼워진다는 장점이 있습니다. Svelte 패키지가 빠지니까요.진정한 반응성위에 장황하게 설명해놓은 점에서 비롯합니다.Virtual DOM 방식은 이벤트를 감지하면 Virtual DOM에서 UI를 완성하여 Reflow를 거쳐 Repaint를 진행합니다.물론 사용자는 알 수 없는 차이겠지만 버튼을 누르자마자 바로 반영하는 것이 아니기에 즉각적인 반응을 한다고 보기는 어렵다는 것이죠.반면, Svelte는 이벤트를 감지하면 Repaint를 바로 진행하기 때문에 즉각적으로 반응한다고 볼 수 있습니다.후기이제서야 본문이 나온 것 같은데, 결론부터 말씀드리자면 Svelte의 개발 경험은 굉장히 긍정적이였습니다.물론 if, each, export와 같은 기본적인 로직만을 사용해봤지만 기본적으로 Vue와 코드 구조가 비슷하여 접근하기가 쉬웠고, React처럼 개발 도구에 의존적이지 않은 자유분방한 코드를 작성할 수 있었기 때문입니다.Tutorial 페이지가 정말 잘 만들어져 있다는 점도 무시할 수 없겠군요.이제부터 가볍게 무언가를 만들어야 할 상황이 온다면 Vue보다는 Svelte를 쓰지 않을까 생각마저 하게될 정도로 너무 좋은 경험이였기에 평소에 Vue를 이용하여 웹 개발을 하고 계셨던 분들이라면 한 번 쯤 찍먹해 보시라고 추천해드리고 싶습니다.요약 Vue와 코드 스타일이 비슷하여 접근성이 좋음 그렇다고 막 Vue처럼 Framework의 문법을 강요하는 느낌도 아님. Vanila Javascript 쓰는 느낌임. 생각한대로 프로그램이 만들어짐 튜토리얼 페이지가 정말 잘 만들어졌다 못해 아름다움.참고개발자 노트 - 1. Svelte 소개 - 컴파일 방식의 UI 프레임워크" }, { "title": "[React Native] React Native Reanimated 패키지 설치 방법", "url": "/posts/react-native-reanimated/", "categories": "Tech, React Native", "tags": "React Native, Animation", "date": "2022-02-03 20:52:00 +0800", "snippet": "개요React Native에서는 애니메이션을 구현하기가 정말 어렵습니다. 특히 웹에서 현란한 애니메이션을 구현해 본 적 있는 사람이라면 상대적으로 크게 느껴질 대목이라고 생각합니다.웹이라면 CSS3 혹은 Javascript를 통해서 간편하게 애니메이션을 구현할 수 있는데, React Native 환경에서는 간단한 Opacity 애니메이션이라면 몰라도 Reflow 레벨의 애니메이션을 구현하기에는 상당히 어렵죠.그래서 해당 문제점을 보완하고자 React Native Community에서는 React Native Reanimated라는 패키지를 개발했습니다.하지만 공식 문서의 설치 가이드를 따르면 에러가 발생하는 부분이 있기에 이 문제를 해결한 방법을 적고자 합니다.문제점제가 설치한 패키지는 2.3.1 버전입니다. 공식 문서에 적힌 모든 사항을 준수 해서 설치했는데도 아래와 같은 문제가 발생했습니다. Invariant Violation: TurboModuleRegistry.getEnforcing(…): ‘NativeReanimated’ could not be found. Verify that a module by this name is registered in the native binary.어떤 문서에서는 1.x 버전으로 다운그레이드를 해서 해결했다고 하는데 이 방법은 제가 개인적으로 굉장히 싫어하는 방법이기에 다른 방법을 찾아 해결하였고, 설치 과정부터 차근차근 아래에 기재해보도록 하겠습니다.설치 방법패키지 설치아래와 같이 패키지를 설치해줍니다.yarn add react-native-reanimatedBabel 명시Babel에 React native reanimated 패키지에 관하여 명시해줍니다. module.exports = { ... plugins: [ ... &#39;react-native-reanimated/plugin&#39;, ], }; 반드시 react-native-reanimated/plugin 패키지는 plugins 목록에서 가장 하단에 배치 되어야 합니다.Androidandroid/app/build.gradle 파일에 이미 존재하는 enableHermes 속성을 true로 변경해줍니다.project.ext.react = [ enableHermes: true // &amp;lt;- here | clean and rebuild if changing]mainApplication.java 파일에 다음과 같이 추가해줍니다. import com.facebook.react.bridge.JSIModulePackage; // &amp;lt;- add import com.swmansion.reanimated.ReanimatedJSIModulePackage; // &amp;lt;- add ... private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { ... @Override protected String getJSMainModuleName() { return &quot;index&quot;; } @Override protected JSIModulePackage getJSIModulePackage() { return new ReanimatedJSIModulePackage(); // &amp;lt;- add } }; ...iOSiOS는 autolink를 지원하기 때문에 별도의 파일 수정이 필요 없습니다. ios 폴더에 들어가서 pod install만 입력하면 됩니다.캐시 제거가장 중요한 파트입니다. 이 부분에 명시 된 내용을 시행하지 않으면 위에 기재한 이슈가 발생할 수 있습니다.yarn start --reset-cache위 내용을 입력하면 문제 없이 실행되는 것을 보실 수 있습니다." }, { "title": "버스는 어떻게 혼잡도를 측정할까?", "url": "/posts/bus-logic/", "categories": "Tech, Talk", "tags": "Talk", "date": "2022-02-03 19:41:00 +0800", "snippet": "버스의 혼잡도서울을 시작으로 이제는 경기도에서도 버스 혼잡도를 볼 수 있습니다.아직 지원하지 않는 버스 정류장이 있을지도 모르겠지만, 현재는 꽤 광범위하게 지원하는 기능이라고 생각됩니다.여유, 보통, 혼잡 세 단계로 분류되는 혼잡도 알림 서비스는 어떻게 측정되는걸까요?BISBus Information System. 참 간단한 약어죠?우리나라의 모든 버스는 BIS를 통하여 모든 정보를 집약하고 관리합니다.해당 버스가 어느 지점에 있는지, 앞 뒤 버스는 어떤게 오고 있는지 등을 전부 이 시스템을 통해서 관리를 하게 됩니다.혼잡도 측정 원리BIS에서는 등록 된 모든 버스에 대해서 차종, 차 번호 등의 기본적인 정보들을 관리합니다.우선, 버스에 승차할 때 교통카드를 태그 하면 숫자 1을 카운트합니다. 여러명이 태그를 하면 그 수만큼 숫자가 늘어나겠죠?하차 태그를 찍게 되면 승차 인원 수에서 -1을 하는 식으로 현재 버스에 타고 있는 사람들의 숫자를 대략적으로 측정하고, 버스가 시외버스인지 시내버스인지 광역버스인지 판단하여 버스의 수용 인원을 파악하여 측정 된 탑승 인원에 따라 혼잡도 상태를 구분합니다.단점교통카드의 사용 빈도가 압도적으로 많다고는 하지만 아직 100%는 아닙니다. 현금을 지불하여 탑승하는 사람의 경우에는 BIS에 누적되지 않으며, 사람 간 간격이 경우에 따라 다르고, 탑승한 사람들이 차지하는 부피도 다르기 때문에 혼잡도가 정확하다고 보기는 어렵습니다.여담BIS를 통한 서비스는 혼잡도만 있는 것이 아닌데요, 정류소 도착 직전에 울리는 정류소 안내 방송도 BIS를 이용한 서비스입니다.초기에는 버스 안내양이 안내해주는 형태로 서비스 되다가, 버스 기사가 버튼을 직접 누르는 형태, 버스의 전파 수신기가 정류소 인근의 전파 송신기의 전파를 수신하면 나오도록 발전하였습니다. 다만 이 모든 형태가 정확한 서비스를 제공하지 못했기 때문에 현재는 GPS로 버스의 위치를 실시간으로 수신하여 BIS에 송신하고, BIS가 상황에 맞는 안내 방송을 전송하는 형태로 서비스 되고 있다고 합니다.출처사진 출처: 디지털 투데이 - 빅데이터 이용한 ‘버스 혼잡도 안내’…정확도는 ‘글쎄’정보 출처: IT 조선 - “교통카드가 별 걸 다하네”…’버스 혼잡 안내 서비스’ 원리 살펴보니" }, { "title": "[React Native] Android에서 캡처 방지하기", "url": "/posts/capture-deny-on-android/", "categories": "Tech, React Native", "tags": "React Native, Android", "date": "2022-01-28 09:53:00 +0800", "snippet": "개요특정 회사의 내부 인원들만 사용하는 안드로이드 전용 어플리케이션을 개발하게 되었습니다.해당 앱에는 특정 조직의 구성원들의 정보가 들어있는데, 사진이나 현 직장 정보 및 전화번호와 같은 매우 민감한 정보들이 포함되어 있기 때문에 앱스토어에도 올리지 않고 조직 내부 인원들에게 따로 공유해서 사용할 앱입니다.그렇기 때문에 보안사항이 꽤 중요하게 작용하는데, 화면 캡처도 당연히 방지해야 하는 상황입니다.Android는 User Level Application이 OS Level의 기능을 핸들링하는걸 꽤 관대하게 여기기 때문에 분명히 해당 기능이 있을 것이라 판단하고 방법을 찾았습니다.역시 기대를 저버리지 않았고, 해당 기능을 어떻게 적용했는지에 대해 적어보고자 합니다.캡처 차단하는 방법 /android/app/src/main/java/com/{Project_Name}/MainActivity.java 파일에 접근합니다. 코드를 MainActivity 클래스에 적용합니다. @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE); } 해당 문서의 상단부에 아래 코드를 적용시킵니다. import android.os.Bundle; import android.view.WindowManager; 스크린샷을 찍어보면 ‘보안정책에 따라 화면을 캡처할 수 없어요’ 라고 나오는 것을 확인할 수 있습니다.주의할 점저의 테스트 환경은 M1Pro 맥북의 Android 애뮬레이터입니다.여기서 테스트를 한 결과, 애뮬레이터에서 지원하는 스크린샷 기능은 정상적으로 작동하기 때문에 제대로 차단이 되었는지를 확인하고 싶다면 실제 안드로이드 기기를 연결하여 확인을 해봐야 합니다." }, { "title": "[React Native] Lottie와 React Native를 이용한 역동적인 앱 만들기", "url": "/posts/react-native-and-lottie/", "categories": "Tech, React Native", "tags": "React Native, Lottie", "date": "2022-01-26 09:14:00 +0800", "snippet": "LottieLottie는 웹이나 앱 환경에서 역동적이며 멋있는 복잡한 애니메이션을 구현하는 것을 도와주는 라이브러리입니다.장점 개발자는 코드만으로는 구현하기 힘든 애니메이션을 쉽게 구현할 수 있게 해줍니다. 디자이너는 복잡한 애니메이션을 구현하기 위해 개발자의 눈치를 보지 않아도 되는 이점이 있습니다. 일반적인 GIF의 경우 프레임 드랍, 성능 이슈 등을 동반하는 반면, Lottie는 해당 이슈로부터 벗어날 수 있습니다.React Native의 예제패키지 설치Lottie를 실제로 사용해보기 위해서 패키지를 설치합니다.yarn add lottie-react-nativeyarn add lottie-ios@3.2.3아이폰 개발을 위해서 pod를 설치합니다.cd iospod install애니메이션 애셋 다운로드코드를 작성하기 전에, 마음에 드는 애니메이션 파일을 구해야 합니다. (직접 Adobe의 After Effect를 이용하여 만들수도 있습니다.)이 문서에서는 다른 누군가가 만들어 둔 애셋을 다운받아 진행할 예정입니다.다른 사람이 만들어놓은 예쁜 애셋들은 Lottie 공식 홈페이지에서 받으실 수 있습니다!여기 마침 적절한 스플래시 애니메이션이 있으니 얘를 사용해서 역동적인 애니메이션을 보여주는 스플래시 스크린을 만들어봅시다.페이지에 방문하면 우측 상단에 있는 [Download] 버튼을 눌러 [Lottie JSON] 타입으로 다운로드 받아봅시다.다운로드 받은 Lottie JSON 파일을 [RN Project Name]/assets/lottie 경로에 집어넣고 파일의 이름을 splash.json이라고 명명합니다.실제 코드 작성하기스플래시 스크린을 구현하기 위해 페이지를 구성하는 코드를 작성해봅시다.도입부에는 사용할 패키지를 import하는 작업이 필요하겠죠?import React from &#39;react&#39;;import { View } from &#39;react-native&#39;;import LottieView from &#39;lottie-react-native&#39;;import 코드 아래쪽에 실제 페이지에 반영 될 컴포넌트를 정의하고 해당 컴포넌트를 export합니다.LottieView 컴포넌트를 이용하여 required한 애니메이션 JSON을 실제로 보여줄 수 있습니다.const App = () =&amp;gt; { return ( &amp;lt;View style={{ flex: 1, height: &#39;100%&#39;, alignItems: &#39;center&#39;, justifyContent: &#39;center&#39;, }} &amp;gt; &amp;lt;LottieView style={{ width: &#39;100%&#39;, height: &#39;100%&#39;, }} source={require(&#39;./assets/lottie/splash.json&#39;)} autoPlay loop={false} /&amp;gt; &amp;lt;/View&amp;gt; );};export default App;결과물아주 예쁜 스플래시 스크린이 만들어졌네요!" }, { "title": "[React Native] Jest를 이용한 단위 테스트 해보기 (feat. TDD)", "url": "/posts/jest-on-react-native/", "categories": "Tech, React Native", "tags": "React Native, Jest, Unittest", "date": "2022-01-25 15:55:00 +0800", "snippet": "흔한 소프트웨어 개발 방법요즘 소프트웨어의 개발은 정교함보다는 간편함과 신속함에 초점이 맞춰져 있습니다.물론 일반화 하기에는 너무나 다양한 가치관과 개발 방식이 있겠지만 대부분의 기업에서는 아래와 같은 시나리오를 따릅니다. 소프트웨어의 요구스펙을 적은 기획서를 작성한다. (일부 기업에서는 이를 ‘유저스토리’라고 칭한다.) 디자인을 제작한다. 개발자가 디자인과 기획서를 보고 개발에 들어간다. 개발자가 직접 테스트를 진행하면서 기획서와 교차 테스트를 진행한다. 제품을 출시한다. 이슈가 발견되면 수정한다.문제점위 개발 방식은 흔하디 흔한 Waterfall 시나리오입니다.그런데 이러한 개발 방식에는 한가지 문제점이 있습니다.기능 추가 및 변경이 지속적으로 일어날수록, 다시 말해 프로젝트의 규모가 확대 될수록 3번 항목이 제대로 지켜지지 않을 수 있다는 점입니다.예를 하나 들어보겠습니다. 2017년에 만들기 시작한 프로젝트가 있다. 이 때는 앱이 지원하는 기능이 간단한 게시판 정도밖에 없었다. 심지어 비회원도 게시물을 작성할 수 있는, 별도의 회원 인증 기능조차 없는 간단한 앱이다. 2018년에는 앱의 사용자 수가 늘어나서 수익을 창출해야만 한다. 광고를 추가했다. 2019년에는 멤버십 기능 추가를 위해 회원 기능을 만들었다. 2020년에는 구글 애널리틱스를 적용하여 비회원과 회원의 앱 사용 방식을 분석하기 시작했다. 2021년에는 비회원 제도를 폐지하여 회원만 앱 사용이 가능하도록 제작했다.위와 같은 개발 절차를 거칠 경우, 1번과 5번이 상충됩니다. 새로운 기능이 생겨나면서 기존 기능의 영역을 침범하게 되는거죠.5번을 개발할 때 1번에 대한 내용을 기억하고 있다면 돌아가서 수정하면 되는 부분이겠지만 만약 1번의 비회원 게시글 작성 기능을 잊고 있는 상태라면 어떨까요?서비스의 코어 기능에 대해 심각한 이슈를 가진 채 릴리즈 될 수도 있는 부분입니다.서비스 개발 과정에서 흔히 일어나는 인적 오류입니다. 기능 개발 후 교차 검증을 사람에게 전적으로 맡기다보면 테스트에 소모되는 시간적 비용도 증가되고, 기능에 대해서 확실히 동작한다는 보장을 받을 수 없습니다.단위 테스트개요단위 테스트란, 개발에 사용되는 가장 작은 단위의 요소(컴포넌트)를 기능별로 분석하여 모든 기능이 개별적으로, 정상적으로 동작하는지를 확인하기 위한 테스트 기법입니다.장점테스트가 조밀하게 작성 된 소프트웨어는 컴포넌트와 페이지의 갯수만큼의 QA 직원을 데리고 있는 것과 마찬가지입니다. (그것도 매우 성실한) QA 직원 한명은 컴포넌트 하나만을 들여다보기 때문에 절대 실수하는 법이 없습니다. 더 이상 쪼개질 수 없을 정도로 디테일하게 작성 된 테스트 코드는 추후 기능 추가 및 변경에 의한 대응도 간편합니다. 사람이 진행하는 테스트가 아니기에 인적 실수가 적용되지 않습니다. 진행해야 할 테스트를 덜 알려주게 되면 Coverage를 차감하는 방식으로 알려주기 때문에 기획 사항이 누락 될 위험이 없습니다. 테스트를 진행하면서 실제로 소프트웨어를 돌려보기 때문에 어떤 과정에서 퍼포먼스가 안좋은지를 바로 알 수 있습니다.단점 기능이 추가 / 변경 될 때마다 기존 테스트 코드에 반영을 해야하기 때문에 기능 개발 + a 의 시간이 들어갑니다. 초반부터 테스트 코드를 작성하고 개발한게 아니라면 추후 테스트 코드를 도입하기 위해 거쳐야 하는 시간적 비용이 클 수도 있습니다. 테스트 코드를 작성하기 위한 학습 시간이 필요할 수 있습니다.실제로 도입해보기설치해야 할 패키지 @types/jest @testing-library/jest-native @testing-library/react-native react-test-renderer immer (단위 테스트에는 상관 없는데, 추후 Home 컴포넌트를 작성하기 위해서 사용합니다.)yarn add --dev @types/jest @testing-library/jest-native @testing-library/react-native react-test-renderer immer방법 이 섹션에서는 jest의 expect와 toBe와 같은 함수의 사용법은 숙지하고 있다는 전제 하에 설명합니다.기획아래와 같은 앱을 만든다고 생각해봅시다. 상단에는 타이틀이 보여진다. 내가 가장 좋아하는 레스토랑의 이름을 입력할 수 있는 입력 필드가 있다. 레스토랑을 추가할 수 있는 버튼이 존재한다. 레스토랑의 이름을 입력하지 않고 추가 버튼을 누를 경우 경고창이 보여지며 입력을 막는다. 레스토랑 이름을 입력하면 레스토랑이 추가가 되어 화면에 표시가 된다.예상 실행 모습은 아래와 같습니다.TDDTDD개발 원칙에 따라 테스트 코드 먼저 작성해봅시다. TDD 개발이란, 테스트 코드부터 개발하고 실제 개발에 들어가는 방식을 말합니다.최종 결과물을 제작할 때는 기존에 작성해둔 테스트 코드가 통과 되도록 제작해야 합니다. __test__ 폴더를 루트 경로에 배치합니다. (react-native CLI를 이용하여 프로젝트를 생성했다면 이미 해당 폴더가 존재 할겁니다.) __test__ 폴더 안에 Home-test.js 파일을 생성합니다. Home-test.js 안에는 Home이라는 이름의 스크린에서 유저가 행할 수 있는 모든 행동과, 유저가 얻을 수 있는 모든 기대값을 테스트하기 위한 로직을 작성합니다. Home-test.js 최상단에서 패키지를 아래와 같이 import합니다. (각각의 패키지에서 불러온 메소드가 어떤 역할을 하는지는 나중에 설명합니다.) import React from &#39;react&#39;; import &#39;react-native&#39;; import { render, fireEvent } from &#39;@testing-library/react-native&#39;; import Home from &#39;../src/Home&#39;; // Home 컴포넌트는 예시이다. 각자의 사정에 맞춰서 테스트를 할 컴포넌트를 불러오면 된다. 현재 Home 컴포넌트를 테스트하고 있기 때문에, Home이라는 대주제를 개설합니다. describe(&#39;Home&#39;, () =&amp;gt; { }); 스냅샷 촬영 및 컴포넌트 렌더링이 제대로 되었는지에 대한 테스트 로직을 작성합니다. (위에서 생성한 describe의 callback 내부에 작성해야 한다.) it(&#39;Home 화면이 정상적으로 렌더링 되는가?&#39;, () =&amp;gt; { // 현재 테스트 하고자 하는 목적을 적고, 두번째 매개변수로 callback을 전달한다. 실제 테스트는 callback 내부에서 진행한다. const screen = render(&amp;lt;Home /&amp;gt;); // react-native 컴포넌트를 @testing-library/react-native 패키지의 render 함수를 통해 렌더링한다. const json = screen.toJSON(); // 렌더링 된 컴포넌트를 json 구조로 변환한다. expect(json).toMatchSnapshot(); // 만들어진 json으로 스냅샷을 촬영한다. }); 스냅샷을 촬영하는 이유는, 추후 컴포넌트가 무언가에 의해 변경됨을 감지하기 위해서 앱 실행 당시 초기의 모습을 기억해두기 위해서입니다. 한 번 촬영해둔 스냅샷은 파일의 형태로 __snapshots__ 폴더에 저장되기 때문에 추후에 컴포넌트를 직접 변경했을 경우 기존에 촬영된 스냅샷과 일치하지가 않아 에러가 발생되는 경우가 있는데, 그럴 경우에는 yarn test --u를 한 번 실행해서 스냅샷을 다시 촬영해주면 됩니다. 제대로 타이틀이 보여지는지에 관한 테스트를 작성합니다. it(&#39;타이틀이 정상적으로 보여지는가?&#39;, () =&amp;gt; { // 마찬가지로 현재 테스트하고자 하는 목적을 적는다. const screen = render(&amp;lt;Home /&amp;gt;); // Home 컴포넌트를 렌더링한다. const title = screen.getByText(&#39;Your Favorite Restaurants!&#39;); // 해당 screen에서 &#39;Your Favorite Restaurants!&#39; 라는 내용을 갖는 노드를 찾는다. expect(title).toBeDefined(); // 만약 노드가 있다면 toBeDefined()로 해당 객체가 정의 되었는지 테스트한다. (toBeDefined는 undefined가 넘어가면 실패를 반환하는 메소드이다.) }); 내가 가장 좋아하는 레스토랑의 이름을 입력할 수 있는 입력 필드가 노출 되었는지에 관한 테스트를 작성합니다. it(&#39;레스토랑 이름을 입력할 수 있는 텍스트 필드가 존재하는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); expect(screen.getByTestId(&#39;restaurantNameField&#39;)).toBeDefined(); // testID 속성에 &#39;restaurantNameField&#39;가 들어가있는 요소가 있는지 찾고, 정의 되었는지를 식별한다. }); testID란, React Native에서 순전히 테스트를 위해 존재하는 Attribute입니다. React Native환경은 웹과 다르게 className이나 id를 사용하지 않기 때문에 Element를 선택하려면 testId를 활용해야 합니다. 레스토랑을 추가할 수 있는 버튼이 노출 되었는지에 관한 테스트를 진행합니다. // 레스토랑 이름 입력 필드 검사 로직과 testId만 다르기 때문에 설명은 생략한다. it(&#39;레스토랑을 추가할 수 있는 추가 버튼이 존재하는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); expect(screen.getByTestId(&#39;restaurantAddButton&#39;)).toBeDefined(); }); 레스토랑 이름을 입력하지 않고 추가 버튼을 누를 경우에 대한 테스트를 작성하기 전에, 패키지 import라인에 해당 코드를 추가합니다. import { Alert } from &#39;react-native&#39;; // react-native에서 지원하는 경고창이다.jest.spyOn(Alert, &#39;alert&#39;); // jest의 spy를 Alert 메소드에 심어놓는다. 테스트를 할 때는 실제 Alert를 실행하는게 아닌, &#39;실행이 되었나?&#39;에 대한 여부만을 확인하기 위한 mocking 작업을 진행하게 된다. 레스토랑 이름을 입력하지 않고 추가 버튼을 누를 경우에 대한 테스트를 작성합니다. it(&#39;레스토랑 이름을 추가하지 않고 추가 버튼을 누를 경우 예외 문구가 표시 되는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); const title = &#39;레스토랑 추가 실패&#39;; // Alert의 제목 const message = &#39;레스토랑 이름을 입력해주세요!&#39;; // Alert의 내용 const button = screen.getByTestId(&#39;restaurantAddButton&#39;); // 버튼을 직접 눌러보기 위해서 버튼을 탐색 fireEvent(button, &#39;press&#39;); // fireEvent를 통해 윗 줄에서 선택한 버튼에 &#39;press&#39;라는 이벤트를 실행하는 trigger이다. const json = screen.toJSON(); // 버튼을 누른 이후의 모습을 json으로 만든다. expect(Alert.alert).toHaveBeenCalledWith(title, message); // react-native의 Alert 메소드가 title, message과 같은 매개변수를 넘겨받고 실행 된 적이 있는지 테스트한다. expect(json).toMatchSnapshot(); // 초기에 촬영 된 스냅샷과 현재 스크린을 비교한다. 만약 경고창은 띄웠지만 실제 작성을 막지 않은 경우, 엉뚱한 노드가 하나 더 생겼을테니 초기 스냅샷과 달라졌기 때문에 오류가 난다.}); 레스토랑을 추가할 수 있는지에 대한 테스트를 작성합니다. it(&#39;레스토랑을 추가할 수 있는가?&#39;, () =&amp;gt; { const names = [ // 추가할 레스토랑의 이름들을 배열에 적어둔다. &#39;1st gourmet&#39;, &#39;sushi daisuki&#39;, &#39;udonya&#39;, ]; const screen = render(&amp;lt;Home /&amp;gt;); const input = screen.getByTestId(&#39;restaurantNameField&#39;); const button = screen.getByTestId(&#39;restaurantAddButton&#39;); for (const name of names) { // 이름들을 반복한다. fireEvent(input, &#39;changeText&#39;, name); // 위에서 찾은 input 노드에 &#39;changeText&#39;라는 이벤트를 보내는데, 매개변수로 name을 보낸다. fireEvent(button, &#39;press&#39;); // 위에서 찾은 button 노드에 &#39;press&#39;라는 이벤트를 보낸다. expect(screen.getByText(name)).toBeDefined(); // name 텍스트를 가진 요소가 정의 되었는지 탐색한다. 만약 레스토랑 이름이 표기되지 않았다면 실패한다. }}); 위 모든 과정을 제대로 따라왔다면 최종 테스트 코드의 모습은 아래와 같이 나올 것입니다. import React from &#39;react&#39;;import { Alert } from &#39;react-native&#39;;import { render, fireEvent } from &#39;@testing-library/react-native&#39;;import Home from &#39;../src/pages/Home&#39;;jest.spyOn(Alert, &#39;alert&#39;);describe(&#39;Home&#39;, () =&amp;gt; {it(&#39;Home 화면이 정상적으로 렌더링 되는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); const json = screen.toJSON(); expect(json).toMatchSnapshot();});it(&#39;타이틀이 정상적으로 보여지는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); const title = screen.getByText(&#39;Your Favorite Restaurants!&#39;); expect(title).toBeDefined();});it(&#39;레스토랑 이름을 입력할 수 있는 텍스트 필드가 존재하는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); expect(screen.getByTestId(&#39;restaurantNameField&#39;)).toBeDefined();});it(&#39;레스토랑을 추가할 수 있는 추가 버튼이 존재하는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); expect(screen.getByTestId(&#39;restaurantAddButton&#39;)).toBeDefined();});it(&#39;레스토랑 이름을 추가하지 않고 추가 버튼을 누를 경우 예외 문구가 표시 되는가?&#39;, () =&amp;gt; { const screen = render(&amp;lt;Home /&amp;gt;); const title = &#39;레스토랑 추가 실패&#39;; const message = &#39;레스토랑 이름을 입력해주세요!&#39;; const button = screen.getByTestId(&#39;restaurantAddButton&#39;); fireEvent(button, &#39;press&#39;); const json = screen.toJSON(); expect(Alert.alert).toHaveBeenCalledWith(title, message); expect(json).toMatchSnapshot();});it(&#39;레스토랑을 추가할 수 있는가?&#39;, () =&amp;gt; { const names = [ &#39;1st gourmet&#39;, &#39;sushi daisuki&#39;, &#39;udonya&#39;, ]; const screen = render(&amp;lt;Home /&amp;gt;); const input = screen.getByTestId(&#39;restaurantNameField&#39;); const button = screen.getByTestId(&#39;restaurantAddButton&#39;); for (const name of names) { fireEvent(input, &#39;changeText&#39;, name); fireEvent(button, &#39;press&#39;); expect(screen.getByText(name)).toBeDefined(); }});}); 위 테스트 코드를 기반으로 Home을 구현해보면 실제 Home의 코드는 아래와 같이 될 것입니다. import produce from &#39;immer&#39;;import React, { useReducer } from &#39;react&#39;;import { Text, View, TextInput, Button, Alert, SafeAreaView, } from &#39;react-native&#39;;const reducer = (state, action) =&amp;gt; {switch(action.type) { case &#39;SET_NAME&#39;: return produce(state, (draft) =&amp;gt; { draft.name = action.payload; return draft; }); case &#39;ADD_ITEM&#39;: return produce(state, (draft) =&amp;gt; { draft.items.push(action.payload); return draft; }); default: return state;}};const Home = () =&amp;gt; {const [state, dispatch] = useReducer(reducer, { name: &#39;&#39;, items: [],});const handleAddRestaurant = () =&amp;gt; { try { if (!state.name) throw new Error(&#39;레스토랑 이름을 입력해주세요!&#39;); const { name } = state; dispatch({ type: &#39;ADD_ITEM&#39;, payload: name }); dispatch({ type: &#39;SET_NAME&#39;, payload: &#39;&#39; }); } catch (e) { Alert.alert(&#39;레스토랑 추가 실패&#39;, e.message); }};const handleChangeName = (e) =&amp;gt; { dispatch({ type: &#39;SET_NAME&#39;, payload: e });};return ( &amp;lt;SafeAreaView&amp;gt; &amp;lt;Text&amp;gt;Your Favorite Restaurants!&amp;lt;/Text&amp;gt; &amp;lt;View&amp;gt; { state.items.map((item, index) =&amp;gt; { return ( &amp;lt;Restaurant key={index} name={item} /&amp;gt; ); }) } &amp;lt;/View&amp;gt; &amp;lt;TextInput value={state.name} testID=&quot;restaurantNameField&quot; onChangeText={handleChangeName} /&amp;gt; &amp;lt;Button title=&quot;추가&quot; testID=&quot;restaurantAddButton&quot; onPress={handleAddRestaurant} /&amp;gt; &amp;lt;/SafeAreaView&amp;gt;);};const Restaurant = (props) =&amp;gt; {return ( &amp;lt;View&amp;gt; &amp;lt;Text&amp;gt;{props.name}&amp;lt;/Text&amp;gt; &amp;lt;/View&amp;gt;);};export default Home; 테스트 실행하기기본jest는 기본적으로 __test__ 폴더 내부의 모든 파일 혹은 *.test 명칭을 가진 파일들을 실행하기 때문에 아래 커맨드로 프로젝트내 포함 된 모든 테스트를 별도의 설정 없이 읽어낼 수 있습니다.yarn test특정 파일만 테스트 해보기만약 특정 테스트 파일만 읽고 싶다면 아래 명령어를 입력합니다.yarn test home// home은 파일의 이름이다. Home-test.js일 경우, 앞의 Home만 따서 쓰는 형태이다.스냅샷 갱신만약 스냅샷을 재촬영하고 싶다면 아래 명령어를 입력합니다.yarn test --uAwesome!" }, { "title": "[React Native] in target &#39;FBReactNativeSpec&#39; from project &#39;Pods&#39; 해결", "url": "/posts/fbreactnativespec_issue/", "categories": "Tech, React Native", "tags": "React Native", "date": "2022-01-25 13:32:00 +0800", "snippet": "개요nvm으로 node 패키지를 설치한 사람에게서 발견할 수 있는 이슈입니다.만약 which node를 입력했을 때 /usr/local/bin/node가 아닌, /Users/[username]/.nvm과 같이 .nvm이 포함 된 경로로 node가 잡힌다면 이에 해당합니다.원인Cocoapods을 비롯한 React Native 필수 패키지는 Homebrew를 이용하여 설치가 되는데, node패키지가 nvm에 의해서 설치될 경우 나머지 패키지를 탐색하지 못하기 때문입니다.해결 방법 nvm 폴더를 삭제합니다. /Users/[username]/.nvm nvm 패키지를 설치할 때 ~/.zshrc와 같은 환경 변수 기록 파일에 기재했던 nvm 환경 변수를 같이 제거해준다. export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;amp;&amp;amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 만약 제거 이후에 which node를 입력했는데 /usr/local/bin/node가 안잡힌다면 brew install node를 실행한다." }, { "title": "[React Native] 안드로이드 Webview 하드웨어 가속 이슈", "url": "/posts/android-webview-hardware-acceleration-issue/", "categories": "Tech, React Native", "tags": "React Native, Webview, Android", "date": "2022-01-25 12:54:00 +0800", "snippet": "Webview란?Webview는 네이티브 앱에서 웹의 화면을 보여줄 수 있는 컴포넌트라고 생각하시면 됩니다.아마 앱 서비스를 개발하는 모든 회사가 웹뷰를 적극적으로 사용하지 않을까 싶을 정도로 활용도가 엄청납니다.단순히 웹을 띄워주는 형태이다보니 플랫폼에 구애받지 않고, 컨텐츠를 수정하는데 앱의 심사를 받지 않아도 된다는 강력한 장점이 있기 때문이죠.개요우리 회사의 서비스에도 타 서비스와 마찬가지로 Webview가 사용 되는데요, 대표적으로 사용자가 적은 게시글을 앱에서 렌더링 할 때 사용합니다.웹에서 적는 게시글에 대해서는 Quill Editor를 쓰는데, 웹과 동일한 모습을 보여주기 위해서 인앱에 Quill CSS를 삽입하는건 사용자 경험도, 앱의 성능 측면에서도 결코 유쾌한 경험은 아니기 때문입니다.그런데 오늘 기획팀으로부터 “안드로이드에서 Webview 컨텐츠가 안보여요!” 라는 이슈가 도착했습니다.원인 의심보통 Webview의 내용을 그리지 못하는 경우라면 두 가지의 경우가 대표적입니다. 서버로부터 게시물을 받아오지 못함 엔드포인트가 목적지와 다른 곳으로 설정 됨그런데 안드로이드에서만 발생하는 이슈라고 해서 약간 불안해졌습니다.보통 웹이건 앱이건 플랫폼간 다르게 발생하는 이슈는 슈팅하기 어렵기 때문이죠.코드 &amp;lt;AutoHeightWebView style={{ width: Dimensions.get(&#39;screen&#39;).width, }} source={{ html: content, }} scrollEnabled={false} onNavigationStateChange={onNavigationStateChange} onShouldStartLoadWithRequest={onShouldStartLoadWithRequest} androidHardwareAccelerationDisabled={true} originWhitelist={[&#39;about:blank&#39;]} /&amp;gt;분석content 변수에 html이 제대로 들어가고 있는가?가장 첫번째로 의심 해볼만한 Feature죠.console.log(content)로 content 변수에 할당 된 내용을 확인해보면 쉽게 알 수 있는 부분입니다.출력해본 결과, 데이터 바인딩에는 문제가 없었습니다.Property로 인해 Webview가 정상 동작하지 않는 경우두번째로 의심 해볼만한 Feature입니다.네이티브 환경에서는 별 일이 다 벌어지기에 특정 기기에서만 동작하지 않는 Property가 생길 수도 있기 때문이죠.이런 이슈를 잡아내기 위해서는 최소한의 기능만 하는 컴포넌트 원형을 작성하면 쉽게 알 수 있습니다.Webview 자체가 문제는 아닌지, Property의 문제는 아닌지 바로 알 수 있기 때문이죠.&amp;lt;AutoHeightWebView source={{ html: content }}/&amp;gt;위 코드를 작성한 결과, 정상적으로 HTML이 렌더링 되는 것을 확인할 수 있었습니다.그렇다면 정말 다행히도 컴포넌트 자체에 문제가 있는 것은 아니겠군요.예상대로 Property가 동작을 방해한다는건데, 눈에 띄는 Property가 하나 있군요.androidHardwareAccelerationDisabled={true} 안드로이드 환경에서만 렌더링이 되지 않는다고 했는데 속성 이름에 딱 android가 들어있군요.해당 속성을 추가한 결과, 정상적으로 작동 되던 Webview마저도 동작하지 않는 것을 확인할 수 있었습니다.androidHardwareAccelerationDisabled PropertyandroidHardwareAccelerationDisabled 속성은 안드로이드 환경에서 특정 컴포넌트를 렌더링 할 때 GPU를 사용하여 보다 빠른 어플리케이션 사용자 경험을 제공하는 하드웨어 가속을 비활성화 하는 Property였습니다.이걸 왜 넣었나 하고 Freedcamp의 작업 이력을 보아하니 [안드로이드 일부 운영체제에서 앱이 꺼지는 이슈]를 수정하기 위해서 해당 Property를 사용했다는 것을 알 수 있었습니다.실제로 해당 Property를 넣고 여러 안드로이드 기기로 테스트를 해본 결과, Android 11버전 이상의 기기에서 크래시 현상이 발견 되었습니다.그런데 이 Property를 넣으면 텍스트가 안보이고, 빼면 팅겨버리는 문제가 발생해서 다른 방법이 없나 찾아보고 있었습니다.애초에 API 문서에 따르면 androidHardwareAccelerationDisabled는 Deprecated 된 Property였기도 하구요.해결 방법React Native Webview android crash 라는 키워드로 구글링을 한 결과, 결국에는 문제를 해결하긴 했습니다.해결 하기는 했는데, 이걸 해결 했다고 봐야 할지 잘 모르겠습니다.저랑 같은 이슈로 인해 고통받는 사람들이 남겨둔 과거의 유산을 활용해본 결과, 방법은 두 가지가 있었습니다. androidHardwareAccelerationDisabled를 사용한다. { opacity: .99, overflow: &#39;hidden&#39; } Style을 Webview에게 준다.1번은 사용할 수 없으니 무조건 2번을 골라야만 하는 상황인데, 이게 도대체 어떤 원리로 해결 해준다는거지? 라는 생각으로 Webview에 넣어본 결과, 이슈는 여전했습니다.“그럼 그렇지” 라며 다시 구글링을 하러 가는데, 한국의 개발자 한 분이 남기신 게시글을 보게 되었습니다.이 분은 overflow: &#39;hidden&#39;이 아닌, maxHeight: 1을 줘서 해결 했다고 합니다.실제로 효과가 있는지 시험해보기 위해서 해당 Style을 넣어봤고, 정상 동작하는 것을 확인했습니다.const Styles = { webview: { minHeight: 1, opacity: .99, },};아니 도대체 이게 무슨 원리로 되는건지 직접 사용하고도 어이가 없어서 구글링을 잔뜩 해봐도 원리를 말하는 사람이 단 한명도 없어서 원리도 모르고 사용하는 코드 중 하나가 되었습니다.그래서 원래는 이 글도 작성을 하지 않으려고 했다가, 추후에 같은 상황을 마주했을 때 쉽게 수정하기 위해서 혹은 같은 문제를 앓고 있는 다른 개발자 분들을 위해서라도 문서화 결정을 내렸습니다." }, { "title": "SEO 테스트하기 좋은 서비스", "url": "/posts/seo-test-service/", "categories": "Tech, Talk", "tags": "Tech, SEO", "date": "2022-01-25 10:15:00 +0800", "snippet": "개요웹 페이지를 제작하다보면 해당 페이지가 Google에 정상적으로 표시가 되고 있는지 확인하고 싶을 때가 있습니다.Sitemap을 등록하고, robots를 등록하는 등의 작업을 거치더라도 이게 Google의 엔진이 읽을 수 있는 포맷으로 정상 등록 되어있는지 확인이 필요합니다.대부분의 경우에는 본인이 소유한 웹 페이지에 Sitemap을 등록했다고 하면 Google search console에 해당 Sitemap을 등록하는 프로세스를 거칩니다.하지만 색인이 제대로 등록이 되는지를 확인하는데는 짧게는 며칠, 길게는 일주일이 걸리기 때문에 즉각적인 피드백을 받기는 힘들죠.그럴 때, Google이 제대로 웹 페이지를 읽을 수 있는지, Robots.txt가 내가 원하는대로 검색엔진에게 명령을 내리고 있는지를 미리 확인해볼 수 있는 사이트가 있습니다.https://www.xml-sitemaps.com/ 입니다.서비스 소개Sitemap.xml 파일 제작웹사이트에 접속하면 상단에 웹 주소를 입력할 수 있는 입력창이 보입니다.입력창에 본인의 사이트 주소를 입력하면 짧은 스캔을 거쳐서 Sitemap.xml을 만들어줍니다.SEO Tools상단 메뉴에서 SEO TOOLS 메뉴를 누르면 사진과 같은 화면이 나옵니다.우측 메뉴에서 Sitemap이 정상적인 포맷으로 등록이 되어있는지, 구글 검색엔진이 해당 사이트를 탐색이 가능한지, 해당 페이지의 Response Header의 형태는 어떠한지 등 우리가 알고싶은 정보를 대부분 제공해줍니다.더 이상 Google Search Console에서 크롤링 갱신 타이밍을 기다리지 마세요!" }, { "title": "[Jekyll] `require&#39;: cannot load such file -- 2.6/ffi_c (LoadError)", "url": "/posts/jekyll_cannot_load_such_file_ffi/", "categories": "Tech, Jekyll", "tags": "Jekyll, Blog", "date": "2022-01-25 09:39:00 +0800", "snippet": "사건제 맥북이 어느 순간부터 Jekyll 기반 블로그들을 로컬에서 실행할 수가 없게 되었습니다.짐작가는 원인이랄게 전혀 없는 상황에서/Library/Ruby/Gems/2.6.0/gems/ffi-1.15.5/lib/ffi.rb:3:in `require&#39;: cannot load such file -- 2.6/ffi_c (LoadError) from /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.5/lib/ffi.rb:3:in `&amp;lt;top (required)&amp;gt;&#39; from /Library/Ruby/Gems/2.6.0/gems/sassc-2.4.0/lib/sassc/native.rb:3:in `require&#39; from /Library/Ruby/Gems/2.6.0/gems/sassc-2.4.0/lib/sassc/native.rb:3:in `&amp;lt;top (required)&amp;gt;&#39; from /Library/Ruby/Gems/2.6.0/gems/sassc-2.4.0/lib/sassc.rb:31:in `require_relative&#39; from /Library/Ruby/Gems/2.6.0/gems/sassc-2.4.0/lib/sassc.rb:31:in `&amp;lt;top (required)&amp;gt;&#39; from /Library/Ruby/Gems/2.6.0/gems/jekyll-sass-converter-2.1.0/lib/jekyll/converters/scss.rb:3:in `require&#39; from /Library/Ruby/Gems/2.6.0/gems/jekyll-sass-converter-2.1.0/lib/jekyll/converters/scss.rb:3:in `&amp;lt;top (required)&amp;gt;&#39; from /Library/Ruby/Gems/2.6.0/gems/jekyll-sass-converter-2.1.0/lib/jekyll-sass-converter.rb:4:in `require&#39; from /Library/Ruby/Gems/2.6.0/gems/jekyll-sass-converter-2.1.0/lib/jekyll-sass-converter.rb:4:in `&amp;lt;top (required)&amp;gt;&#39;bundle exec jekyll serve를 입력해도 이런 에러만 나오고 있는 상황이라 로컬에서 글을 확인하고 올릴 수가 없는 상황에 빠졌습니다.첫 번째 시도위 에러문에서 유독 눈에 띄는 부분이 있는데, cannot load such file -- 2.6/ffi_c 라고 적힌 부분입니다.의존성 패키지 중 ffi가 삭제라도 됐나 싶어서 gem install ffi를 입력해서 설치를 하고 실행해봐도 결과는 매한가지였습니다.두 번째 시도rm -rf 명령어로 프로젝트 폴더를 전부 지우고 Github에서 다시 Clone을 떠오는 방법을 사용해봤습니다.Github의 Workflow는 정상 동작을 하길래 이렇게 하면 되지 않을까 싶어 시도해 본 결과 같은 에러를 표시했습니다.해결 방법이게 직접적인 원인을 끼친건지, 아니면 여러 방법을 시도해보면서 간접적으로 영향을 끼친건지 정확히 판단은 되지 않습니다만 아래와 같은 방법을 통해 해결했습니다. gem update --system 명령어 실행 실행이 잘 되는 것 같다가 권한이 없다고 나옴. sudo gem update --system 명령어 실행 sudo를 앞에 붙여도 권한이 없다고 뜨긴 매한가지 위 에러문 무시하고 bundle exec jekyll serve 명령어 실행 bundle이 설치 되지 않았다고 나옴 gem install bundle 명령어 실행 bundle exec jekyll serve 명령어 다시 실행 정상 동작참고Error in jekyll installation" }, { "title": "[React Native] Please accept all necessary Android SDK licenses using Android SDK Manager", "url": "/posts/React_Native_Android_license_issue/", "categories": "Tech, React Native", "tags": "React Native, Android, M1", "date": "2022-01-24 14:32:00 +0800", "snippet": "개요최근 제 맥북 패키지가 여러모로 꼬여서 아예 공장 초기화를 돌린다음 개발환경을 다시 세팅했습니다.React Native 환경은 개발환경 초기 세팅이 아주 뭣같기로 유명합니다.실행만 하면 충돌이 일어나는데 원인은 모르겠는 상황이 참 많이 터지죠. 이번에 작성할 포스트도 그에 관해서 작성할 예정입니다.사건개발 환경 설정법에 따라서 JDK 설치하고, Android Studio 설치하고, 에뮬레이터도 설치하고나서 yarn android를 실행했습니다.정상적으로 나올 것을 기대하고 실행했는데, 역시 한 번에 되는 법은 없듯이 에러가 바로 튀어나왔습니다.error Failed to install the app. Please accept all necessary Android SDK licenses using Android SDK Manager: &quot;$ANDROID_HOME/tools/bin/sdkmanager --licenses&quot;.Error: Command failed: ./gradlew app:installDebug -PreactNativeDevServerPort=8081뭔가 라이센스 어쩌구 하는 에러가 나왔습니다.보아하니 Android SDK에 대한 라이센스를 수락해달라는 내용 같은데, 저번에 설치할 때는 못봤던 이슈라서 좀 난감했습니다.구글에다가 검색해보니 해결 방법을 찾게 되어 밑에 정리합니다.해결 방법 Android studio의 SDK Manager를 실행합니다. Appearance &amp;amp; Behavior 탭을 선택합니다. Android SDK 탭을 선택합니다. Android SDK Command-line Tools(latest) SDK가 미설치 되어있다면 해당 SDK를 설치합니다. open ~/.zshrc를 실행하고 가장 아랫줄에 환경 변수를 작성해줍니다. export ANDROID_SDK=/Users/&amp;lt;your_computer_name&amp;gt;/Library/Android/sdkexport PATH=/Users/&amp;lt;your_computer_name&amp;gt;/Library/Android/sdk/platform-tools:$PATH source ~/.zshrc를 실행하여 환경 변수를 적용합니다.참고M1 React Native Android Studio 시뮬레이터 이슈" }, { "title": "회사 기술 블로그 구축 완료!", "url": "/posts/product-tech-blog-of-company/", "categories": "Tech, Talk", "tags": "Jekyll", "date": "2022-01-24 11:59:00 +0800", "snippet": "회사 기술 블로그 구축현재 제가 다니고 있는 회사 단감소프트의 기술 블로그를 구축했습니다.회사 업무로 인해 마주친 이슈들과 그 해결 방법들을 주로 올리게 될 것이며, 제가 작성한 문서 중 일부는 이 블로그에도 옮겨올 계획입니다.기술 블로그의 장점기술 블로그의 장점은 다음과 같습니다. 기술적인 이슈들을 기록하므로, 같은 이슈가 벌어졌을 때 대응이 빠르게 이루어짐 기술 이슈를 기록함으로 인해 기록자의 기억에 확실히 남음 개발 생태계 전체에도 이로운 활동임 본인만 보는 문서에 기록하면 기록을 대충하게 되는데, 남에게 설명하듯 작성할 필요가 있다면 문서를 상세히 기록하게 됨왜 도입을 생각했나?우리 회사의 문제점은 다음과 같습니다. 저마다 이슈를 해결한 경험을 공유하지 않음 아예 기록을 하지 않거나 본인의 Private Notion에만 정리해둠위 문제점은 공개적인 기록을 하지 않는 점에서 비롯 된 문제라고 생각되어, 사내 구성원 뿐 아니라 블로그에 들어오는 모두에게 본인의 경험을 전해줄 수 있는 기술 블로그가 해결책이 될 것이라고 생각되었기 때문입니다.위에 도입한 문제를 해결할 것 같은가?아직은 잘 모르겠습니다. 구성원분들의 개발 경험을 공유할 시간을 별도로 마련하기에는 여건 상 문제가 있고, 평소 Markdown 기반의 문서 작업을 하지 않는 구성원이 많아서 Markdown 기반의 Jekyll 블로그는 정서적으로 거리감이 느껴지는 듯 합니다.그렇지만 본인의 경험을 공유하는 것을 중요한 가치로 여기고 있고, 기록의 중요성을 강력하게 체감했기에 구성원 모두가 거리낌 없이 받아들일 수 있는 정책으로 활용될 때 까지 저 혼자라도 문서를 작성해나갈 예정입니다.왜 Github가 아닌 Gitlab인가?이 블로그는 사실 회사에서 협의 된 내용으로 구축을 한게 아닌, 순전히 제 독단으로 구축한 블로그입니다.“이런 좋은게 있는데 이거 한번 무봐라!” 라는 심리로 일단 구축을 하고 아니면 빼자는 식으로 일단 무작정 만들어 본 페이지인 것이죠.그렇기 때문에 유료 그룹이여야만 페이지를 구축할 수 있는 Github Pages 솔루션을 사용할 수는 없었습니다.반면, Gitlab은 개인이건 그룹이건 블로그 구축 서비스가 무료길래 Gitlab으로 구축했습니다.여담원래 제 개인 블로그는 지금과는 다른 테마를 사용중이였습니다.처음 그 테마를 봤을 때는 제 마음에 드는 모든 기능들이 다 있어서 찬양하다시피 사용했었는데 회사 기술 블로그를 구축하기 위해 테마를 다시 찾던 도중 너무 뜬금없이 마음에 드는 테마를 찾아서 제 개인 블로그에 역적용을 해버렸습니다…" }, { "title": "[Jekyll] Liquid Exception: Liquid syntax error", "url": "/posts/liquid-exception-liquid-syntax-error/", "categories": "", "tags": "Tech, Jekyll, Blog, Github pages", "date": "2022-01-22 17:44:00 +0800", "snippet": "사건바로 이전 포스팅인 React Native Calendars 오픈소스를 파헤쳐보자를 작성하던 도중 있었던 일입니다.자꾸 프로젝트를 실행하면 계속 이런 에러문이 노출되면서 블로그를 로컬에서 실행할 수가 없게 되었습니다.Github pages에 배포를 하면 CI/CD와 Deploy가 무사히 진행이 되는게 보이는데도, 해당 포스팅이 노출되지 않는 이슈가 있었습니다.머릿말이 문제인가 싶어서 Front matter를 바꿔보기도 하고, 제목을 바꿔보기도하고, 포스트가 저장 된 폴더 경로를 바꿔보기도 하는 등 여러가지 노력을 했으나 게시물이 노출되지 않는 이슈가 이어졌습니다.해결Google에 검색하여 이 이슈에 대한 해결법을 기재한 게시글을 보게 되었습니다.원인Jekyll은 Liquid Template Language를 이용하여 문서를 읽어냅니다.그런데 이 Liquid의 문법에는 변수를 출력할 때 사용되는 {{ }}가 있습니다.문서 어딘가에 이와 같은 연산자를 사용하는 부분이 있기 때문에 Liquid의 Syntax와 충돌이 일어난게 원인이였던겁니다.방법이 부분에서 {{를 사용한 것이 원인이 되었기에 “Liquid 문법을 쓰려고 한게 아니예요”라고 Liquid에게 말해줘야 합니다.원인의 시작 부분에 {% raw %}를 적고, 종료되는 지점에 {% endraw %}를 적으면 해결할 수 있습니다.&amp;lt;Calendar markingType={&#39;period&#39;} markedDates={{ &#39;2012-05-15&#39;: {marked: true, dotColor: &#39;#50cebb&#39;}, &#39;2012-05-16&#39;: {marked: true, dotColor: &#39;#50cebb&#39;}, &#39;2012-05-21&#39;: {startingDay: true, color: &#39;#50cebb&#39;, textColor: &#39;white&#39;}, &#39;2012-05-22&#39;: {color: &#39;#70d7c7&#39;, textColor: &#39;white&#39;}, &#39;2012-05-23&#39;: {color: &#39;#70d7c7&#39;, textColor: &#39;white&#39;, marked: true, dotColor: &#39;white&#39;}, &#39;2012-05-24&#39;: {color: &#39;#70d7c7&#39;, textColor: &#39;white&#39;}, &#39;2012-05-25&#39;: {endingDay: true, color: &#39;#50cebb&#39;, textColor: &#39;white&#39;} }}/&amp;gt;" }, { "title": "React Native Calendars를 통해 오픈소스를 파헤쳐보자", "url": "/posts/react-native-calendar-opensource-review/", "categories": "Tech, Talk", "tags": "React Native, Review, Open Source", "date": "2022-01-21 22:11:00 +0800", "snippet": "기존에 사용하던 오픈소스회사에서 개발하고 있는 서비스 앱에 다음과 같은 캘린더가 있습니다.이 캘린더는 다음과 같은 기능을 합니다. 날짜 선택 버튼을 누르면 Navigation을 통해 표시가 된다. 날짜를 선택하면 해당 날짜에 작성 된 자신의 글이 목록에 노출 된다. 세로 방향으로 스크롤을 하면서 1개월씩 뒤로 앞으로 이동할 수 있다.매우 심플한 기능들입니다.우리는 이 기능을 React Native Calendars라는 오픈소스 라이브러리를 이용해 작업해 둔 상태였습니다.기획팀의 기능 추가 요청며칠 전, 기획팀은 사용성 증가를 위해서 캘린더 관련 기능 추가를 요청했습니다.추가해야 할 기능들 년, 월을 직접 선택하여 한번에 건너뛸 수 있는 기능 날짜 범위 검색 각 캘린더 사이에 컴포넌트 배치이렇게 세 가지 요청이 들어왔습니다.가능 여부 판단년, 월을 한번에 건너뛸 수 있는 기능 (추가 가능)React Native Calendars Documentation을 참고해서 해당 기능을 지원하는지 알아봤습니다.해당 기능을 직접적으로 지원하지는 않지만 renderheader Property를 지원하므로 년, 월에 대한 건너뛰기 기능을 자체적으로 제작하는 방향으로 해결할 수 있다고 판단하였습니다.날짜 범위 검색 (추가 가능)다행히도 해당 부분은 공식 API에서 지원을 하는 기능으로 보이기에 가능하다고 판단했습니다.&amp;lt;Calendar markingType={&#39;period&#39;} markedDates={{ &#39;2012-05-15&#39;: {marked: true, dotColor: &#39;#50cebb&#39;}, &#39;2012-05-16&#39;: {marked: true, dotColor: &#39;#50cebb&#39;}, &#39;2012-05-21&#39;: {startingDay: true, color: &#39;#50cebb&#39;, textColor: &#39;white&#39;}, &#39;2012-05-22&#39;: {color: &#39;#70d7c7&#39;, textColor: &#39;white&#39;}, &#39;2012-05-23&#39;: {color: &#39;#70d7c7&#39;, textColor: &#39;white&#39;, marked: true, dotColor: &#39;white&#39;}, &#39;2012-05-24&#39;: {color: &#39;#70d7c7&#39;, textColor: &#39;white&#39;}, &#39;2012-05-25&#39;: {endingDay: true, color: &#39;#50cebb&#39;, textColor: &#39;white&#39;} }}/&amp;gt;markedDates Property에 YYYY-MM-DD 포맷의 key들로 이루어진 Object를 넣고, 범위로 표시하고 싶은 날짜의 시작일에는 startingDay Propery를, 종료일에는 endingDay를 삽입하는 방식으로 해결할 수 있다고 적혀있습니다.각 캘린더 사이에 컴포넌트 배치 (추가 불가능)가장 큰 문제는 이 부분이였습니다.동그랗게 표시한 부분, 각 캘린더 사이에 우리가 직접 만든 컴포넌트를 삽입할 수 있냐는 내용인데, 공식 문서에 따르면 마땅한 방법이 존재하지 않습니다.왜 안되나? 스크롤 캘린더는 &amp;lt;CalendarList /&amp;gt; 컴포넌트를 활용하여 구성하기 때문에 각각의 캘린더가 아닌 사실상 하나의 캘린더임 renderHeader처럼 헤더를 정의하는 Property나 renderDay처럼 날짜를 렌더링하는 Property는 있지만 하단에 추가하는 Property가 없음없으면 만들어야지이번 추가 개발 사항에서 하필이면 해당 부분은 가장 Priority가 높다고 봐도 되는 부분이였기에 난감한 상황이였습니다.이제 와서 다른 캘린더를 사용하자니 기존에 개발 되어 있던 기능들이 너무 방대했기에 이 작업들을 다시 진행하는 것은 사실상 무리였습니다.무엇보다 다른 캘린더들은 이 캘린더만큼의 확장성을 지원하지 않고, React Native 생태계에서 가장 유명한 캘린더 라이브러리가 이 라이브러리였기 때문에 변경은 최대한 지양해야 했습니다.React Native 캘린더 라이브러리 순위표그래서 최대한 이 캘린더를 활용하는 방향으로 작업을 진행하기로 결정했고, 그렇게 한 번도 하지 못했던 오픈소스 개발이 시작 되었습니다.오픈소스 뜯어보기시작은 언제나 index원래 아무것도 모를 때는 진입점부터 뜯어봐야 합니다.프로젝트의 진입점인 src/index.ts부터 오픈을 하니 컴포넌트를 불러와서 export하는 페이지였습니다.export {default as Calendar} from &#39;./calendar&#39;;export type {CalendarProps} from &#39;./calendar&#39;;export {default as CalendarList} from &#39;./calendar-list&#39;;export type {CalendarListProps} from &#39;./calendar-list&#39;;export {default as Agenda} from &#39;./agenda&#39;;export type {AgendaProps} from &#39;./agenda&#39;;export {default as ExpandableCalendar} from &#39;./expandableCalendar&#39;;export type {ExpandableCalendarProps} from &#39;./expandableCalendar&#39;;export {default as WeekCalendar} from &#39;./expandableCalendar/WeekCalendar&#39;;export type {WeekCalendarProps} from &#39;./expandableCalendar/WeekCalendar&#39;;// 중략우리가 해야하는 것은 CalendarList 컴포넌트에 renderFooter를 추가하는 것.그 전에 모든 캘린더의 원형이 되는 것 같은 Calendar부터 시작하기로 했습니다.모든 것은 언제나 원형부터어차피 CalendarList, Agenda와 같은 확장성 컴포넌트들은 Calendar를 이용해서 만들었을테니 가장 기초가 되는 calendar/index.tsx를 열어보기로 했습니다.특징Calendar를 포함한 해당 라이브러리의 모든 컴포넌트들은 다음과 같은 특징을 갖고 있었습니다. export interface CalendarProps와 같이 Interface로 Type을 정의하고 추출하고 있음 Class 안에서 static displayName = &#39;Calendar&#39;;과 같이 컴포넌트의 이름을 정의하고 있음 Class 안에서 해당 컴포넌트가 받을 Props의 원형을 static propTypes로 정의하고 있음 컴포넌트들이 대부분 Class Component 구조로 작성 되어 있음흐름현재로서는 변수가 정의 되어서 어떻게 쓰이는지에 대한 흐름을 모르니 일단 export는 무시하고 넘어갑니다.지금으로서 유일하게 가능한 것은 화면단에 데이터를 뿌리는 render() 메소드를 분석하는 것이였기에 가장 먼저 render를 찾아갔습니다. render() { const {enableSwipeMonths, style} = this.props; const GestureComponent = enableSwipeMonths ? GestureRecognizer : View; const gestureProps = enableSwipeMonths ? this.swipeProps : undefined; return ( &amp;lt;GestureComponent {...gestureProps}&amp;gt; &amp;lt;View style={[this.style.container, style]} accessibilityElementsHidden={this.props.accessibilityElementsHidden} // iOS importantForAccessibility={this.props.importantForAccessibility} // Android &amp;gt; {this.renderHeader()} {this.renderMonth()} &amp;lt;/View&amp;gt; &amp;lt;/GestureComponent&amp;gt; ); }renderHeader라는 메소드와 renderMonth라는 메소드를 통해 캘린더 하나를 뿌려주고 있는 형태라는 것을 알 수 있습니다.우리가 여기서 하고싶은건 renderFooter를 만드는 일이죠. 그렇지만 원리를 모르기에 renderHeader를 벤치마킹 하기 위해 renderHeader의 구조를 잠깐 살펴 봅시다.renderHeader 구조 renderHeader() { const {customHeader, headerStyle, displayLoadingIndicator, markedDates, testID} = this.props; let indicator; if (this.state.currentMonth) { const lastMonthOfDay = toMarkingFormat(this.state.currentMonth.clone().addMonths(1, true).setDate(1).addDays(-1)); if (displayLoadingIndicator &amp;amp;&amp;amp; !markedDates?.[lastMonthOfDay]) { indicator = true; } } const headerProps = extractComponentProps(CalendarHeader, this.props); const CustomHeader = customHeader; const HeaderComponent = customHeader ? CustomHeader : CalendarHeader; const ref = customHeader ? undefined : this.header; return ( &amp;lt;HeaderComponent {...headerProps} testID={testID} style={headerStyle} ref={ref} month={this.state.currentMonth} addMonth={this.addMonth} displayLoadingIndicator={indicator} /&amp;gt; ); }renderFooter 생성renderHeader 메소드를 벤치마킹하여 비슷한 구조로 renderFooter를 만들어줍니다. renderFooter() { const {customFooter, renderFooter} = this.props; const Footer = customFooter ? customFooter : CalendarFooter; const ref = customFooter ? undefined : this.footer; return ( &amp;lt;Footer ref={ref} month={this.state.currentMonth} renderFooter={renderFooter} /&amp;gt; ); }기본적은 구조는 renderHeader 메소드의 구조를 그대로 갖고왔습니다. props로 customFooter를 받습니다. 아마 얘가 사용자 정의 컴포넌트를 넘기는 Property겠죠. customFooter가 안넘어온다면 컴포넌트에서 자체적으로 정의한 Basic 컴포넌트를 호출하고, 있다면 customFooter 컴포넌트를 사용합니다.그러면 이제 CalendarFooter를 정의하지 않았으니 만들러 가야겠네요.Basic Footer Class 만들기Header 구조 벤치마킹 하기오픈소스 개발자의 컨벤션에 맞추기 위해, 비교 대상이 되는 header의 구조를 그대로 벤치마킹 하여 footer를 만듭니다. export interface CalendarFooterProps 일단 FooterProps Interface를 추출 해주고 class CalendarFooter extends React.Component&amp;lt;CalendarFooterProps&amp;gt; Class 선언 해주고 static displayName = &#39;CalendarFooter&#39;; 컴포넌트 이름 정의 해주고 static propTypes = Props 원형 정의 해주면 기본 구조는 완성Header 렌더링 방식 벤치마킹하기header/index.tsx를 봤을 때 렌더링의 핵심 기능은 이 부분 같습니다.다른건 다 모르겠고, renderHeader를 Property로 받아서 renderHeader가 있다면 Property의 renderHeader를 실행하는게 인상깊네요.이 구조를 그대로 벤치마킹 합니다. renderHeader = () =&amp;gt; { const {customHeaderTitle, renderHeader, month, monthFormat, testID, webAriaLevel} = this.props; const webProps = Platform.OS === &#39;web&#39; ? {&#39;aria-level&#39;: webAriaLevel} : {}; if (renderHeader) { return renderHeader(month); } if (customHeaderTitle) { return customHeaderTitle; } return ( &amp;lt;Fragment&amp;gt; &amp;lt;Text allowFontScaling={false} style={this.style.monthText} testID={testID ? `${HEADER_MONTH_NAME}-${testID}` : HEADER_MONTH_NAME} {...webProps} &amp;gt; {formatNumbers(month?.toString(monthFormat))} &amp;lt;/Text&amp;gt; &amp;lt;/Fragment&amp;gt; ); };renderFooter 완성최대한 핵심 기능 원리를 이해하여 간단하게 만들면 이렇게 됩니다. renderFooter() { const {props} = this; const {renderFooter, ...other} = props; if (renderFooter) return renderFooter(other); return ( &amp;lt;View {...props}&amp;gt;&amp;lt;/View&amp;gt; ); }BasicHeader와는 다르게 기본 기능이 없기 때문에 단순 &amp;lt;View&amp;gt; 컴포넌트만을 띄우고 props를 바인드 하는 기능을 제작합니다.다만, renderFooter를 통해서 사용자 정의 컴포넌트가 넘어오는 경우를 커버하기 위해서 매개변수로 현재 캘린더 컴포넌트가 갖고 있는 모든 props 정보를 매개변수로 넘겨줍니다.그렇게 되면 API를 사용하는 사용자 입장에서는 renderFooter Property의 Callback 안에서 보다 다양한 기능을 만들 수 있겠죠.약간 신경 쓰이는 점이 쯤에서 약간 신경 쓰이는 부분이 있습니다.static displayName과 propsTypes는 왜 정의하는걸까요?그 부분을 알아보기 위해 renderHeader 메소드를 잠깐 다시 살펴봅시다. renderHeader() { const {customHeader, headerStyle, displayLoadingIndicator, markedDates, testID} = this.props; let indicator; if (this.state.currentMonth) { const lastMonthOfDay = toMarkingFormat(this.state.currentMonth.clone().addMonths(1, true).setDate(1).addDays(-1)); if (displayLoadingIndicator &amp;amp;&amp;amp; !markedDates?.[lastMonthOfDay]) { indicator = true; } } const headerProps = extractComponentProps(CalendarHeader, this.props); const CustomHeader = customHeader; const HeaderComponent = customHeader ? CustomHeader : CalendarHeader; const ref = customHeader ? undefined : this.header; return ( &amp;lt;HeaderComponent {...headerProps} testID={testID} style={headerStyle} ref={ref} month={this.state.currentMonth} addMonth={this.addMonth} displayLoadingIndicator={indicator} /&amp;gt; ); }여기서 신경쓰이는 부분이 하나 있는데, extractComponentProps 함수의 존재입니다.얘는 역할이 뭘까요? 함수 선언부로 가봅시다.exteractComponentPropsexport function extractComponentProps(component: any, props: any, ignoreProps?: string[]) { const componentPropTypes = component.propTypes; if (componentPropTypes) { const keys = Object.keys(componentPropTypes); const componentProps = omit( pickBy(props, (_value: any, key: any) =&amp;gt; includes(keys, key)), ignoreProps ); return componentProps; } return {};}보아하니 여기서 쓰이는 멤버 변수들이였군요. 컴포넌트의 클래스 안에서 선언 된 propTypes Object에 적혀있는 key만을 유효한 Property로 간주함 그 외의 props는 다 잘라버림보안상의 이슈로 엄한 Property가 넘어오는 것을 막는 메소드였군요!완성캘린더 원형에 사용 된 Footer &amp;lt;Calendar customFooter={customFooter} /&amp;gt;스크롤 캘린더에 사용 된 Footer &amp;lt;CalendarList renderFooter={renderCustomFooter} /&amp;gt;가로 스크롤 캘린더에 사용 된 Footer &amp;lt;CalendarList horizontal renderFooter={renderFooter} /&amp;gt;느낀 점오리지널 레포지토리에도 Merge Request를 날리긴 했으나, 이게 Merge 될 지는 잘 모르겠습니다.급한대로 우리가 필요한 기능을 넣는걸 우선으로 했기 때문에 프로젝트에 대한 완전한 이해도 하지 않은 상황에서 만든 부분이라 날림이 조금 있기 때문입니다.하지만 처음으로 해보는 오픈소스 기여였기 때문에 인기 있는 오픈소스를 내 손으로 수정한다는 사실이 굉장히 흥미로웠고, 이를 해부하는 과정에서 상당히 깔끔한 구조의 코드를 배우는 등 아주 유익한 경험이 되었다고 생각합니다.아직 커미터의 리뷰가 도착하지 않았기 때문에 병합 대기 상태입니다만, 유익한 리뷰가 달린다면 참 좋을 것 같습니다!감사합니다!" }, { "title": "기술 블로그를 시작하게 된 이유", "url": "/posts/created-tech-blog/", "categories": "Tech, Talk", "tags": "Talk", "date": "2022-01-19 22:25:00 +0800", "snippet": "누구세요?안녕하세요? 프론트엔드 개발자 박찬영입니다.특성화 고등학교를 졸업한 이후 대학도 열심히 다니고 회사 일도 열심히 하면서 살아가는 평범한 개발자입니다.블로그를 개설한 이유저는 벌써 약 3년 6개월의 경력을 갖게 되었습니다. 4년차인거죠.나름 회사에서 인정도 받으며 커리어를 쌓고 있으니 한참 자신감이 뿜뿜하던 2021년.개발 과정에서 직면한 이슈를 수정하기 위해 짧은 영어 실력을 굴려가며 구글에 검색을 하고 있었습니다.요즘은 영어만 사용하여 검색을 해도 양질의 한국어 자료가 많이 나오는걸 보면서 “내가 사용하고 있는 언어의 생태계와 한국 개발자 생태계가 예전과는 다르게 급성장 하는구나!”와 같은 감상을 늘어놓음과 동시에 국내 메이저 기업들의 기술 블로그에 당도하게 되었습니다.메이저 기업에 다니는 훌륭한 개발자가 작성한 문서는 이슈를 해결함과 동시에 저의 지식을 채워주는 양분이 되었습니다.저였다면 아무런 생각 없이 진행하는 패키지 설치 과정에서마저 불편함을 느끼고 방법을 개선하는 개발자들의 탐구력과 통찰력에 감탄하고 있던 와중 해당 게시글을 작성했던 개발자의 정보가 눈에 들어왔습니다.“이제 막 개발 업계에 들어온지 1년 된 프론트엔드 개발자입니다!”자괴감저는 이 짧막한 자기 소개를 보고는 자괴감이 들기 시작했습니다. “나는 여태까지 뭘 한거지?” “나는 사실 프로그래밍을 못하는 편인가?” “나는 나름 프로그래밍을 잘한다고 생각했는데… 요즘은 저정도 실력이 평균인건가?”위와 같은 자학적인 생각들이 머리속을 지배하게 되었고, 저의 과거를 곱씹어 보았습니다.프로그래밍 경진대회 수상, 대학교에서 교수님들께 들었던 수많은 칭찬, 스타트업 입사 2년만에 엔지니어링 매니저로서 개발팀을 지도했던 경험 등 모든게 완벽한 커리어였다고 생각했는데 알고보니 이 모든 것들은 기술자로서의 개발 능력과 친화력 높은 성격만을 인정 받은게 아닌가 라는 생각이 들기 시작했습니다.제가 되고 싶었던 훌륭한 소프트웨어 연구자의 관점으로서 저를 돌아본다면 내 주변에 상주하는 일상적인 불편함을 해소시켜 본 경험도, 퍼포먼스를 개선시켰지만 이를 얼마나 개선 시켰는지 수치화를 해봤던 경험도, 나의 개발 방식이 어떤 원리로 동작하는 지에 대한 탐구도 전혀 하지 않았다는 것을 알게 되었습니다.내가 바랐던건 많은 사람들의 멘토가 되는 개발자였고 나름 그 길에 가까워졌다고 생각했는데 알고보니 단순히 요령만 좋았던 기술자 그 이상 그 이하도 아니였던 것입니다.기록을 시작하게 된 계기그러던 와중, 과거 우아한형제들의 리드 개발자, 현 인프런 개발자인 Jojoldu선배님의 인터뷰 영상을 보게 되었습니다.인터뷰 영상을 보면 평범한 어투로 말씀하시는 이 내용들이 제 마음 어딘가에 있던 핵심을 찌르는 듯한 느낌을 받았습니다.되돌아본 나의 문제점 돌이켜보면 나름 배운 것도 많고 아는 것도 많은데 이를 어디에도 기록하지 않아 나의 실력을 증명할 수 있는건 나의 입 말고는 없다는 것 예전에 분명 해결했었던 이슈인데도 동일한 이슈를 다시 접했을 때 해결 방법이 기억이 나지 않아 구글링을 하던 적도 있었다는 것 기술 면접 때, 어떤 용어에 대한 질문을 듣고 그게 뭔지 한참 생각했던 적이 있는데 나중에 조사해보니 “아 이게 그 뜻이였어?” 라고 생각했던 상황이 정말 많았다는 것이 모든것을 한번에 해결할 수 있는 방법은 역시 기록이다. 라고 생각하게 되었습니다.기록의 시작TIL문제점을 찾은 저는 4년차 개발자가 되어서야 남들 다 하는 TIL을 시작하게 되었습니다.TIL을 하다보니 제가 겪었던 대부분의 이슈, 이벤트 등을 지칭하는 용어들이 이미 있다는 사실을 알게 되었고, 동료 개발자들끼리 대화할 때 일부 용어를 못알아 듣는 상황이 현저히 적어졌습니다.1일 1커밋?1일 1커밋을 목표로 잡고 기록을 시작한지 5개월 째 되었습니다.중간 중간 친구들과 너무 즐겁게 노는 나머지 커밋 하는 것을 잊어버려서 구멍이 많이 뚫려있지만 그래도 하루 하루 초록색이 쌓여가는 모습이 보기 좋은 Contributions을 얻게 되었습니다.기록만 해놓으면 뭐하냐그렇게 기록이 주는 재미의 맛을 알게 될 때 쯤, Vue 생태계에 발을 들이시려는 우리 회사 퍼블리셔분으로 부터 Nuxt 세팅 방법에 대해 질문을 받았습니다.초기 세팅 방식은 조금 복잡해서 과거 TIL을 정리할 때 기록해 두었던 사항이라 “드디어 나의 기록을 활용할 기회인 것인가?!” 라고 생각하고 정리해뒀던 문서를 건네드렸습니다.그러자 조금 뒤에 그 분으로부터 답장을 받게 되었습니다.“여기서 뭐 눌러야 돼요?”그 질문을 받은 저는 “문서에 분명 상세히 적혀있는데 왜 다시 여쭤보실까?” 라고 생각하며 제 문서를 다시 읽어보았습니다.그러자 한숨이 절로 나왔습니다.어차피 저만 읽어볼 것을 상정하고 만든 문서라서 가독성은 말할 것도 없었고, 세부 선택 사항들은 이미 내가 알고 있다는 것을 전제로 적은 문서였기 때문에 디테일한 내용들이 누락 되거나 일부는 아예 기록조차 하지 않았다는 것을 알게 되었습니다.애초에 “나만 볼 것”을 전제로 만든 나만의 필기노트 같은 느낌으로 작성했던 부분이라서 다른 사람은 이해할 수가 없을정도로 처참한 결과물이 나온 것입니다.이 일을 계기로 나만 보기 위해서 적는 것이 아닌, 내가 겪었던 문제를 겪는 다른 개발자들을 위한 문서를 적는다는 생각으로 작성하는 방향으로 노선을 바꾸게 되었습니다.기술 블로그 시작그런데 “내 Github에만 문서를 잘 정리해놓으면 그걸 누가 보긴 할까?” 라는 가장 원초적인 질문이 제 머리속을 지나갔습니다.애초에 Github의 README.md 뷰어는 그다지 읽고싶게 생기지도 않았다는 추가적인 이슈는 덤이구요.곰곰히 생각해본 결과, “개인 블로그에 글을 써보는건 어떨까?” 라는 생각이 들었습니다.사실 기술 블로그를 시작하는게 처음은 아닙니다. 고등학생 때 그냥 남들 다 하길래 따라서 시작해본, 영양가 없는 문서들이 몇 달 간격으로 하나씩 올라오는 거의 버려진 블로그가 있던 상태였습니다.처음에는 이 블로그를 어떻게 좀 살려보자는 생각으로 글을 쓰기 시작했는데, 일반적인 글 작가분들께 특화 된 에디터와 뷰어 때문에 코드를 작성하기에 썩 좋은 선택지가 아님을 알게되어 현재의 Github Pages 블로그로 갈아타게 된 것입니다.그렇게 현재까지좀 더 꾸준하고 퀄리티있는 문서들로 TIL을 채우면서 저의 귀차니즘 해결과 전문 지식 습득이라는 두마리의 토끼를 열심히 잡고 있습니다.덤으로, 제 주변에 상주하는 불편함을 발견하는 통찰력을 기르기 위해서 세상 모든 일에 대해 왜? 라는 질문을 던지기 시작했습니다. 담배에는 니코틴만 넣으면 몸에도 해롭지 않은 좋은 담배가 나올텐데 왜 타르같은걸 넣는거지? 사거리 횡단보도가 켜지는 알고리즘은 뭘까? 지하철이 스크린도어에 딱 맞게 멈출 수 있는 원리는 뭘까?위와 같이 정말 별것도 아닌 것 같은 일에 대해 호기심을 갖고 탐구하는 습관을 가지려고 노력중입니다.누가 보면 미친것 같다고 할 수도 있지만 원래 어떤 분야든 한 구석이 미친 사람만이 미친듯한 성과도 낼 수 있다고 생각하거든요!다른 사람이 저를 보고는 “쟤는 좀 미친 것 같은데 일은 잘해” 라고 말하게 되는게 제 단기적인 목표입니다.마치며즉흥적으로 끄적인 글이라 문장 구성에 미흡함이 느껴질 수도 있습니다.그 때 당시에 느꼈던 복잡했던 심리를 그대로 살려 작성한 글이라서 상당히 감정이 많이 실려있다고 느끼실 수도 있습니다.하지만 이런 감정이 담긴 글을 기재함으로서 블로그에 애착을 갖게 되고, 오랜 활동으로 이어질 수 있는 원동력이 되지 않을까 싶어 이렇게 작성해봅니다.두서 없는 글 읽어주셔서 감사합니다!" }, { "title": "[React Native] StyleSheet.create vs Plain Object", "url": "/posts/StyleSheet.create_vs_plain_object/", "categories": "Tech, React Native", "tags": "React Native, Performance", "date": "2022-01-19 14:46:00 +0800", "snippet": "StyleSheet.create vs Plain ObjectReact Native로 앱을 개발해 본 적이 있는 분들이라면 css를 선언할 때const Styles = StyleSheet.create({ container: { flexDirection: &#39;row&#39;, },});처럼 StyleSheet.create를 사용하여 선언하는 방식과const Styles = { container: { flexDirection: &#39;row&#39;, },};처럼 Plain Object를 통해 선언하는 방식을 본 적이 있을겁니다.둘 중 어떤 방식을 취하더라도 스타일을 전달하는데는 문제가 없습니다. 그러면 당연히 Plain Object를 썼을 때보다 StyleSheet.create로 선언을 했을 때 취할 수 있는 장점이 있으니까 React팀이 StyleSheet 객체를 만들어뒀을 거라고 생각하게 됩니다.결론부터 말하자면 아무런 장점이 없습니다.StyleSheet가 주는 장점이 없다고?네 맞습니다. 장점 없어요. 대부분의 개발자들이 StyleSheet 객체를 이용함으로서 취할 수 있는 이득이 있다고 생각하고, 그 이점이라고 하면 대부분 성능 향상을 떠올립니다.하지만 놀랍게도 정말 장점이 없습니다.흔히들 하는 오해성능 향상의 이점이 있다.사실이 아닙니다. 성능면에서 Plain Object와 StyleSheet는 결과값이 완전히 동일하므로 성능면에서 아무런 차이가 없습니다.컴파일 타임에서 스타일 시트의 여부를 구분한다.사실이 아닙니다. 애초에 Vanila Javascript는 유효성 검사를 할 수 있는 기능이 없습니다.물론 런타임 때는 유효성 검사를 하지만 모두가 알다시피 두 방식으로 제작 된 스타일시트는 컴포넌트에 정상적으로 할당이 되며 동작마저 동일하게 이루어집니다.그럼 왜 만든거지?이 섹션은 성능 향상 오해와 뿌리가 같습니다.React Native팀은 StyleSheet를 별도로 만들고 성능 향상을 위해 개발을 시도한 적이 있습니다.실제로 React Native라이브러리의 StyleSheet 코드의 주석을 보면 성능과 관련한 섹션이 있는데, 매번 스타일 객체를 새로 만드는 대신 Style 요소에 고유의 ID를 생성하고 중복 사용 시 기존에 생성했던 ID를 이용하여 퍼포먼스 향상을 시도한 흔적이 보입니다만, (아직 구현되지 않음)이라는 코멘트가 붙여져 있는 것을 볼 수 있습니다.그러므로 성능면에서 더 나은 경험을 주려는 시도는 했으나 아직 차이를 보일만한 개발이 이루어지지는 않았다고 볼 수 있습니다.참조[Stackoverflow] React Native - What is the benefit of using StyleSheet vs a plain object" }, { "title": "Git 메시지 컨벤션", "url": "/posts/Git-message-convention/", "categories": "Tech, Git", "tags": "Git", "date": "2022-01-18 17:33:00 +0800", "snippet": "개요우리는 협업 과정에서 하나 이상의 버전 관리 툴을 사용합니다. 소스코드의 공유, 소스코드 백업 등 셀 수도 없이 다양한 이유가 있겠지만 ‘이력 관리’라는 강력한 기능을 활용하는 점에 대해서는 다른 의견이 없을겁니다.둘 이상이 소프트웨어 개발에 참여하다보면 서로가 개발한 부분이 Conflict가 발생하기도 할거고, 어제까지만 해도 이슈 없이 동작했던 부분인데 오늘 확인해보면 갑자기 안되기도 하죠.이럴 때 보통 어디부터 잘못 되었나 History를 살펴봅니다.이렇게나 중요한 기능인데도 불구하고 많은 개발자들은 Commit 메시지에 대해서는 세상 관대해지는 경우가 많습니다.단순히 기능 추가, 문서 수정 등 굉장히 포괄적인 메시지를 남김과 동시에 해당 메시지와 전혀 상관없는 변경 이력마저 한 커밋에 몰아서 Push하는 경우도 정말 많죠.(다른 회사에서 근무할 때는 커밋 메시지를 “dd”로 통일해서 올리는 개발자도 있었습니다…)그렇다면 어떻게 이 문제를 해결할 수 있을까요?Code 컨벤션이 있다면 Commit 컨벤션도 물론 있지다행히도 이러한 문제를 우리만 깨달은 것은 아닌지 해외의 개발자들이 무수한 논의 끝에 만들어놓은 좋은 컨벤션이 있습니다.이 문서에서는 해당 내용들을 정리해보겠습니다.문법커밋 메시지 구조VSCode 혹은 GUI 버전 관리 툴에서 커밋을 하는 사람들은 모르는 사람이 많지만, Commit 메시지는 HEAD BODY FOOTER 세 가지 구조로 나뉩니다. HEAD: 우리가 흔히 아는 커밋 메시지가 HEAD입니다. BODY: 이 작업이 왜 필요한지 상세히 기술하는 영역입니다. FOOTER: 이 작업을 통해 어떤 이슈를 수정했는지 기재하는 영역입니다. Github나 Gitlab은 단순히 Git Server의 역할만 하는 것이 아닌, Agile을 위한 Sprint Planning 기능도 지원합니다. 또한 소프트웨어에서 발견되는 Issue들도 정리할 수 있죠. Sprint 플랜을 추가하거나 Issue를 등록하면 해당 내용에 매칭되는 고유 번호가 발급되는데, 작업 내용과 연관 된 번호를 Footer에 적습니다. HEAD 컨벤션HEAD에는 간략하게 50자 이내로 변경 이유와 이 커밋으로 인해 어떤 점이 달라지는지를 명시해야 합니다. feat: 기존에 없던 기능 개발 fix: 이슈 수정 docs: 코드와는 상관이 없는 문서가 추가 및 수정 될 경우 style: 코드 컨벤션 등이 수정 될 경우 design: 디자인이 변경되어 해당 부분을 수정하는 코드를 짤 경우 refactor: 코드를 리팩토링 할 경우 test: 테스트 코드를 추가할 경우 chore: package.json이나 nuxt.config.js처럼 패키지 설치 및 환경 설정에 관련된 내용이 수정 될 경우예시 feat: 회원가입 기능 개발 fix: 회원가입 시 사용자 이름이 안보이는 이슈과거형대신 명령형커밋 메시지에는 과거형으로 적지 말고 현재형으로 적어야 합니다.feat: 회원가입 기능을 개발함 (x)feat: 회원가입 기능 개발 (o)끝에 점을 붙이지 마세요커밋 메시지는 점을 붙이지 않습니다.feat: 회원가입 기능을 개발함. (x)feat: 회원가입 기능 개발 (o)대문자로 시작하지 마세요영어로 커밋 메시지를 남기는 경우에 해당되는 얘기인데, 커밋 메시지는 소문자로 시작합니다.feat: Add join member (x)feat: add join member (o)BODY도 마찬가지로 과거형 대신 명령형을 사용합니다.HEAD와 같습니다.FOOTER 컨벤션이 변경 이력으로 인해 수정 된 주요 이슈를 간략하게 적어야 합니다.이슈를 수정했다면 아래와 같이 작성합니다.Resolved: #110여기서 110번은 발급 된 Issue의 번호입니다.예시feat: Summarize changes in around 50 characters or less &amp;lt;– HEADMore detailed explanatory text, if necessary. Wrap it to about 72 &amp;lt;– BODYcharacters or so. In some contexts, the first line is treated as thesubject of the commit and the rest of the text as the body. Theblank line separating the summary from the body is critical (unlessyou omit the body entirely); various tools like log, shortlogand rebase can get confused if you run the two together.Explain the problem that this commit is solving. Focus on why youare making this change as opposed to how (the code explains that).Are there side effects or other unintuitive consequenses of thischange? Here’s the place to explain them.Further paragraphs come after blank lines. Bullet points are okay, too Typically a hyphen or asterisk is used for the bullet, precededby a single space, with blank lines in between, but conventionsvary here If you use an issue tracker, put references to them at the bottom,like this:Resolves: #123 &amp;lt;– FOOTERSee also: #456, #789참고Commit message format" }, { "title": "[jekyll] 프로젝트 구동하는법", "url": "/posts/how_to_launch_jekyll/", "categories": "Tech, Jekyll", "tags": "Jekyll, Markdown, Notice", "date": "2022-01-18 13:07:00 +0800", "snippet": "개요마크다운 문서를 배포하기 전에 미리 보기 위해서, 블로그 레이아웃을 커스터마이징 하기 위해서 등등 여러가지 이유로 프로젝트를 로컬에서 구동 할 필요가 있습니다.본 문서는 Mac OS를 기준으로 작성 되었습니다.설치XCodeJekyll은 Ruby언어 기반으로 만들어진 SSG Framework입니다.그렇기 때문에 Ruby언어를 해석할 수 있는 컴파일러가 필요한데, 이를 설치하기 위해서 XCode를 먼저 설치합니다.RubyXCode를 설치하셨다면 Ruby언어를 읽을 수 있는 컴파일러를 설치할 수 있습니다. 터미널에서 아래의 명령어를 입력해주세요.# Install Homebrew/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;# Install Rubybrew install rubyRuby 환경변수 등록터미널에서 아래 명령어를 입력해주세요.# If you&#39;re using Zshecho &#39;export PATH=&quot;/usr/local/opt/ruby/bin:/usr/local/lib/ruby/gems/3.0.0/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.zshrc# If you&#39;re using Bashecho &#39;export PATH=&quot;/usr/local/opt/ruby/bin:/usr/local/lib/ruby/gems/3.0.0/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile# Unsure which shell you are using? Typeecho $SHELLRuby 설치 및 환경 변수 등록 여부 확인터미널에 which ruby와 ruby -v 명령어를 입력했을 때 아래와 같이 표시되면 설치가 되었다는 의미입니다.which ruby# /usr/local/opt/ruby/bin/rubyruby -vruby 3.0.0p0 (2020-12-25 revision 95aff21468)Jekyll 설치Ruby 패키지를 설치했다면 gem 명령어를 사용하실 수 있습니다. jekyll를 설치하기 위해 아래 명령어를 입력해주세요.gem install --user-install bundler jekyllJekyll 환경 변수 설정환경 변수를 설정하기 위해 아래 명령어를 입력합니다.# If you&#39;re using Zshecho &#39;export PATH=&quot;$HOME/.gem/ruby/X.X.0/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.zshrc# If you&#39;re using Bashecho &#39;export PATH=&quot;$HOME/.gem/ruby/X.X.0/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile# Unsure which shell you are using? Typeecho $SHELL환경 변수 설정이 완료 되었다면 아래 명령어를 통해 체크 해보실 수 있습니다.gem env프로젝트 실행의존성 패키지 설치이미 jekyll 프로젝트가 있다고 가정하고 작성합니다.jekyll 프로젝트 폴더에 들어가서 아래 명령어를 실행합니다. 블로그를 실행하기 위한 의존성 패키지를 설치하기 위한 과정입니다.bundle install실행아래 명령어를 통해 실행이 가능합니다.bundle exec jekyll serve접속위 명령어를 입력하셨고, 아무 에러도 나오지 않았다면 http://127.0.0.1:4000 주소로 웹 브라우저에 접속하실 수 있습니다!참고Jekyll 공식 가이드 문서" }, { "title": "[jekyll] 블로그에서 문서를 예쁘게 작성하는 방법", "url": "/posts/how-to-write-blog-post/", "categories": "Tech, Jekyll", "tags": "Jekyll, Markdown, Notice", "date": "2022-01-18 12:22:00 +0800", "snippet": "기술 블로그가 오픈 되었습니다!업무 중 마주한 문제점, 이를 해결하기 위해 진행했던 방법들을 기재해주시면 추후 같은 문제가 발생한 모든 개발자들을 위한 귀중한 자료가 될 것이니 많은 참여 부탁드립니다!게시물 작성 방법게시물 디렉토리Jekyll블로그는 _posts 디렉토리 안에 작성 된 파일들을 모두 게시물로 인식합니다.페이지 이름 작성 규칙_posts 디렉토리 안에 파일을 작성했다고 해서 무조건 페이지로 인식 되는 것은 아닙니다.YYYY-MM-DD-PAGENAME와 같은 파일명을 가진 파일들만 페이지로 인식되어 메인 페이지에 노출 되게 됩니다.예를 들어, Typescript 개요 문서의 경우는 실제 저장 된 파일 이름이 2022-01-18-00.Typescript.md로 작성 되어 있습니다.날짜는 보통 해당 문서가 작성 된 시간으로 구성하니 이에 맞춰주시면 되겠습니다.게시글 확장자Jekyll기반 블로그에서는 모든 포스팅을 Markdown을 이용하여 작성합니다.그렇기 때문에 매우 깔끔하고 예쁜 포스트를 작성할 수 있습니다.물론 HTML도 일부 사용은 가능합니다만, 일관성있는 문서 디자인을 유지하기 위해 Markdown만 이용하는 것을 권장드립니다.머리말Front Matter이라고 불리는 작성 방법이 있습니다.Jekyll Theme마다 사용하는 양식이 서로 다른데, 본 블로그는 Chirpy Jekyll Theme테마를 사용하고 있으므로 해당 테마에서 지원하는 머리말 양식을 사용해야 합니다.머리말에서는 해당 게시글의 제목, 작성한 사람, 작성일시, 게시물이 포함 될 카테고리, 태그 등을 기재합니다.머리말에 적힌 데이터를 기반으로 게시물들을 배치하기 때문에 반드시 알맞은 양식을 준수하셔야 합니다!---title: &quot;jekyll 블로그에서 문서를 예쁘게 작성하는 방법&quot;author: name: 박 찬영 link: https://github.com/univdevdate: 2022-01-18 13:22:00 +0900categories: [Editor]tags: [Editor, Jekyll]---본 문서의 경우는 위와 같은 머리말을 가지고 있습니다. title은 게시물의 제목을 의미합니다. author는 작성자의 정보를 입력합니다. 들여쓰기를 통해 author 아래에 name과 link를 사용할 수 있습니다. name은 작성자의 이름입니다. link는 해당 작성자의 프로필 등이 기재 된 링크를 작성해주시면 됩니다. 없다면 아예 이 필드를 작성하지 말아주세요! date는 게시물이 작성 된 일자와 시간을 입력해주시면 됩니다. YYYY-MM-DD HH:mm:ss UTC 포맷으로 입력해주시면 됩니다. YYYY-MM-DD는 2022-01-18과 같은 양식을 의미합니다. HH:mm:ss는 14:23:11과 같은 양식을 의미합니다. 14시 23분 11초라는 의미입니다. UTC는 그리니치 천문대 기준 현지 시간과의 시차를 적용해주시면 됩니다. 한국에서 적는 포스트라면 그리니치 천문대와는 9시간 차이가 나기 때문에 +0900으로 적어주시면 됩니다. categories는 해당 글이 작성 된 게시판을 배열 형태로 작성해주시면 됩니다. 예를 들어, Typescript 개요 문서의 경우에는 [typescript, basic] 카테고리를 갖습니다. 배열의 index는 카테고리의 깊이를 의미하며, [typescript, basic]을 예시로 들자면, Typescript 하위의 Basic이라는 카테고리로 구분 됩니다. tags는 해당 게시물과 연관 된 태그를 입력해주시면 됩니다. 추후 태그로 검색이 이루어질 때 사용되며, 여기서의 배열은 태그를 여러 개 받기 위함이지 인덱스에 따라 깊이가 달라지지는 않습니다. 본문머리말의 끝맺음 이후 한 줄을 내려서 본문을 작성하시면 됩니다. Markdown 문법을 준수하셔서 작성해주시면 아주 예쁘게 작성이 됩니다.헤더를 이용한 문서 네비게이션위에 첨부 된 Markdown 문법 중 Header를 표현할 수 있는 # 문법을 자주 활용해주세요!문서를 탐색할 때 도움이 됩니다. #, ##, ###순서대로 하위 컨텐츠를 의미합니다.이 사항을 준수해서 문서를 작성해주시면 다음과 같이 문서 탐색에 아주 도움이 되는 네비게이션이 자동으로 완성됩니다!링크 변수다음과 같은 문법으로 링크 변수를 작성하실 수 있습니다.[변수 이름]: 링크이 링크 변수는 아무 곳에서 정의해도 상관은 없지만 보통은 문서 최하단에 정리해둡니다. 작성해 둔 링크 변수는 링크가 들어갈 곳에 링크 대신 치환하여 쓸 수 있습니다.같은 링크가 문서 내 여러 곳에 등장할 경우 사용하시면 굉장히 유용합니다. 이 문서에서도 쓰고 있어요! 원래 링크는 이런 식으로 작성합니다. [Test Link](https://example.com) 하지만 변수 링크를 사용한다면 이런 식으로 적을 수 있어요. [Test Link][Test Link] [Test Link]: https://example.com이미지 첨부게시글을 작성하시다가 이미지를 첨부해야하는 경우가 있을 수 있습니다.게시할 이미지를 assets/posts에 저장하시고 이미지를 첨부할 때는 ![이미지](/assets/posts/...)와 같은 형태로 첨부 해주시면 되겠습니다.![이미지][path variable]처럼 링크 변수를 활용하실 수도 있습니다!배포이 블로그의 경우 CI 세팅을 마친 레포지토리에서 동작하고 있기 때문에 master 브랜치에 push하는 것만으로 블로그가 자동으로 갱신 됩니다!다만, Github와는 다르게 Gitlab기반으로 동작하기 때문에 자동 배포까지 어느정도 시간이 걸립니다. (대략 1~2분)" }, { "title": "[Typescript] 999. Typescript 에러", "url": "/posts/999.typescript_%EC%97%90%EB%9F%AC/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Typescript 관련 컴파일 오류목록Cannot find module ‘typescript’https://stackoverflow.com/questions/44611526/how-to-fix-cannot-find-module-typescript-in-angular-4npm install -g typescriptnpm link typescriptReference - https://grr1.tistory.com/42" }, { "title": "[Typescript] 11. 열거형", "url": "/posts/11.enum/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Enum개요프로그래밍을 배우다보면 Enumeration 자료형에 대해서 들어본 적이 있을 것이다.일정 범위 안에 들어오는 값만을 고를 수 있는 자료형으로, 열거형이라고 부른다. 아래 예제를 보자.const paint = (brush) =&amp;gt; { if (brush === &#39;square&#39;) return console.log(&#39;square&#39;); if (brush === &#39;circle&#39;) return console.log(&#39;circle&#39;); return console.log(&#39;nothing&#39;);};그림판에서 brush의 모양에 따라 그려지는 방식을 다르게 한다고 하면 위와 같이 구현이 가능할 것이다.하지만 매개변수의 brush의 값은 square circle 둘 중 하나여야만 정상적으로 동작한다. 물론 그 외 값이 들어와도 nothing 처리를 해뒀기 때문에 에러는 나지 않지만 nothing이 표시가 되는 일은 없어야 한다.그럴 때 열거형을 사용할 수 있다.const enum BrushType = { SQUARE = &#39;square&#39;, CIRCLE = &#39;circle&#39;,};const paint = (brush: BrushType) =&amp;gt; { // ...};paint(BrushType.SQUARE); // paint(&#39;square&#39;);enum 키워드로 열거형을 선언할 수 있으며, type처럼 사용할 수 있다.Value가 없는 열거형만약 enum객체를 선언할 때 굳이 value를 지정해주지 않아도 될 상황이 있다.어차피 enum만 허용할건데 enum을 대표하는 value들을 지정해 줄 필요는 없기 때문이다.const enum BrushType { CIRCLE, // 0 SQUARE, // 1};const draw = (brush: BrushType) =&amp;gt; { if (brush === BrushType.CIRCLE) return console.log(&#39;Circle&#39;); if (brush == BrushType.SQUARE) return console.log(&#39;Square&#39;); return console.log(&#39;Nothing!&#39;);};draw(BrushType.CIRCLE);draw(&#39;Hello&#39;); // Error위와 같은 방법으로 사용할 수 있다.Type Union을 이용한 Enum그런데 몇가지 되지도 않는 선택지 때문에 enum 객체를 선언하기 애매한 상황이라면 다음과 같은 선택지도 존재한다.const paint = (brush: &#39;square&#39; | &#39;circle&#39;) =&amp;gt; { if (brush === &#39;square&#39;) return console.log(&#39;square&#39;); if (brush === &#39;circle&#39;) return console.log(&#39;circle&#39;); return console.log(&#39;nothing&#39;);};&#39;square&#39; | &#39;circle&#39;와 같은 방식으로 유효 범위를 지정하여 Type을 간단하게 만들 수 있다." }, { "title": "[Typescript] 10. 클래스", "url": "/posts/10.class/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Classtypescript를 쓰는 이유라고 할 수 있는 class이다.javascript에서도 class문법이 이미 있긴 하지만 우리가 원하는 객체지향 프로그래밍 언어 수준까지는 지원해주지 않기 때문에 javascript에서의 class는 그저 좀 더 구체적인 객체처럼 다루기 위해서 쓰는 것에 불과했기 때문이다.Fieldclass Point { x: number; y: number;}const pt = new Point();객체의 타입 선언과 비슷한 문법으로 class의 field 정의를 할 수 있다. (다만 위 코드는 오류가 날 것이다.)초기화 생략위 코드를 직접 실행 해봤다면 에러가 표시 되는 것을 확인할 수 있었을 것이다.class를 구성하고 있는 변수들은 반드시 constructor에서 초기화를 진행해줘야 하기 때문이다.만약 멤버 변수들의 정의만을 하고 싶을 뿐, constructor에서 초기화를 진행하고 싶지 않다면 확정 할당 연산자(Non-null assertion operator)를 사용한다. !class Point { x!: number; y!: number;}const pt = new Point();console.log(pt.x, pt.y); // undefined undefined멤버 변수 이름 뒤에 !를 붙이면 constructor에서 초기화를 해야하는 의무를 선택사항으로 만들 수 있다.다만 초기화를 진행하지 않으면 undefined가 나오게 된다.Readonly멤버 변수에 readonly 속성을 사용할 수도 있다.class Greeter { readonly name: string = &quot;world&quot;; constructor(otherName?: string) { if (otherName !== undefined) { this.name = otherName; } } err() { this.name = &quot;not ok&quot;; // Cannot assign to &#39;name&#39; because it is a read-only property. }}const g = new Greeter();g.name = &quot;also not ok&quot;; // Cannot assign to &#39;name&#39; because it is a read-only property.readonly 속성이 주어진 멤버 변수는 클래스 내부에서도, 외부에서도 수정이 불가능한 상태가 된다.Constructor어느 객체지향 언어처럼 생성자 역시 지원한다.class Point { x: number; y: number; // Normal signature with defaults constructor(x = 0, y = 0) { this.x = x; this.y = y; }}constructor라는 이름으로 클래스 내에서 함수를 정의하면 해당 함수는 생성자로서 취급받는다.생성자란?const point: Point = new Point(); 처럼 new연산자를 통해 Instance를 생성할 때 실행되는 함수이다.new Point(1, 2)와 같이 파라미터를 넘겨주면 constructor 함수를 통해 받을 수 있다.Constructor overloadingclass Point { // Overloads constructor(x: number, y: string); constructor(s: string); constructor(xs: any, y?: any) { // TBD }}일반 멤버 함수와 마찬가지로 constructor역시 Overloading이 가능하다.필요하다면 Union Type도 사용할 수 있다.Super call다른 객체지향 언어를 써 본 사람이라면 역시 super도 이해하기 쉬울 것이다.클래스는 exntends를 지원한다. 그렇다면 자식 클래스의 인스턴스를 생성하게 되면 부모 클래스의 constructor는 언제 실행되는 걸까?class Base { constructor() {}}class Children extends Base { constructor() {}}const childrenInstance: Children = new Children();정확히 말하면 부모 클래스의 constructor는 영원히 실행되지 않는다.자식 클래스의 인스턴스를 생성한 것이지 부모의 인스턴스를 생성한 것이 아니기 때문이다.다만 자식 클래스에서 부모 클래스의 생성자를 호출해야만 하는 상황이 생길 수가 있는데, 이럴 경우에 부모의 생성자를 호출하는 함수가 super함수이다.class Base { k = 4;} class Derived extends Base { constructor() { super(); }}super() 형태로 사용하면 부모의 constructor를 호출하게 된다.super를 실행하는 타이밍을 조정하는 식으로 부모 constructor의 실행 주기를 마음대로 할 수 있긴 하지만 가급적이면 constructor의 제일 첫 줄에 선언하는게 베스트이다.super를 실행하지 않으면 부모의 멤버 변수를 참조할 수 없기 때문이다.class Base { k = 4;} class Derived extends Base { constructor() { console.log(this.k); // Error super(); }}GetterJavascript에서 Array.length를 수정해 본 적이 있으면 알겠지만 실제로 값을 재정의 할 때는 아무런 에러가 나오지 않는데도 값을 재정의 한 다음 출력을 해보면 내가 정의한 값이 아닌 올바른 값이 나오는 것을 볼 수 있다.const arr = [1, 2, 3];console.log(arr.length); // 3;arr.length = 777; // OKconsole.log(arr.length); // 3;이런 Attribute는 어떻게 만드는걸까?답은 Getter이다.class Stack&amp;lt;T&amp;gt; { items: T[]; constructor() { this.items = []; } public push(item: T) { this.items.push(item); } public get length(): number { return this.items.length; }}const stack: Stack&amp;lt;number&amp;gt; = new Stack();console.log(stack.length); // 0stack.push(1);console.log(stack.length); // 1stack.length = 777; // Cannot assign to &#39;length&#39; because it is a read-only property.(2540)console.log(stack.length);함수 앞에 get 접근자를 붙이면 해당 함수 이름으로 속성을 꺼낼 때 get 접근자 함수 안에 있는 로직에 따라 값을 꺼내오게 된다.하지만 javascript에서의 예제와는 다르게 read-only 이슈가 발생하여 수정이 되지는 않는다.SetterGetter는 원하는 값을 실제로 존재하지 않는 멤버 변수명을 통해 얻어올 수 있는 방법임을 알았다.그러면 Setter도 대충 감이 올텐데, Setter는 대입 연산자(=)를 통해 Attribute에 값을 대입할 때, 정직하게 대입만 하는 것이 아닌 특정 로직을 거쳐서 값에 변조를 줄 때 사용한다.class Square { x!: number; y!: number; public set square(area: number) { this.x = Math.sqrt(area); this.y = Math.sqrt(area); }}const rect: Square = new Square();console.log(rect.x, rect.y); // undefined undefinedrect.square = 25;console.log(rect.x, rect.y); // 5, 5정사각형의 넓이를 입력받아서 x와 y의 길이를 구하는 클래스이다.다만 한가지 다른 점이 있다면, x와 y를 직접 초기화하지 않았음에도 불구하고 x와 y의 값이 설정 되었다는 점이다.set 설정자 통해 함수를 정의하면 해당 함수 이름을 속성처럼 사용할 수 있다.속성에 값을 대입하면 그 값을 parameter로 넘기게 되고, set함수를 실행하게 되는 것이다.Index Signatures여기서 일반 객체와 마찬가지로 Index Signatures를 사용할 수 있다.class MyClass { [s: string]: boolean | ((s: string) =&amp;gt; boolean); check(s: string) { return this[s] as boolean; }}Class HeritageClass도 interface를 통해 멤버들의 범위를 정해줄 수 있다.interface Pingable { ping(): void;} class Sonar implements Pingable { ping() { console.log(&quot;ping!&quot;); }} class Ball implements Pingable { pong() { // Error. console.log(&quot;pong!&quot;); }}Overriding다른 객체지향 언어처럼 Overriding을 지원한다.부모 클래스가 갖고있는 멤버 함수와 동일한 이름으로 설정 하되, parameter의 type이나 갯수를 다르게 설정하는 방식으로 사용한다.class Base { greet() { console.log(&quot;Hello, world!&quot;); }} class Derived extends Base { greet(name?: string) { if (name === undefined) { super.greet(); } else { console.log(`Hello, ${name.toUpperCase()}`); } }} const d = new Derived();d.greet();d.greet(&quot;reader&quot;);super 키워드를 통해 부모의 메소드에 접근 할 수도 있다.RelationshipA클래스와 B클래스가 서로 다르다는 것을 Typescript는 어떻게 구분할까?일반 객체와 마찬가지로 Class 구성하는 멤버들을 비교하여 구분한다.class Point1 { x = 0; y = 0;} class Point2 { x = 0; y = 0;} // OKconst p: Point1 = new Point2();그렇기 때문에 위 코드가 성립 된다." }, { "title": "[Typescript] 09. 타입 확장", "url": "/posts/09.extending_types/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Extending Typesclass가 상속이 되듯이, type도 상속이 가능하다.type BasicAddress = { name?: string; street: string; city: string; country: string; postalCode: string;} interface AddressWithUnit extends BasicAddress { unit: string;}우편번호를 입력 받을 때, 공통적으로 입력 받아야 하는 항목에 대해서 우선적으로 정의하고 추후에 선택사항을 따로 정의한 interface에 상속하는 방법으로 type을 확장시킬 수 있다. 다만, extends 키워드는 interface에서만 사용할 수 있다.다중 상속interface Colorful { color: string;} interface Circle { radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = { color: &quot;red&quot;, radius: 42,};,(콤마)를 통해 상속받을 대상을 여러 개 지정할 수 있다.교차 타입비록 type에서 extends를 사용하진 못하지만 비슷한 효과를 낼 수 있는 방법이 있다.type testA = { a: number,}type testB = { b: string,}type testC = testA &amp;amp; testB &amp;amp; { good: boolean };const obj: testC = { a: 1, b: &#39;asd&#39;, good: true,}&amp;amp; 연산자를 사용하면 여러 type을 하나로 묶을 수 있다." }, { "title": "[Typescript] 08. 인덱스 서명", "url": "/posts/08.index_signatures/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Index Signature아주 가끔 객체 안에 들어있는 속성들의 key를 특정짓지 못하는 경우가 있을 수 있다.그런 경우 객체 속성의 key를 모르는 상태이기 때문에 Type 정의에도 지장이 생긴다. 이럴 경우에는 인덱스 서명 방식을 사용할 수 있다.type Props = { [key: number]: string | boolean | Function,};const props: Props = { title: &#39;Hello world!&#39;, 1: &#39;good&#39;, // Type &#39;{ title: string; 1: string; }&#39; is not assignable to type &#39;Props&#39;. Object literal may only specify known properties, and &#39;title&#39; does not exist in type &#39;Props&#39;.(2322)};type을 정의할 때 정확히 어떤 key로 속성이 정의 될 지 확실하지가 않다면 key가 될 수 있는 type만을 기재하여 유동적으로 객체를 확장할 수 있다. 반드시 Index Signatures의 속성은 string 혹은 ```number``여야 한다. 주의할 점 ```typescripttype Props = { [key: string]: string | boolean | Function, type: string, // OK index: number, // Property ‘index’ of type ‘number’ is not assignable to ‘string’ index type ‘string | boolean | Function’.(2411)};const props: Props = { index: 1,};Index Signatures를 사용하면 반드시 나머지 속성들도Index Signatures```의 유형을 따라야 한다." }, { "title": "[Typescript] 07. 읽기 전용", "url": "/posts/07.readonly/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "ReadonlyJavascript에서 객체를 구성하는 수많은 Attributes는 Writable하면서 Readable하다.따지고 보면 수정하면 안되는 Attribute마저도 수정이 가능하다.const test = &#39;good&#39;;console.log(test.length); // 4;test.length = 777; // successconsole.log(test.length); // 4;string이나 array의 length Attribute에 직접 값을 입력하는게 가능하다.물론 실제로 값이 변경되어 엉뚱한 값이 나오는 것은 아니지만 값을 대입 할 때 아무런 오류 없이 통과가 된다는 것 자체가 원하는 그림이 아니다. Javascript는 기본적으로 const로 정의 된 값이 아니라면 재정의가 가능하기 때문에 생기는 이슈이다.이번엔 같은 소스코드를 Typescript에서 실행시켜보자.const test = &#39;good&#39;;console.log(test.length); // 4;test.length = 777; // Cannot assign to &#39;length&#39; because it is a read-only Attribute.(2540)console.log(test.length);우리가 원하는대로 length Attribute가 read-only 값으로 인식되어 수정이 불가능하다.Typescript에는 readonly키워드가 있기 때문에 가능한 일이다.type ButtonProps = { title?: string, disabled?: boolean, readonly onPress?: Function,};const submitButtonProps: ButtonProps = { title: &#39;전송&#39;, onPress: (): void =&amp;gt; console.log(&#39;Submit!&#39;),};submitButtonProps.onPress = () =&amp;gt; console.log(&#39;Not Submit!&#39;); // Cannot assign to &#39;onPress&#39; because it is a read-only Attribute.(2540)// ...위 예제처럼 ButtonProps Type을 정의하고, submitButtonProps 객체를 ButtonProps Type으로 정의한다면 onPress Attribute에 대하여 최초로 정의한 값에서 재정의를 진행할 때 에러를 뱉는다.주의할 점readonly 키워드가 정의되면 모든 방식의 수정을 차단하는 것은 아니다. readonly 키워드는 대상의 재정의만을 차단하는 속성이기 때문이다.Readonly 속성이 붙은 객체의 Attribute 수정type ButtonProps = { title?: string, disabled?: boolean, readonly onPress?: Function, readonly children: { a: Number, b: Number },};const submitButtonProps: ButtonProps = { title: &#39;전송&#39;, onPress: (): void =&amp;gt; console.log(&#39;Submit!&#39;), children: { a: 1, b: 2, }};submitButtonProps.children.a = 2;submitButtonProps.children은 readonly Attribute가 맞지만, submitButtonProps.children.a는 readonly가 아니므로 수정이 가능하다.구조가 동일한 서로 다른 type의 재정의interface Person { name: string; age: number;} interface ReadonlyPerson { readonly name: string; readonly age: number;} let writablePerson: Person = { name: &quot;Person McPersonface&quot;, age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints &#39;42&#39;writablePerson.age++;위 소스코드를 보면 writablePerson은 모든 Attributes의 수정이 가능한 Interface인 Person을 Type으로 사용했다.그런데 ReadonlyPerson이라는 type을 보면 모든 Attribute가 readonly로 정의 되어있다.변수 readonlyPerson은 ReadonlyPerson Type을 따르기 때문에 Attributes의 재정의가 원래는 불가능 해야한다. 하지만 readonlyPerson의 값을 WritablePerson Type을 베이스로 정의 된 writablePerson 변수로 정의했으니 readonlyPerson의 Attributes마저 수정이 가능하다.왜냐하면 변수를 대입하는 과정에서 Type의 호환 여부를 식별할 때 readonly는 비교 대상에서 제외되기 때문이다.재정의가 불가능한 Arraytype ArrayType = readonly [number, number, number];const arr: ArrayType = [1, 2, 3];arr[1] = 1; // Cannot assign to &#39;1&#39; because it is a read-only property.console.log(arr);객체 뿐 아니라 배열도 readonly 속성을 통해 데이터의 재정의를 막을 수 있다.type 정의를 하지 않는 재정의가 불가능한 Arrayconst arr = [1, 2, 3, 4, 5, 6, 7] as const;readonly 튜플을 이용하여 배열을 정의하면 해당 배열의 type이 자동으로 readonly [1, 2, 3, 4, 5, 6, 7]이 된다." }, { "title": "[Typescript] 06. 오버로딩", "url": "/posts/06.overloading/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Function Overloading다른 언어를 써 본 경험이 있다면 Overloading가 뭔지 알 것이다.하지만 Javascript가 시작 언어고, 다른 언어를 전혀 써본 경험이 없다면 생소할 수 있는데, 쉽게 말해서 동일한 함수에 넘기는 Parameter로 실행 로직을 달리하는 방법이라고 보면 된다.만약에 매개변수로 a b c라는 number를 넘겨받는 함수가 있다고 생각해보자.이 함수의 기능은 a와 b만 입력된다면 덧셈을, a와 b와 c가 입력 된다면 곱셈을 처리하는 기능을 갖고 있다.이를 Javascript로 처리한다면 아래와 같이 처리할 수 있다.const numberLogic = (a, b, c) =&amp;gt; { if (!c) return a + b; return a * b * c;};뭐… 문제는 없는데, a와 b와 c를 함수에게 어떻게 전달해야 하는지 메뉴얼이 부족하다.Typescript에서는 Overloading을 통해 더욱 명시적으로 작성할 수 있다.function numberLogic(a: number, b: number): number;function numberLogic(a: number, b: number, c: number): number;function numberLogic(a: any, b: any, c?: any): number { if (!c) return a + b; return a * b * c;}console.log(numberLogic(1, 2));console.log(numberLogic(1, 2, 3));console.log(numberLogic(1, 2, &#39;a&#39;)); // error분명 함수의 구현부는 매개변수의 type을 any로 받고 있지만 매개변수에 문자열을 넘기면 에러가 난다.구현부의 로직은 Overloading된 함수들의 요구사항을 충족하기 위한 개념일 뿐이고, Function Prototype의 요구 조건 중 하나를 충족해야만 실행이 가능하다.Union TypeOverloading이라는 개념은 이제 알겠는데, 개인적으로는 좀 별로다.일단 const a = () =&amp;gt; 구조를 사용할 수 없다는 점이 첫번째, 유효한 Type을 선언하기 위해서 Prototype을 선언해야 한다는 것 자체가 솔직히 부담스럽다.나같은 사람을 위해서 Typescript는 Type변화가 거의 없는 심플한 구조에 적용하기 좋은 연산자를 제공한다.const len = (x: string | any[]): number =&amp;gt; x.length;배열 혹은 문자열이 와야하는 심플한 구조의 경우 | 연산자를 통해 쉽게 구현할 수 있다." }, { "title": "[Typescript] 05. 필수가 아닌 파라미터", "url": "/posts/05.optional_parameters/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Optional ParametersJavascript에서는 함수의 선언부에서 표기 된 Parameters 갯수를 전부 충족시키지 않은 실행이 이루어져도 에러가 나지 않는다.const consolePrint = (a, b, c) =&amp;gt; { console.log(a, b, c);};consolePrint(1, 2); // 1, 2, undefined그저 undefined로 출력이 될 뿐 에러 요소는 아니다.하지만 Typescript에서는 Paramters 갯수도 강제성을 띈다.const consolePrint = (a: number, b: number, c: number) =&amp;gt; { console.log(a, b, c);};consolePrint(1, 2); // Expected 3 arguments, but got 2만약 매개변수를 굳이 받지 않아도 되는 부분이라면 생략할 수도 있을텐데 좀 너무한 부분이다.그래서 Typescript에는 Parameter를 Optional(선택적)으로 받을 수 있도록 연산자를 지원한다.const consolePrint = (a: number, b: number, c?: number) =&amp;gt; { console.log(a, b, c);};consolePrint(1, 2); // 1, 2, undefined생략해도 되는 parameters 이름 뒤에 ? 연산자를 붙여주면 해당 parameter는 생략이 가능하다.여담const consolePrint = (a: number, b?: number, c: number) =&amp;gt; { // A required paramter cannot follow optional paramter. console.log(a, b, c);};consolePrint(1, 2);당연한 소리겠지만 Optional Paramter 뒤에는 Required Paramter를 정의할 수 없다." }, { "title": "[Typescript] 04. 제네릭", "url": "/posts/04.generic/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Generic Function만약 당신이 Java를 익숙하게 사용하는 개발자라면 이 섹션은 이해하기 정말 쉬울 것이다. 다른 언어에서 흔히들 Generic이라고 부르는 것과 동일하기 때문이다.예를 들어, 당신이 Stack 자료구조를 직접 구현한다고 해보자.Stack에는 정말로 많은 Type의 데이터가 들어간다. Number String Boolean와 같은 모든 유형을 포함해야 한다.class Stack { private data = []; public push(item) { this.data.push(item); } public pop() { return this.data.pop(); }}물론 이런 형태로 작성할 수는 있겠으나, 우리가 원하는 Typescript의 형태를 띄려면 각 Method와 Paramter의 Return Type을 정의해야 한다.만약 제네릭이 없다면class NumberStack { private data: number[] = []; public push(item: number) { this.data.push(item); } public pop(): number { return this.data.pop(); }}class StringStack { private data: string[] = []; public push(item: string) { this.data.push(item); } public pop(): string { return this.data.pop(); }}/// ...이런 식으로 모든 유형에 대응하는 StackClass를 정의해야 할 것이다.이건 사실 말이 안되므로, 제네릭을 사용해서 구현을 하면 아래와 같이 표현할 수 있다.class Stack&amp;lt;T&amp;gt; { private data: T[] = []; public push(item: T) { this.data.push(item); } public pop(): T | null { return this.data.pop() || null; }}class 이름 뒤에 &amp;lt;T&amp;gt;가 추가 되었다.이는 Type을 받을 수 있는 Type Variable이라고 불린다. 제네릭 타입의 객체를 사용할 때는 아래와 같이 사용하면 된다.const stack: Stack&amp;lt;number&amp;gt; = new Stack&amp;lt;number&amp;gt;();이렇게 선언하면 number타입으로 구성 된 Stack 클래스를 사용할 수 있다.예시class Stack&amp;lt;T&amp;gt; { private data: T[] = []; public push(item: T) { this.data.push(item); } public pop(): T | null { return this.data.pop() || null; }}const stack = new Stack&amp;lt;number&amp;gt;();stack.push(123);console.log(stack.pop()); // 123console.log(stack.pop()); // null두 개 이상의 Type VariableType Variable은 여러개를 선언할 수도 있다.class Stack&amp;lt;T, U&amp;gt; { private data: [T, U][] = []; public push(item: [T, U]) { this.data.push(item); } public pop(): [T, U] | null { return this.data.pop() || null; }}const stack: Stack&amp;lt;number, string&amp;gt; = new Stack&amp;lt;number, stirng&amp;gt;();stack.push([123, &#39;hello&#39;]);console.log(stack.pop()); // [123, &#39;hello&#39;]console.log(stack.pop()); // nullType 상속가독성 측면에서 쓸 일이 진짜 없을 것 같지만 가능은 하다고 하니 알아보겠다.function getFirst&amp;lt;T extends Stack&amp;lt;U&amp;gt;, U&amp;gt;(container: T): U { const item = container.pop(); container.push(item); return item;}getFirst&amp;lt;Stack&amp;lt;number&amp;gt;, number)(numberStack);getFirst&amp;lt;number, number&amp;gt;(1); // Type &#39;number&#39; does not satisfy the constraint &#39;Stack&amp;lt;number&amp;gt;&#39;.참고DailyEngineering - TypeScript: 제네릭(Generic)" }, { "title": "[Typescript] 03. 시그니처", "url": "/posts/03.signatures/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "type DescribableFunction = { description: string; (someArg: number): boolean;};function doSomething(fn: DescribableFunction) { console.log(fn.description + &quot; returned &quot; + fn(6));}위 예제는 처음 봤을 때 뭔 소린가 싶었는데, 해석 된 글을 보고 이해한 것을 바탕으로 쉽게 풀어보겠다.Javascript의 객체들은 Property를 가질 수 있다. 예를 들어보자.const text = String(&quot;text&quot;); // &quot;text&quot;const defaultStringLength = String.length; // 1String객체는 String 자체를 함수 형태로 사용하는게 가능하지만, String객체의 Property인 length에 직접 접근하여 숫자를 가져오는 것도 가능하다. (다른 객체지향 언어의 Static Member Variable을 생각하면 편할 듯 하다.)바로 이런 경우를 type으로 정의한게 아래와 같은 코드이다.type DescribableFunction = { description: string; (someArg: number): boolean;};DescribableFunction Type은 DescribableFunction(123) 이러한 형태로 사용하는 것도 가능하지만, DescribableFunction.description 형태로 사용하는 것도 가능한 구조라는 얘기이다.Construct Signatures위 섹션을 봤다면 본 섹션은 어렵지 않게 이해할 수 있을 것이다.Type은 생성자의 규칙마저도 선언이 가능하다.type SomeConstructor = { new (s: string): SomeObject;};function fn(ctor: SomeConstructor) { return new ctor(&quot;hello&quot;);}Type 객체 member에 new 연산자만 붙여주면 해당 Type의 클래스는 반드시 선언 된 Type과 동일한 형태의 Constructor를 가져야만 한다.Vanila Javascript에서 Class를 사용하는건 드문 일이니 익숙하지 않을 수 있는 부분이다." }, { "title": "[Typescript] 02. 함수 타입 표현식", "url": "/posts/02.function_type_expression/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "function greeter(fn: (a: string) =&amp;gt; void) { fn(&quot;Hello, World&quot;);}function printToConsole(s: string) { console.log(s);} greeter(printToConsole);위 예제처럼 매개변수로 함수가 넘어오는 경우, 함수 갖고있는 매개변수와 해당 함수가 return하는 값의 Type을 설정하여, 해당 기능을 하는 함수들만 매개변수로 받을 수 있다.함수 greeter는 매개변수로 string Type의 변수를 한 개 받는 Return Type이 void인 함수 printToConsole을 정상적으로 받는 모습을 볼 수 있다.그런데 아무리 봐도 매개변수 자리에 fn: (a: string) =&amp;gt; void가 오는건 솔직히 부담스럽다. 너무 길고 복잡하다.type GreetFunction = (a: string) =&amp;gt; void;function greeter(fn: GreetFunction) { // ...}그렇다면 이건 어떤가? type 선언은 number나 boolean과 같은 Type을 직접 커스터마이징 할 수 있는 선언문이다.일반 변수나 상수를 정의할 때와 동일한 방법을 사용하는데, 연산자 뒤에 들어오는 값은 위 코드와 같은 함수의 선언부나 객체가 들어갈 수 있다." }, { "title": "[Typescript] 01. Typescript를 왜 쓸까?", "url": "/posts/01.Typescript-%EA%B8%B0%EC%B4%88/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Type의 불확실성 제거Javascript를 사용해봤다면 아래와 같은 문제를 만난 적이 있을 것이다.message.toLowerCase();message();방대한 소스코드에서 저 부분만을 딱 잘라서 보여줬다고 가정할 때 위 코드를 실행하면 어떤 결과가 나올 것 같은가?그건 아무도 모른다. 왜나하면 message가 프로그램 내부에서 어떻게 정의 되고 변경 되는지 알 수가 없기 때문이다. javascript에서 위 코드를 안정적으로 실행하기 위해서는 다음과 같은 확인 사항이 있다. message라는 값이 있긴 한가? message 안에 toLowerCase라는 메소드가 있는가? message는 function의 역할도 수행할 수 있는가?하지만 Javascript는 기본적으로 위 궁금증들을 해결해주지 않는다. Type은 애초에 변수 정의 할 때 조차 확정되지 않으며 추후 값을 없애거나 Type을 변경하는 것도 가능하기 때문이다.message에 만약에 Hello world가 들어가있다고 가정해보면 message.toLowerCase()는 정상 실행이 될 것임을 짐작할 수 있다.다만 아래쪽은 TypeError: message is not a function 이라는 에러가 표시 될 뿐이다.만약 저 message가 function이 맞다고 하더라도 저기서 반환 되어 나오는 값이 어떤 Type을 갖고있는지 전혀 모르기 때문에 추후 로직 구성에도 많은 예외 처리가 필요하다.Typescript는 위 이슈에 대해서도 아주 깔끔한 경고문을 보여준다.const message = &quot;hello!&quot;; message();This expression is not callable. Type &#39;String&#39; has no call signatures.비예외 실패const user = { name: &quot;Daniel&quot;, age: 26,};user.location;Javascript에서는 user.location을 참조해봤자 undefined 한줄 띡 뱉어놓고 끝난 다는 것을 모두 알 것이다. 그 어떤 Exception조차 반환하지 않는다.반면에 Typescript는const user = { name: &quot;Daniel&quot;, age: 26,}; user.location;// Property &#39;location&#39; does not exist on type &#39;{ name: string; age: number; }&#39;.선언 당시에 존재하지 않은 Property에 대해서 참조하려고 하면 Type Error가 표시된다.오타 보정const announcement = &quot;Hello World!&quot;; // How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase(); // We probably meant to write this...announcement.toLocaleLowerCase();Typescript는 위처럼 대소문자 이슈에 대해서도 오타를 바로잡아준다." }, { "title": "[Typescript] 00. 개요", "url": "/posts/00.Typescript-%EA%B0%9C%EC%9A%94/", "categories": "Tech, Typescript, Tutorial", "tags": "Typescript", "date": "2022-01-18 00:00:00 +0800", "snippet": "Typescript개요Typescript는 Javascript의 수많은 개량 버전 중 하나이고, 그 중 가장 많은 사랑을 받고 있다.Javascript에서는 지원하지 않는 객제지향 문법을 지원하며 Javascript보다 엄격한 문법 검사를 시행하기에 에러가 상대적으로 적은 코드를 작성할 수 있다.또한 Javascript는 변수 간 Type 변환이 정말 자유롭다.별다른 조치를 취하지도 않았는데 값을 대입한 것 만으로도 string, number, Boolean을 제 집 안방마냥 드나드는 자율성을 가졌다.하지만 이로 인한 문제도 생겼는데 각 Type마다 존재하는 고유의 Property와 Method가 존재하는지 확신할 수가 없다는 점이다.변수에 값만 대입하면 Type이 바뀌어버리니 기존에는 문자열이였던 변수의 .length를 참조하는 로직을 사용할 때 조차 정말로 저 변수가 string이 맞는지 확인을 해야한다.Typescript는 이름답게 Type을 기초로 만들어지다보니 매개변수나 변수에 들어갈 Type을 확정지을 수 있다.장점 보다 엄격한 문법으로 에러가 적은 코드를 만들 수 있다. 객체지향 언어에서나 볼 수 있었던 class interface extends implement 등을 사용할 수 있다. Javascript의 슈퍼셋이다보니 Typescript안에서 기존 Javascript문법을 완전 지원한다. Typescript 컴파일러를 통해 나오는 결과물은 최종적으로 Javascript에 완전 대응되기 때문에 호환성 문제도 걱정 없다. 위에서 기재한 이유로 기존 Javascript 프로젝트의 Migration도 매우 간단하다." } ]
